// SPDX-License-Identifier: GPL-2.0-only
//
// Copyright (c) 2025 - Greg Kroah-Hartman <gregkh@linuxfoundation.org>
// Copyright (c) 2025 - Sasha Levin <sashal@kernel.org>
//

use crate::state::{found_in, DyadState};
use cve_utils::Kernel;
use log::{debug, error};
use owo_colors::{OwoColorize, Stream::Stdout};
use std::cmp::Ordering;

/// Process reverted backport pairs, adding them to the appropriate state sets.
/// The context parameter is used for debug messages to identify the call site.
fn process_reverted_pairs(state: &mut DyadState, reverted_pairs: Vec<(Kernel, Kernel)>, context: &str) {
    for (vuln_kernel, fix_kernel) in reverted_pairs {
        debug!(
            "Found revert-based fix ({}): {} ({}) -> {} ({})",
            context,
            vuln_kernel.git_id(), vuln_kernel.version(),
            fix_kernel.git_id(), fix_kernel.version()
        );

        // Add to sets with O(1) deduplication checks
        state.add_to_vulnerable_set(vuln_kernel.clone());
        state.add_to_fixed_set(fix_kernel.clone());
        state.add_revert_pair(vuln_kernel, fix_kernel);
    }
}

/// Find all kernels where the fixing git commits have been backported
pub fn find_fixed_kernels(state: &mut DyadState) {
    // Clone git_sha_full to avoid borrow conflicts when mutating state
    let git_sha_list = state.git_sha_full.clone();
    // Find all of the places where each git commit was backported to and save them off
    for git_sha in &git_sha_list {
        let result = found_in(state, &git_sha.git_id());
        for kernel in result.kernels {
            // Add to fixed set with O(1) deduplication check
            state.add_to_fixed_set(kernel);
        }
        // Note: We don't process reverted_pairs here because if someone backported a fix
        // and then reverted it, that branch is still vulnerable, not fixed.
    }

    let num_fixed = state.fixed_set.len();
    debug!("We have found {num_fixed} fixed kernel version/commits by these git ids:");
    if (num_fixed) == 0 {
        error!(
            "No vulnerable and then fixed pairs of kernels were found for the provided commit(s)",
        );
        std::process::exit(1);
    }
    for k in &state.fixed_set {
        debug!("\t{:<12}{}\t{}", k.version(), k.git_id(), k.is_mainline());
    }
}

/// Add explicitly provided vulnerable commits to the vulnerable set
pub fn add_provided_vulnerabilities(state: &DyadState) -> Vec<Kernel> {
    let mut vulnerable_kernels: Vec<Kernel> = vec![];

    if !state.vulnerable_sha.is_empty() {
        // We are asked to set the original vulnerable kernel to be a specific
        // one, or many, so no need to look it up.
        for k in &state.vulnerable_sha {
            println!(
                "{} {} {} {}",
                "# \tSetting original vulnerable kernel to be kernel"
                    .if_supports_color(Stdout, |x| x.green()),
                k.version().if_supports_color(Stdout, |x| x.cyan()),
                "and git id".if_supports_color(Stdout, |x| x.green()),
                k.git_id().if_supports_color(Stdout, |x| x.cyan())
            );
            // Save off this commit
            vulnerable_kernels.push(k.clone());
        }
    }

    vulnerable_kernels
}

/// Derive vulnerabilities from fixing SHAs when no explicit vulnerable commits were provided
pub fn derive_vulnerabilities(state: &mut DyadState, vulnerable_kernels: &mut Vec<Kernel>) {
    if state.vulnerable_sha.is_empty() {
        // Clone git_sha_full to avoid borrow conflicts when mutating state
        let git_sha_list = state.git_sha_full.clone();
        // Only try to derive vulnerabilities from the fixing SHA1s if no explicit vulnerable commits were provided
        for git_sha in &git_sha_list {
            // Get the list of all valid "Fixes:" entries for this commit
            if let Ok(fix_ids) = state.verhaal.get_fixes(&git_sha.git_id()) {
                for fix_id in fix_ids {
                    // Find all places this introducing commit was backported to
                    let result = found_in(state, &fix_id.git_id());

                    // Process non-reverted backports as vulnerable
                    for kernel in result.kernels {
                        let kernel_is_mainline = kernel.is_mainline();

                        if kernel_is_mainline {
                            // For mainline kernels, use the original fix ID
                            debug!("Creating vulnerable set (mainline): {fix_id:?}");
                            state.vulnerable_set.push(fix_id.clone());
                        } else {
                            // For non-mainline kernels, use the backported ID
                            debug!("Creating vulnerable set (stable): {kernel:?}");
                            state.vulnerable_set.push(kernel);
                        }
                    }

                    // Process reverted backports: the backport was vulnerable, the revert is a fix
                    process_reverted_pairs(state, result.reverted_pairs, "derive_vulnerabilities");
                }
            } else {
                // No fixes found, check if this is a revert commit
                let revert_result = state.verhaal.get_revert(&git_sha.git_id());
                match revert_result {
                    Ok(revert) => {
                        debug!("{git_sha:?} is a revert of {revert:?}");

                        // Save off this commit
                        vulnerable_kernels.push(revert.clone());

                        // Find all backports of this revert
                        let result = found_in(state, &revert.git_id());

                        for kernel in result.kernels {
                            let kernel_is_mainline = kernel.is_mainline();
                            if kernel_is_mainline {
                                // For mainline kernels, use the original revert ID
                                debug!("Creating vulnerable set for revert (mainline): {revert:?}");
                                state.vulnerable_set.push(revert.clone());
                            } else {
                                // For non-mainline kernels, use the backported ID
                                debug!("Creating vulnerable set for revert (stable): {kernel:?}");
                                state.vulnerable_set.push(kernel);
                            }
                        }
                    }
                    Err(e) => {
                        debug!("{e:?}");
                    }
                }
            }
        }
    } else {
        // When --vulnerable is provided, only use those specific commits
        debug!(
            "Using only explicitly provided vulnerable commits, skipping 'Fixes:' tag processing"
        );
        // Add the explicitly provided vulnerable commits directly to vulnerable_set
        for k in &*vulnerable_kernels {
            state.vulnerable_set.push(k.clone());
        }
    }

    debug!("vulnerable_kernels = {vulnerable_kernels:?}");
}

/// Find backported vulnerable kernels and winnow the vulnerable set
pub fn process_vulnerable_kernels(state: &mut DyadState, vulnerable_kernels: &[Kernel]) {
    // Sort vulnerable kernels topologically
    let mut sorted_vulnerable_kernels = vulnerable_kernels.to_owned();
    sorted_vulnerable_kernels.sort();

    // We now have a list of "vulnerable" kernels in 'vulnerable_kernels', let's find out where
    // they were backported to and create the large list of all vulnerable branches
    for k in sorted_vulnerable_kernels {
        debug!("Finding kernels with id: {}", k.git_id());

        // Find all backports of the vulnerability
        let result = found_in(state, &k.git_id());
        debug!("Found kernels: {:?}", result.kernels);

        for kernel in result.kernels {
            // Check if this is a mainline kernel or not
            let kernel_is_mainline = kernel.is_mainline();

            if kernel_is_mainline {
                // For mainline kernels, use the original full git ID that we're looking at
                debug!("Creating vulnerable set for mainline: {k:?}");
                state.vulnerable_set.push(k.clone());
            } else {
                // For non-mainline kernels, use the kernel_git_id from found_in (the backported ID)
                debug!("Creating vulnerable set for stable: {kernel:?}");
                state.vulnerable_set.push(kernel.clone());
            }
        }

        // Process reverted backports: the backport was vulnerable, the revert is a fix
        process_reverted_pairs(state, result.reverted_pairs, "process_vulnerable_kernels");
    }
    debug!("vulnerable_set = {:?}", state.vulnerable_set);

    // Winnow down the vulnerable set to the most accurate representation
    winnow_vulnerable_set(state, vulnerable_kernels);
}

/// Winnow down the vulnerable set to find the oldest mainline kernel and appropriate stable kernels
fn winnow_vulnerable_set(state: &mut DyadState, vulnerable_kernels: &[Kernel]) {
    // Single-pass approach: split into mainline/stable while finding oldest mainline
    let mut vulnerable_stable_set: Vec<Kernel> = Vec::new();
    let mut oldest_mainline_kernel: Option<Kernel> = None;
    let mut mainline_count = 0;

    for k in &state.vulnerable_set {
        if k.is_mainline() {
            mainline_count += 1;
            // Track oldest mainline (compare returns Less if k is older)
            if oldest_mainline_kernel.is_none()
                || k.compare(oldest_mainline_kernel.as_ref().unwrap()) == Ordering::Less
            {
                oldest_mainline_kernel = Some(k.clone());
            }
        } else {
            vulnerable_stable_set.push(k.clone());
        }
    }

    debug!("vuln_stable_set: {}", vulnerable_stable_set.len());
    debug!("vuln_mainline_set: {mainline_count}");

    let mut vulnerable_set: Vec<Kernel> = Vec::new();

    if let Some(ref oldest_mainline) = oldest_mainline_kernel {
        debug!("vuln_mainline_pair={oldest_mainline:?}");

        // Add explicitly specified vulnerabilities or the oldest mainline kernel
        if vulnerable_kernels.is_empty() {
            vulnerable_set.push(oldest_mainline.clone());
        } else {
            // Build a HashSet for O(1) duplicate checking
            use std::collections::HashSet;
            let explicit_keys: HashSet<(String, String)> = vulnerable_kernels
                .iter()
                .map(|k| (k.version(), k.git_id()))
                .collect();

            vulnerable_set.extend(vulnerable_kernels.to_vec());

            // Add oldest mainline if not already included
            let oldest_key = (oldest_mainline.version(), oldest_mainline.git_id());
            if !explicit_keys.contains(&oldest_key) {
                vulnerable_set.push(oldest_mainline.clone());
            }
        }

        // Add stable entries older than the mainline release
        for k in &vulnerable_stable_set {
            if oldest_mainline.compare(k) == Ordering::Greater {
                debug!("    {:?} is > {:?}", oldest_mainline.version(), k.version());
                vulnerable_set.push(k.clone());
            }
        }
    } else {
        // No mainline kernels, just use all stable ones
        vulnerable_set = vulnerable_stable_set;

        // Add explicitly provided vulnerable kernels with deduplication
        if !vulnerable_kernels.is_empty() {
            use std::collections::HashSet;
            let existing_keys: HashSet<(String, String)> = vulnerable_set
                .iter()
                .map(|k| (k.version(), k.git_id()))
                .collect();

            for k in vulnerable_kernels {
                let key = (k.version(), k.git_id());
                if !existing_keys.contains(&key) {
                    vulnerable_set.push(k.clone());
                }
            }
        }
    }

    debug!("oldest mainline kernel = {:?}", oldest_mainline_kernel);
    debug!(
        "After winnowing, we have found {} sets of vulnerable kernels",
        vulnerable_set.len()
    );
    for k in &vulnerable_set {
        debug!("    {k:?}");
    }

    state.vulnerable_set = vulnerable_set;
}
