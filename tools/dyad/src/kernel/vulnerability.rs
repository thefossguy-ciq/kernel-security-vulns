// SPDX-License-Identifier: GPL-2.0-only
//
// Copyright (c) 2025 - Greg Kroah-Hartman <gregkh@linuxfoundation.org>
// Copyright (c) 2025 - Sasha Levin <sashal@kernel.org>
//

use crate::state::{found_in, DyadState};
use cve_utils::Kernel;
use log::{debug, error};
use owo_colors::{OwoColorize, Stream::Stdout};
use std::cmp::Ordering;

/// Find all kernels where the fixing git commits have been backported
pub fn find_fixed_kernels(state: &mut DyadState) {
    // Find all of the places where each git commit was backported to and save them off
    for git_sha in &state.git_sha_full {
        let result = found_in(state, &git_sha.git_id());
        for kernel in result.kernels {
            // Check if we already have this kernel in our fixed set
            if !state.fixed_set.iter().any(|k| k == &kernel) {
                state.fixed_set.push(kernel);
            }
        }
        // Note: We don't process reverted_pairs here because if someone backported a fix
        // and then reverted it, that branch is still vulnerable, not fixed.
    }

    let num_fixed = state.fixed_set.len();
    debug!("We have found {num_fixed} fixed kernel version/commits by these git ids:");
    if (num_fixed) == 0 {
        error!(
            "No vulnerable and then fixed pairs of kernels were found for the provided commit(s)",
        );
        std::process::exit(1);
    }
    for k in &state.fixed_set {
        debug!("\t{:<12}{}\t{}", k.version(), k.git_id(), k.is_mainline());
    }
}

/// Add explicitly provided vulnerable commits to the vulnerable set
pub fn add_provided_vulnerabilities(state: &DyadState) -> Vec<Kernel> {
    let mut vulnerable_kernels: Vec<Kernel> = vec![];

    if !state.vulnerable_sha.is_empty() {
        // We are asked to set the original vulnerable kernel to be a specific
        // one, or many, so no need to look it up.
        for k in &state.vulnerable_sha {
            println!(
                "{} {} {} {}",
                "# \tSetting original vulnerable kernel to be kernel"
                    .if_supports_color(Stdout, |x| x.green()),
                k.version().if_supports_color(Stdout, |x| x.cyan()),
                "and git id".if_supports_color(Stdout, |x| x.green()),
                k.git_id().if_supports_color(Stdout, |x| x.cyan())
            );
            // Save off this commit
            vulnerable_kernels.push(k.clone());
        }
    }

    vulnerable_kernels
}

/// Derive vulnerabilities from fixing SHAs when no explicit vulnerable commits were provided
pub fn derive_vulnerabilities(state: &mut DyadState, vulnerable_kernels: &mut Vec<Kernel>) {
    if state.vulnerable_sha.is_empty() {
        // Only try to derive vulnerabilities from the fixing SHA1s if no explicit vulnerable commits were provided
        for git_sha in &state.git_sha_full {
            // Get the list of all valid "Fixes:" entries for this commit
            if let Ok(fix_ids) = state.verhaal.get_fixes(&git_sha.git_id()) {
                for fix_id in fix_ids {
                    // Find all places this introducing commit was backported to
                    let result = found_in(state, &fix_id.git_id());

                    // Process non-reverted backports as vulnerable
                    for kernel in result.kernels {
                        let kernel_is_mainline = kernel.is_mainline();

                        if kernel_is_mainline {
                            // For mainline kernels, use the original fix ID
                            debug!("Creating vulnerable set (mainline): {fix_id:?}");
                            state.vulnerable_set.push(fix_id.clone());
                        } else {
                            // For non-mainline kernels, use the backported ID
                            debug!("Creating vulnerable set (stable): {kernel:?}");
                            state.vulnerable_set.push(kernel);
                        }
                    }

                    // Process reverted backports: the backport was vulnerable, the revert is a fix
                    for (vuln_kernel, fix_kernel) in result.reverted_pairs {
                        debug!(
                            "Found revert-based fix: {} ({}) was reverted by {} ({})",
                            vuln_kernel.git_id(), vuln_kernel.version(),
                            fix_kernel.git_id(), fix_kernel.version()
                        );

                        // Add the vulnerable backport to vulnerable_set
                        if !state.vulnerable_set.iter().any(|k| k.git_id() == vuln_kernel.git_id()) {
                            state.vulnerable_set.push(vuln_kernel.clone());
                        }

                        // Add the revert to fixed_set
                        if !state.fixed_set.iter().any(|k| k.git_id() == fix_kernel.git_id()) {
                            state.fixed_set.push(fix_kernel.clone());
                        }

                        // Store the direct pair for use in kernel_pairs - we already know
                        // exactly which vulnerable commit this revert fixes
                        if !state.revert_pairs.iter().any(|(v, _)| v.git_id() == vuln_kernel.git_id()) {
                            state.revert_pairs.push((vuln_kernel, fix_kernel));
                        }
                    }
                }
            } else {
                // No fixes found, check if this is a revert commit
                let revert_result = state.verhaal.get_revert(&git_sha.git_id());
                match revert_result {
                    Ok(revert) => {
                        debug!("{git_sha:?} is a revert of {revert:?}");

                        // Save off this commit
                        vulnerable_kernels.push(revert.clone());

                        // Find all backports of this revert
                        let result = found_in(state, &revert.git_id());

                        for kernel in result.kernels {
                            let kernel_is_mainline = kernel.is_mainline();
                            if kernel_is_mainline {
                                // For mainline kernels, use the original revert ID
                                debug!("Creating vulnerable set for revert (mainline): {revert:?}");
                                state.vulnerable_set.push(revert.clone());
                            } else {
                                // For non-mainline kernels, use the backported ID
                                debug!("Creating vulnerable set for revert (stable): {kernel:?}");
                                state.vulnerable_set.push(kernel);
                            }
                        }
                    }
                    Err(e) => {
                        debug!("{e:?}");
                    }
                }
            }
        }
    } else {
        // When --vulnerable is provided, only use those specific commits
        debug!(
            "Using only explicitly provided vulnerable commits, skipping 'Fixes:' tag processing"
        );
        // Add the explicitly provided vulnerable commits directly to vulnerable_set
        for k in &*vulnerable_kernels {
            state.vulnerable_set.push(k.clone());
        }
    }

    debug!("vulnerable_kernels = {vulnerable_kernels:?}");
}

/// Find backported vulnerable kernels and winnow the vulnerable set
pub fn process_vulnerable_kernels(state: &mut DyadState, vulnerable_kernels: &[Kernel]) {
    // Sort vulnerable kernels topologically
    let mut sorted_vulnerable_kernels = vulnerable_kernels.to_owned();
    sorted_vulnerable_kernels.sort();

    // We now have a list of "vulnerable" kernels in 'vulnerable_kernels', let's find out where
    // they were backported to and create the large list of all vulnerable branches
    for k in sorted_vulnerable_kernels {
        debug!("Finding kernels with id: {}", k.git_id());

        // Find all backports of the vulnerability
        let result = found_in(state, &k.git_id());
        debug!("Found kernels: {:?}", result.kernels);

        for kernel in result.kernels {
            // Check if this is a mainline kernel or not
            let kernel_is_mainline = kernel.is_mainline();

            if kernel_is_mainline {
                // For mainline kernels, use the original full git ID that we're looking at
                debug!("Creating vulnerable set for mainline: {k:?}");
                state.vulnerable_set.push(k.clone());
            } else {
                // For non-mainline kernels, use the kernel_git_id from found_in (the backported ID)
                debug!("Creating vulnerable set for stable: {kernel:?}");
                state.vulnerable_set.push(kernel.clone());
            }
        }

        // Process reverted backports: the backport was vulnerable, the revert is a fix
        for (vuln_kernel, fix_kernel) in result.reverted_pairs {
            debug!(
                "Found revert-based fix in process_vulnerable_kernels: {} -> {}",
                vuln_kernel.git_id(), fix_kernel.git_id()
            );

            // Add the vulnerable backport to vulnerable_set
            if !state.vulnerable_set.iter().any(|k| k.git_id() == vuln_kernel.git_id()) {
                state.vulnerable_set.push(vuln_kernel.clone());
            }

            // Add the revert to fixed_set
            if !state.fixed_set.iter().any(|k| k.git_id() == fix_kernel.git_id()) {
                state.fixed_set.push(fix_kernel.clone());
            }

            // Store the direct pair for use in kernel_pairs
            if !state.revert_pairs.iter().any(|(v, _)| v.git_id() == vuln_kernel.git_id()) {
                state.revert_pairs.push((vuln_kernel, fix_kernel));
            }
        }
    }
    debug!("vulnerable_set = {:?}", state.vulnerable_set);

    // Winnow down the vulnerable set to the most accurate representation
    winnow_vulnerable_set(state, vulnerable_kernels);
}

/// Winnow down the vulnerable set to find the oldest mainline kernel and appropriate stable kernels
fn winnow_vulnerable_set(state: &mut DyadState, vulnerable_kernels: &[Kernel]) {
    // Now that we have a list of vulnerable kernels, we need to find the "root"
    // mainline version that had the oldest issue in it. We might have many
    // mainline kernels listed in here, but we only care about the "oldest" one, so
    // throw away all the rest.
    //
    // To do this, we create 2 lists, one for mainline kernels, and one for stable
    // kernels. The stable kernel list we will keep "as is", but for the mainline
    // kernel list, we will sort it and then throw away everything EXCEPT the oldest
    // kernel. After that, we will re-create the vulnerable set with the new
    // information.
    let mut vulnerable_set: Vec<Kernel> = vec![];
    let mut vulnerable_stable_set: Vec<Kernel> = vec![];
    let mut vulnerable_mainline_set: Vec<Kernel> = vec![];
    for k in &state.vulnerable_set {
        if k.is_mainline() {
            vulnerable_mainline_set.push(k.clone());
        } else {
            vulnerable_stable_set.push(k.clone());
        }
    }
    debug!("vuln_stable_set: {}", vulnerable_stable_set.len());
    for k in &vulnerable_stable_set {
        debug!("    {k:?}");
    }
    debug!("vuln_mainline_set: {}", vulnerable_mainline_set.len());
    for k in &vulnerable_mainline_set {
        debug!("    {k:?}");
    }

    // The "default" vulnerable point in mainline where this issue first showed up.
    // We need this for any fix that happened in a stable branch that happened AFTER
    // this point in time (i.e. fixed in 6.6.3 for an issue that showed up in 5.4).
    let mut oldest_mainline_kernel: Kernel = Kernel::empty_kernel();
    if vulnerable_mainline_set.is_empty() {
        // No mainline kernels, so just add all stable ones
        vulnerable_set = vulnerable_stable_set;

        // Also add any explicitly provided vulnerable kernels
        if !vulnerable_kernels.is_empty() {
            for k in vulnerable_kernels {
                // Only add if not already in the set
                if !vulnerable_set
                    .iter()
                    .any(|x| x.version() == k.version() && x.git_id() == k.git_id())
                {
                    vulnerable_set.push(k.clone());
                }
            }
        }
    } else {
        debug!("Trying to find the best mainline kernel to use...");
        let mut sorted_mainline_kernels = vulnerable_mainline_set.clone();
        sorted_mainline_kernels.sort();
        oldest_mainline_kernel = sorted_mainline_kernels[0].clone();

        debug!("vuln_mainline_pair={oldest_mainline_kernel:?}");

        // Add both explicitly specified vulnerabilities and the oldest mainline kernel
        // for detected vulnerabilities
        if vulnerable_kernels.is_empty() {
            // For detected vulnerabilities, use the oldest as default
            vulnerable_set.push(oldest_mainline_kernel.clone());
        } else {
            // Add all explicitly specified vulnerabilities
            vulnerable_set.extend(vulnerable_kernels.to_vec());

            // Also add the oldest mainline kernel if it's not already included
            let already_included = vulnerable_kernels.iter().any(|k| {
                k.version() == oldest_mainline_kernel.version()
                    && k.git_id() == oldest_mainline_kernel.git_id()
            });
            if !already_included {
                vulnerable_set.push(oldest_mainline_kernel.clone());
            }
        }

        // iterate over all of the stable entries, and only add the ones that
        // are "older" than the mainline release.
        for k in &vulnerable_stable_set {
            if oldest_mainline_kernel.compare(k) == Ordering::Greater {
                debug!(
                    "    {:?} is > {:?}",
                    oldest_mainline_kernel.version(),
                    k.version()
                );
                vulnerable_set.push(k.clone());
            }
        }
    }

    debug!("oldest mainline kernel = {oldest_mainline_kernel:?}");
    debug!(
        "After winnowing, we have found {} sets of vulnerable kernels",
        vulnerable_set.len()
    );
    for k in &vulnerable_set {
        debug!("    {k:?}");
    }

    state.vulnerable_set = vulnerable_set;
}
