#!/bin/bash
# SPDX-License-Identifier: GPL-2.0
#
# Copyright (c) 2024 - Greg Kroah-Hartman <gregkh@linuxfoundation.org>
#
# bippy - creates a json and/or mbox file on standard output in the proper
# 	  format to submit a CVE based on a specific git SHA.
#
# Usage:
#	bippy [loads of options, see the help text below]
#
# Right now only works with CVEs, will handle other identifiers as needed.
#
# Name comes from the phrase "you bet your bippy!" as said by David L. Morse.
#
# Requires:
#  A kernel git tree with the SHA to be used in it
#  jo - the json output tool, found at: https://github.com/jpmens/jo
#  id_found_in - tool to find what kernel a specific SHA is in

# set to 1 to get some debugging logging messages (or use -v/--verbose option)
DEBUG=0

# TODO - make these options that are not hard-coded
KERNEL_TREE="/home/gregkh/linux/stable/linux-stable"
FOUND_IN="/home/gregkh/linux/stable/commit_tree/id_found_in"

# Hard coded for now, but maybe come from a file?
ORGID="f4215fc3-5b6b-47ff-a258-f7189bd81038"

# Might be dropped if we don't need the full "container" output, see at the
# bottom for more details
USER="gregkh@linuxfoundation.org"

# don't use unset variables
set -o nounset

# set where the tool was run from,
# the name of our script,
# and the git version of it
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
SCRIPT=${0##*/}
SCRIPT_VERSION=$(cd "${DIR}" && git show -s --abbrev-commit --abbrev=12 --pretty=format:"%h")

# global variables
vuln_kernels=()

help() {
	echo "Usage: $0 [OPTIONS]"
	echo "Create a JSON or MBOX file to report a CVE based on a specific Linux kernel"
	echo "git sha value."
	echo ""
	echo "Arguments:"
	echo " -c, --cve=CVE_NUMBER		The full CVE number to assign"
	echo " -s, --sha=GIT_SHA		The kernel git sha1 to assign the CVE to"
	echo " -j, --json=JSON_FILENAME	Output a JSON report to submit to CVE to the"
	echo "				specified filename"
	echo " -m, --mbox=MBOX_FILENAME	Output a mbox file to submit to the CVE"
	echo "				announce mailing list"
	echo " -h, --help			This information"
	echo " -v, --verbose			Show debugging information to stdout"
	echo ""
	echo "Note, CVE_NUMBER and GIT_SHA are required, as well as at least one of"
	echo "JSON_FILENAME and/or MBOX_FILENAME."
	exit 1
}

dbg() {
	if [[ ${DEBUG} -ge 1 ]] ; then
		echo "$1"
	fi
}


# Parse the command line
short_opts="j:m:c:s:hv"
long_opts="json:,mbox:,cve:,sha:,help,verbose"
JSON_FILE=""
MBOX_FILE=""
CVE_NUMBER=""
GIT_SHA=""

TMP=$(getopt -o "${short_opts}" --long "${long_opts}" --name="${SCRIPT}" -- "$@")
eval set -- "${TMP}"
while :; do
	dbg "arg=${1}"
	case "${1}" in
		-j | --json	) JSON_FILE="${2}";	shift 2 ;;
		-m | --mbox	) MBOX_FILE="${2}";	shift 2 ;;
		-c | --cve	) CVE_NUMBER="${2}";	shift 2 ;;
		-s | --sha	) GIT_SHA="${2}";	shift 2 ;;
		-h | --help	) help ;;
		-v | --verbose	) DEBUG=1;		shift ;;
		-- )		  shift; break ;;
		*		) help ;;
	esac
done

dbg "CVE_NUMBER=${CVE_NUMBER}"
dbg "GIT_SHA=${GIT_SHA}"
dbg "JSON_FILE=${JSON_FILE}"
dbg "MBOX_FILE=${MBOX_FILE}"

if [[ "${CVE_NUMBER}" == "" || "${GIT_SHA}" == "" ]] ; then
	help
fi
if [[ "${JSON_FILE}" == "" && "${MBOX_FILE}" == "" ]] ; then
	help
fi


# Functions for us to use, main flow starts below at ======= point


# Given a short SHA value in $1 (we hope), turn it into an "expanded" sha and
# then look up where that commit came from.
# Might be multiple kernels, so parse accordingly
find_fix() {
	FIX=$1

	id=""
	if [[ ${FIX} =~ [[:xdigit:]]{12} ]] ; then
		id=${BASH_REMATCH[0]}
	else
		# Let's try it again in a cruder way
		id=$(echo "${FIX}" | sed -e 's/^[ \t]*//' | cut -f 2 -d ':' | sed -e 's/^[ \t]*//' | cut -f 1 -d ' ')
	fi

	if [ "${id}" == "" ] ; then
		# can't find a valid sha or something resembing it, so just return
		return
	fi

	long_id=$(cd ${KERNEL_TREE} && git log -1 --format="%H" "${id}")
	if [ "${long_id}" == "" ] ; then
		# git id is not a valid one, so just return
		return
	fi

	release=$("${FOUND_IN}" "${long_id}")
	echo "${release} "
	return
}

# =======
# Main logic starts here

# go into the kernel tree, we need this to be a valid one
#cd ${KERNEL_TREE} || exit 1

# See if the SHA given to us is a valid SHA in the git repo
# and turning the sha into a "full" one so that we don't get this wrong.

GIT_SHA_FULL=$(cd ${KERNEL_TREE} && git log -1 --format="%H" "${GIT_SHA}")
if [[ "${GIT_SHA_FULL}" == "" ]] ; then
	echo "error: git id ${GIT_SHA} is not found in the tree at ${KERNEL_TREE}"
	exit 1
fi

# Get the subject line of our sha
subject=$(cd ${KERNEL_TREE} && git show --no-patch --pretty=format:"%s" "${GIT_SHA_FULL}" 2> /dev/null)
if [[ "${subject}" == "" ]] ; then
	echo "error: git id ${GIT_SHA_FULL} is not found in the tree at ${KERNEL_TREE}"
	exit 1
fi
dbg "subject=${subject}"

# Grab the full commit text, we will use that for many things
commit_text=$(cd ${KERNEL_TREE} && git show --no-patch --pretty=format:"%B" "${GIT_SHA_FULL}")

#echo "commit_text=${commit_text}"

# Look in the commit text to see if there is any "Fixes:" lines
# if so, look them up to see what kernels they were released in.  Need to do
# this with the "expanded" SHA value, the short one will give us too many
# false-positives when it shows up in other Fixes: tags
fixes_lines=$(echo "${commit_text}" | grep -i "fixes:" | sed -e 's/^[ \t]*//' | cut -f 2 -d ':' | sed -e 's/^[ \t]*//' | cut -f 1 -d ' ')
dbg "fixes_lines=${fixes_lines}"
og_vuln="0"
if [ "${fixes_lines}" != "" ] ; then
	# figure out what kernels this commit fixes, (i.e. which are
	# vulnerable) and turn them into an array
	v=()
	for fix_line in ${fixes_lines}; do
		v+=($(find_fix "${fix_line}"))
	done
	# now sort and uniq the list of versions
	vuln_kernels=($(echo "${v[@]}" | sed 's/ /\n/g' | sort -V | uniq))

	dbg "vuln_kernels=${vuln_kernels[@]}"
	# Figure out the "original" oldest commit where this showed up, we need
	# this as a default value in case we can't match up anything else to
	# it.
	og_vuln="${vuln_kernels[0]}"
	dbg "og vuln=${og_vuln}"
fi

# Find the fixed kernels where this release was done
fixed_kernels=$("${FOUND_IN}" "${GIT_SHA_FULL}")
dbg "fixed_kernels=${fixed_kernels}"

# Generate the "vulerable kernel json mess
# TODO, use the ${vuln_kernels} array to match up with the fixed kernels
# somehow, for now we just iterate over the fixed_kernels
vuln_array=""
for v in ${fixed_kernels[@]}; do
	# hack, filter out stuff that is still in the queue.
	# There's a simpler way to do this in bash, I know, but
	# I'm on a plane without wifi and I can't look anything up
	# so just brute-force old-school it with echo/grep
	queue=$(echo "${v}" | grep "queue")
	if [[ "${queue}" == "" ]]; then
		vuln_array+="versions[]=$(jo --	\
			-s lessThan="${v}"	\
			-s status="affected"	\
			-s version="${og_vuln}"	\
			-s versionType="custom"	\
			) "
	fi
done
dbg "vuln_array=${vuln_array}"

#########################
# Compose the json knowing what we now know, using the 'jo' tool
#########################
if [[ "${JSON_FILE}" != "" ]] ; then
	URL="https://git.kernel.org/torvalds/c/${GIT_SHA_FULL}"

	x_generator=$(jo -- engine="${SCRIPT}-${SCRIPT_VERSION}")

	cveMetadata=$(jo -- assignerOrgId="${ORGID}"	\
			cveID="${CVE_NUMBER}"		\
			requesterUserId="${USER}"	\
			-s serial="1"			\
			state="PUBLISHED")

	d=$(jo --				\
		lang="en"			\
		-s value="${commit_text}"	\
		)

	descriptions=$(jo -a -- "${d}")

	providerMetadata=$(jo --		\
		orgId="${ORGID}"		\
		)

	r=$(jo -- 		\
		url="${URL}"	\
		)

	references=$(jo -a -- "${r}")

	versions=$(jo --	\
		-s lessThan="6.7"	\
		-s status="affected"	\
		-s version="0"		\
		-s versionType="custom"	\
	)

	a=$(jo --	\
		product="Linux"			\
		vendor="Linux"			\
		defaultStatus="affected"	\
		${vuln_array}			\
	)

	affected=$(jo -a -- "${a}")

	cna=$(jo --	\
		providerMetadata="${providerMetadata}"	\
		descriptions="${descriptions}"		\
		affected="${affected}"			\
		references="${references}"		\
		title="${subject}"			\
		x_generator="${x_generator}"		\
	)

	# We might just need the "cna" output, and not the "containers" output below.
	# Test with the 'cve' tool a bit, I think this might be able to be dropped as
	# the tool might provide it for us.  If not, then just output the above cna
	# record instead.
	containers=$(jo -- cna="${cna}")

	# output the final combination
	jo -p --					\
		containers="${containers}"		\
		cveMetadata="${cveMetadata}"		\
		-s dataType="CVE_RECORD"		\
		-s dataVersion="5.0"			> "${JSON_FILE}"

	dbg "json file written to ${JSON_FILE}"

fi	# end json creation

#########################
# Compose the mbox file
#########################
if [[ "${MBOX_FILE}" != "" ]] ; then
	cat << EOF > "${MBOX_FILE}"
From: Linux Kernel CVE team <cve@kernel.org>
Subject: ${CVE_NUMBER}: ${subject}

${CVE_NUMBER} has been assigned for the following issue:

${commit_text}

Affected versions:

EOF

	dbg "mbox file written to ${MBOX_FILE}"
fi	# end mbox creation

