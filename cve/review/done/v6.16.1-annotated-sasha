101841c38346 [ceph] parse_longname(): strrchr() expects NUL-terminated string
- [sasha] ## Answer: YES
  This commit should be assigned a CVE because:
  1. **Out-of-bounds memory read vulnerability**: The code was calling `strrchr(name, '_')` on a buffer that was not guaranteed to be NUL-terminated, causing the function to potentially read beyond the allocated memory boundary while searching for the terminator.
  2. **Kernel memory exposure risk**: The vulnerability occurs in kernel space (CephFS filesystem code) and could potentially expose kernel memory contents through out-of-bounds reads.
  3. **User-triggerable**: The vulnerable `parse_longname()` function is called when processing encrypted snapshot names in CephFS, which can be triggered through filesystem operations from userspace.
  4. **Clear security fix**: The commit explicitly fixes a memory safety issue by ensuring proper NUL-termination before any string operations (`kmemdup_nul()` creates a properly terminated copy).
  The vulnerability is similar to classic buffer over-read issues that have historically been assigned CVEs, particularly when they occur in kernel code and can be triggered from userspace.
d99208b91933 fs/ntfs3: cancle set bad inode after removing name fails
- [sasha] YES
  This commit should be assigned a CVE because it fixes a security vulnerability with potential system impact:
  1. **Use-After-Free/Memory Corruption Risk**: The commit message explicitly states "The underlying bug is that make_bad_inode() is called on a live inode" which can lead to memory corruption. The message describes scenarios where:
     - "icache lookup finds a normal inode... while another thread decides to call make_bad_inode() on it - that would evict it from icache"
     - This creates a race condition where the inode is being used while simultaneously being marked bad and evicted
  2. **Exploitable via Corrupted Filesystem**: The vulnerability can be triggered using "a file0 on a ntfs3 file system with a corrupted i_link", meaning an attacker with ability to present a maliciously crafted NTFS filesystem could trigger this issue.
  3. **Code Changes Show Security Fix**: The key change removes the `is_bad` parameter and the problematic `_ntfs_bad_inode(inode)` call:
  ```c
  - if (is_bad) {
  -     /* Restore after failed rename failed too. */
  -     _ntfs_bad_inode(inode);
  - } else if (!err) {
  + if (!err) {
  ```
  4. **Syzbot Report**: The commit references a syzbot report (syzbot+1aa90f0eb1fc3e77d969@syzkaller.appspotmail.com), indicating this was found through fuzzing and is likely exploitable.
  5. **Race Condition with System Impact**: Calling make_bad_inode() on a live inode that's already attached to dentries can cause system instability, potential crashes, or memory corruption that could be exploited for privilege escalation.
  The vulnerability allows corrupted filesystem data to trigger improper inode handling that can lead to memory safety issues, making it a legitimate security vulnerability warranting a CVE assignment.
a49f0abd8959 Revert "fs/ntfs3: Replace inode_trylock with inode_lock"
- [sasha] Let me analyze the commit based on the provided information:
  ## Analysis:
  ### 1. Nature of the Change:
  This commit **reverts** a previous change that replaced `inode_trylock()` with `inode_lock()`. The reversion brings back the conditional lock acquisition pattern using `inode_trylock()`.
  ### 2. Security Implications:
  **Key Code Change:**
  ```c
  - inode_lock(inode);
  + if (!inode_trylock(inode)) {
  +     err = -EAGAIN;
  +     goto out;
  + }
  ```
  ### 3. Security Assessment:
  - **Deadlock Fix**: The commit message explicitly states this fixes a deadlock reported by syzbot. Deadlocks are denial-of-service conditions that can be security-relevant.
  - **Locking Mechanism**: The change moves from unconditional locking (`inode_lock()`) back to conditional locking (`inode_trylock()`). This prevents the thread from blocking indefinitely if the lock is already held, avoiding potential deadlock scenarios.
  - **Impact**: The deadlock could allow local attackers to cause system hangs or denial of service by triggering the specific code path in the NTFS3 filesystem.
  - **Syzbot Report**: The commit references a syzbot report (syzbot+a91fcdbd2698f99db8f4@syzkaller.appspotmail.com), indicating this was a real issue found through fuzzing, which often uncovers security-relevant bugs.
  ### 4. Context from Referenced Commit:
  The original commit (69505fe98f19) that's being reverted was attempting to fix an xfstest issue but inadvertently introduced a deadlock condition.
  ## Decision: **YES**
  This commit should be assigned a CVE because:
  1. It fixes a **deadlock vulnerability** that could be exploited for denial of service
  2. The issue was discovered by syzbot, a security fuzzing tool
  3. Deadlocks in filesystem code can impact system availability and stability
  4. The vulnerability allows potential local DoS attacks through filesystem operations
  5. The change directly addresses a security-relevant locking issue that could hang the system
  The deadlock condition represents a security vulnerability as it can be triggered to cause system unavailability, which qualifies as a denial-of-service vulnerability requiring CVE assignment.
8e1fab9cccc7 block: mtip32xx: Fix usage of dma_map_sg()
- [sasha] YES
  This commit should be assigned a CVE because it fixes a security vulnerability with potential for memory corruption and system instability.
  The vulnerability consists of two critical issues:
  1. **Missing error handling for DMA mapping failure**: The original code did not check if `dma_map_sg()` succeeded. When `dma_map_sg()` fails, it returns 0, but the code proceeded anyway without checking. The fix adds:
  ```c
  +	if (!nents)
  +		return -ENOMEM;
  ```
  2. **Incorrect parameter passing to dma_unmap_sg()**: The code was incorrectly saving the return value of `dma_map_sg()` (which can be different from the input value) to `command->scatter_ents`, then using this same value for `dma_unmap_sg()`. According to DMA API requirements, `dma_unmap_sg()` must receive the original number of entries passed to `dma_map_sg()`, not its return value. The fix corrects this by:
  ```c
  +	command->scatter_ents = blk_rq_map_sg(rq, command->sg);
  +	nents = dma_map_sg(&dd->pdev->dev, command->sg,
  +			   command->scatter_ents, dma_dir);
  ```
  These bugs could lead to:
  - **Memory corruption** from improper DMA unmapping with incorrect scatter-gather entry counts
  - **System crashes** from operating on failed DMA mappings
  - **Data integrity issues** in storage operations
  - **Potential privilege escalation** through kernel memory corruption
  The vulnerability has existed since the driver was initially added (commit 88523a61558a from 2011), affects a hardware storage driver that handles sensitive I/O operations, and the memory corruption potential makes this a security issue worthy of a CVE assignment.
deb016c16690 gfs2: No more self recovery
- [sasha] YES
  This commit should be assigned a CVE because it fixes critical security vulnerabilities:
  1. **NULL Pointer Dereference**: The commit message explicitly states "is a NULL pointer dereference since then" when describing how `gfs2_recover_func()` dereferences `sdp->sd_jdesc->jd_inode`. This is a security vulnerability that can cause system crashes or potentially be exploited for denial of service.
  2. **Use-After-Free**: The commit message mentions this was "a use-after-free before commit 04133b607a78", indicating this code path had multiple security issues over time.
  3. **Impact on System Availability**: The vulnerability occurs in the filesystem withdrawal/recovery path, which is a critical component. A NULL pointer dereference here could crash the kernel, affecting system availability.
  4. **Clear Security Fix**: The code changes remove the problematic self-recovery logic entirely, eliminating the code path that leads to the NULL pointer dereference. The removed code includes:
     - The attempt to recover the journal via `gfs2_recover_journal(sdp->sd_jdesc, 1)`
     - The subsequent operations that would have dereferenced potentially NULL pointers
  The commit directly addresses memory safety issues (NULL pointer dereference and previously use-after-free) in kernel filesystem code, which are classic CVE-worthy vulnerabilities that can impact system stability and availability.
746d0ac5a07d nvmet: pci-epf: Do not complete commands twice if nvmet_req_init() fails
- [sasha] YES
  This commit should be assigned a CVE based on the following security-relevant aspects:
  1. **Double-free/Use-after-free vulnerability**: The code fixes a double completion issue where `nvmet_pci_epf_complete_iod()` is called twice for the same I/O descriptor (iod). This can lead to memory corruption as the iod is freed in the first completion and then accessed/freed again in the second completion.
  2. **Kernel crash/DoS potential**: The commit message explicitly states this "not only sends two completions to the host but also corrupts the state of the PCI NVMe target leading to kernel oops." A kernel oops indicates a serious kernel crash that can be triggered by unprivileged operations.
  3. **Easy to trigger**: The vulnerability can be triggered by sending a simple unsupported command from userspace using standard tools like nvme-cli (e.g., `nvme security-recv` command), making it easily exploitable.
  4. **State corruption**: The bug corrupts the internal state of the PCI NVMe target driver, which could potentially lead to further security issues beyond just a crash.
  The fix ensures that failed commands are only completed once by:
  - Returning early from `nvmet_pci_epf_exec_iod_work()` when `nvmet_req_init()` fails (line change where `goto complete` is replaced with `return`)
  - Adding a check for `iod->status` in `nvmet_pci_epf_queue_response()` to complete failed commands immediately
  This is a clear security vulnerability that allows local denial of service through kernel crash and potential memory corruption.
f2e467a48287 eventpoll: Fix semi-unbounded recursion
- [sasha] **YES**
  This commit fixes a significant security vulnerability related to stack exhaustion through deep recursion in the epoll subsystem. The key security issues:
  1. **Stack Exhaustion Attack**: The commit message explicitly states that recursion to "a depth of at least roughly 500" is possible on v6.15, which can cause stack overflow and system crashes.
  2. **Incomplete Depth Checking**: The original implementation from commit 22bacca48a17 (which was assigned CVE-2011-1082) had flaws:
     - Only checked downward paths, not upward traversal
     - Multiple paths of different lengths weren't properly considered due to commit 28d82dc1c4ed
  3. **Critical Code Changes**: The fix adds:
     - `loop_check_depth` field to track subtree depths
     - `ep_get_upwards_depth_proc()` to check upward traversal depth  
     - Modified `ep_loop_check_proc()` to properly calculate total depth even for already-visited nodes
     - Changed `ep_loop_check()` to enforce `EP_MAX_NESTS` limit on total path length
  4. **Attack Vector**: A local unprivileged user could create deeply nested epoll structures to trigger kernel stack exhaustion, leading to denial of service.
  The security impact is similar to the original CVE-2011-1082, but this is a distinct vulnerability arising from incomplete fixes in the original patch. The ability to cause stack exhaustion through unbounded recursion is a clear security issue warranting CVE assignment.
a739d3b13bff staging: gpib: fix unset padding field copy back to userspace
- [sasha] YES
  This commit should be assigned a CVE because it fixes an information disclosure vulnerability where uninitialized stack memory is copied to userspace.
  The security issue is clearly visible in the code change:
  1. **Before the fix**: `struct gpib_board_info_ioctl info;` - This declares the structure on the stack without initialization, leaving any padding bytes containing random stack data.
  2. **After the fix**: `struct gpib_board_info_ioctl info = { };` - This zero-initializes the entire structure, ensuring padding bytes are cleared.
  3. **The vulnerability**: The function copies the entire structure to userspace with `copy_to_user((void __user *)arg, &info, sizeof(info))`, which includes any padding bytes between struct members.
  This is a classic information leak vulnerability where kernel stack memory containing potentially sensitive information (addresses, data from previous function calls, etc.) could be exposed to unprivileged userspace processes. The commit message explicitly states "initialized data on the stack frame being copied back to userspace" and mentions "padding field" issues, confirming this is fixing a security-relevant information disclosure bug.
  Such kernel information leaks are routinely assigned CVEs as they can potentially be used to defeat kernel ASLR or leak other sensitive kernel data.
eb2cb7dab60f staging: fbtft: fix potential memory leak in fbtft_framebuffer_alloc()
- [sasha] YES
  This commit should be assigned a CVE because it fixes a memory leak vulnerability with potential security implications:
  1. **Memory Leak Fix**: The commit explicitly fixes a memory leak where `info->pagerefs` allocated in `fb_deferred_io_init()` was not being freed in error paths after successful fb_info allocation.
  2. **Security Impact**: Memory leaks in kernel drivers can lead to:
     - Resource exhaustion attacks where an attacker could trigger the error path repeatedly to consume kernel memory
     - Potential denial of service if memory exhaustion becomes severe
     - System instability over time
  3. **Error Path Vulnerability**: The code change shows adding `fb_deferred_io_cleanup(info)` to the error path at the `release_framebuf:` label, which was missing before. This is a classic error handling bug that could be exploited.
  4. **Kernel Space Context**: This is a kernel driver (staging/fbtft), where memory leaks are more serious than userspace leaks since kernel memory is a limited, shared resource.
  5. **Fixes Tag Present**: The commit includes `Fixes: c296d5f9957c ("staging: fbtft: core support")` indicating this has been a long-standing issue since the initial implementation, affecting multiple kernel versions.
  The vulnerability allows local attackers with ability to trigger framebuffer allocation failures to potentially cause memory exhaustion, making it a security-relevant fix worthy of CVE assignment.
bfb4cf9fb97e vmci: Prevent the dispatching of uninitialized payloads
- [sasha] **YES**
  This commit should be assigned a CVE because it fixes a **kernel information disclosure vulnerability** (data leak from kernel to userspace). The key security issues are:
  1. **Information Disclosure**: The commit explicitly states that "kernel data leaks to the user space" when uninitialized payload data is dispatched.
  2. **Race Condition**: The vulnerability occurs due to a race condition between two tasks executing `unlocked_ioctl` concurrently, where one task can dispatch datagrams with uninitialized payloads while another task is setting up the context.
  3. **Code Fix**: The patch adds `memset()` to zero out the payload memory before setting specific fields:
     ```c
     memset((char*)&ev.msg.hdr + sizeof(ev.msg.hdr), 0, ev.msg.hdr.payload_size);
     ```
     This ensures that any uninitialized portions of the payload are zeroed, preventing kernel memory contents from being exposed.
  4. **Attack Vector**: The vulnerability can be triggered through the host's ioctl interface, making it accessible to local attackers who can execute code to trigger the race condition.
  5. **Impact**: Information disclosure vulnerabilities that leak kernel memory are considered security issues as they can potentially expose sensitive data like kernel addresses (useful for KASLR bypass), credentials, or other privileged information.
  The commit message explicitly mentions this is fixing a data leakage issue where kernel data leaks to userspace through uninitialized payload content, which is a clear security vulnerability warranting CVE assignment.
12c409aa1ec2 pps: fix poll support
- [sasha] YES
  This commit should be assigned a CVE because it fixes a security-relevant denial of service vulnerability.
  The vulnerability allows any user with access to `/dev/pps0` to cause excessive CPU consumption through a busy-wait condition. The bug is in the `pps_cdev_poll()` function which unconditionally returns `EPOLLIN | EPOLLRDNORM`, causing poll/select to return immediately even when no new data is available.
  Key security implications from the code changes:
  1. **Resource exhaustion**: The old code in `drivers/pps/pps.c` always returned `EPOLLIN | EPOLLRDNORM` from `pps_cdev_poll()`, causing userspace programs to spin in a tight loop fetching data "at max speed" as noted in the commit message.
  2. **Fix validates event tracking**: The fix adds `last_fetched_ev` to track the last fetched event and compares it with `last_ev` to only return POLLIN when new data is actually available:
  ```c
  +	if (pps->last_fetched_ev == pps->last_ev)
  +		return 0;
  ```
  3. **System-wide impact**: This affects a kernel driver (`/dev/pps0`) that could be accessible to unprivileged users depending on system configuration, allowing them to cause high CPU usage that affects overall system performance.
  4. **Long-standing bug**: The Fixes tag references commit eae9d2ba0cfc from the initial PPS implementation, indicating this vulnerability has existed since the feature was introduced.
  The vulnerability enables a local denial of service attack through resource exhaustion, which warrants CVE assignment.
46dc57406887 powercap: dtpm_cpu: Fix NULL pointer dereference in get_pd_power_uw()
- [sasha] **YES**
  This commit should be assigned a CVE because it fixes a NULL pointer dereference vulnerability that can cause a kernel crash. The security implications are:
  1. **Crash/DoS vulnerability**: The commit explicitly states it "can crash with a NULL pointer dereference" in `get_pd_power_uw()` when a CPU becomes unavailable during runtime.
  2. **Missing input validation**: The original code at line 98 called `em_cpu_get(dtpm_cpu->cpu)` but failed to check if it returned NULL before dereferencing it on line 102 with `em_span_cpus(pd)`.
  3. **Runtime triggerable**: The vulnerability can be triggered during normal system operation when "a CPU becomes impossible during runtime" (likely meant "unavailable" or "offline"), making it exploitable.
  4. **Clear security fix pattern**: The fix adds a NULL check (lines 99-100):
  ```c
  +	if (!pd)
  +		return 0;
  ```
  This is a classic NULL pointer dereference fix that prevents a kernel crash, which qualifies as a denial-of-service vulnerability requiring CVE assignment.
bab7834c0382 PM / devfreq: Check governor before using governor->name
- [sasha] Now I understand the context. Let me analyze the security implications:
  **CVE Analysis:**
  **Answer: YES**
  This commit fixes a **null pointer dereference vulnerability** that could lead to a kernel crash. Here's the detailed analysis:
  1. **The Vulnerability**: 
     - The original code (after commit 96ffcdf239de) replaced `devfreq->governor_name` with direct access to `devfreq->governor->name`
     - In `devfreq_remove_governor()`, the code accessed `devfreq->governor->name` WITHOUT first checking if `devfreq->governor` was NULL
     - This creates a null pointer dereference when `devfreq->governor` is NULL
  2. **Security Impact**:
     - **Denial of Service (DoS)**: A null pointer dereference in kernel space causes a kernel panic/crash, resulting in system unavailability
     - The vulnerability can be triggered when removing a devfreq governor from the system
     - This could potentially be exploited by:
       - Unprivileged users if they have access to devfreq sysfs interfaces
       - Malicious kernel modules
       - Race conditions during governor removal/switching
  3. **Code Analysis**:
     The fix moves the NULL check BEFORE accessing `devfreq->governor->name`:
     ```c
     // BEFORE (vulnerable):
     if (!strncmp(devfreq->governor->name, governor->name, ...)) {
         if (!devfreq->governor) { // Check comes AFTER dereference!
     
     // AFTER (fixed):
     if (!devfreq->governor)
         continue;  // Check comes BEFORE dereference
     if (!strncmp(devfreq->governor->name, governor->name, ...)) {
     ```
  4. **Attack Vector**:
     - The vulnerability could be triggered through the devfreq subsystem's sysfs interface
     - Any operation that leads to `devfreq_remove_governor()` being called when a device has a NULL governor pointer would trigger the crash
  This is a classic kernel null pointer dereference vulnerability that results in system crash/DoS, which warrants CVE assignment as it affects system availability and stability.
53cf488927a0 wifi: rtw89: mcc: prevent shift wrapping in rtw89_core_mlsr_switch()
- [sasha] Let me analyze the commit based on the provided information:
  **CVE Status: YES**
  **Explanation:**
  This commit fixes a security vulnerability with the following characteristics:
  1. **Input validation vulnerability**: The code accepts a `link_id` value from userspace via debugfs without proper bounds checking. The fix adds validation: `link_id >= IEEE80211_MLD_MAX_NUM_LINKS` to prevent values >= 15.
  2. **Potential memory safety issue**: The commit message explicitly states this could cause "shift wrapping and potentially an out of bounds access later". When `link_id` is used in `BIT(link_id)`, values >= BITS_PER_LONG (typically 32 or 64) would cause undefined behavior in the shift operation.
  3. **Attack vector exists**: While the commit notes "only root can write to debugfs files", this is still an exploitable path from userspace to kernel that could lead to memory corruption.
  4. **Clear security fix pattern**: The added bounds check `link_id >= IEEE80211_MLD_MAX_NUM_LINKS` directly prevents the shift wrapping vulnerability, which is a classic security hardening pattern.
  5. **Similar to other CVE-worthy fixes**: This follows patterns seen in other kernel CVEs - insufficient input validation leading to potential out-of-bounds access or undefined behavior.
  The fix prevents a shift operation with an overly large value that could wrap around and potentially cause memory corruption or out-of-bounds access in subsequent operations. Even though root access is required, this still represents a legitimate security boundary that should be enforced.
76be5fae32fe bpf, sockmap: Fix psock incorrectly pointing to sk
- [sasha] YES
  This commit should be assigned a CVE based on the following security-relevant factors:
  1. **Use-After-Free/Incorrect Memory Access Pattern**: The commit fixes a race condition where an old psock can incorrectly access a socket that no longer belongs to it. As stated in the commit message: "When the pending workqueue is later triggered, it uses the old psock to access sk for I/O operations, which is incorrect."
  2. **Exploitable Race Condition**: The timing diagram shows a clear race condition between map operations and workqueue processing that could lead to one psock performing I/O operations on behalf of another psock's socket. This is a security boundary violation.
  3. **Memory Safety Issue**: The code change adds a critical check:
  ```c
  +	/* If sk is quickly removed from the map and then added back, the old
  +	 * psock should not be scheduled, because there are now two psocks
  +	 * pointing to the same sk.
  +	 */
  +	if (!sk_psock_test_state(psock, SK_PSOCK_TX_ENABLED))
  +		return;
  ```
  This prevents the old psock from continuing to operate on a socket it no longer owns, which could lead to data corruption or information disclosure.
  4. **Impact on BPF Socket Maps**: This affects the BPF sockmap subsystem which is used for redirecting socket data, a security-sensitive operation where incorrect psock-to-socket associations could lead to data being sent to/from wrong sockets.
  5. **Long-standing Issue**: The bug has existed since commit 604326b41a6f ("bpf, sockmap: convert to generic sk_msg interface"), indicating this vulnerability has been present in the kernel for an extended period.
  The vulnerability allows for potential information disclosure or data corruption through incorrect socket associations in the BPF sockmap subsystem.
178f6a5c8cb3 bpf, ktls: Fix data corruption when using bpf_msg_pop_data() in ktls
- [sasha] **YES**
  This commit should be assigned a CVE based on the following analysis:
  **Security Impact:**
  The commit fixes a **data corruption vulnerability** that leads to **information disclosure** through transmission of uninitialized memory:
  1. **Uninitialized Data Exposure**: The bug causes "uninitialized bytes to be appended after a complete 'Application Data' packet" during TLS transmission. This means sensitive data from uninitialized memory could be transmitted over the network.
  2. **Mechanism of the Bug**: 
     - When `bpf_msg_pop_data()` reduces the plaintext data size, the corresponding ciphertext buffer size was not being adjusted
     - This mismatch causes the TLS layer to transmit more data than intended, including uninitialized memory contents
     - The fix adds code to recalculate the ciphertext length: `sk_msg_trim(sk, enc, enc->sg.size - delta)`
  3. **Attack Surface**: This affects kTLS (kernel TLS) when used with BPF socket policies, which is a production feature used for TLS offloading and performance optimization.
  4. **Exploitability**: While not directly exploitable for code execution, information disclosure vulnerabilities in TLS implementations are serious security issues as they can leak sensitive data like cryptographic material, passwords, or other confidential information residing in memory.
  **Comparison to Similar Commits:**
  This aligns with patterns in commits that received CVEs - it fixes a concrete security vulnerability (information disclosure) in a network-facing component (TLS), with clear potential for data leakage to remote parties.
  The commit message explicitly describes this as "data corruption" leading to "uninitialized data" transmission, which is a classic information disclosure vulnerability pattern.
3157f7e29996 bpf: handle jset (if a & b ...) as a jump in CFG computation
- [sasha] **YES**
  This commit should be assigned a CVE. The bug causes the BPF verifier to incorrectly analyze control flow for programs using `BPF_JSET` instructions, leading to incorrect live register tracking and potentially allowing unsafe BPF programs to pass verification. This is a security vulnerability because:
  1. It affects the BPF verifier's correctness, which is a critical security component that prevents malicious or buggy BPF programs from compromising the kernel
  2. The incorrect liveness analysis could allow BPF programs to bypass safety checks
  3. It's reported by syzbot, indicating it was found through fuzzing security-critical kernel code
  4. The "Fixes:" tag points to a recent commit that introduced the vulnerability
  5. Missing jump edges in CFG computation can lead to incomplete security analysis of BPF programs
36670b67de18 wifi: ath12k: Avoid accessing uninitialized arvif->ar during beacon miss
- [sasha] Let me analyze the commit based on the provided information:
  **YES**
  This commit should be assigned a CVE because it fixes a **null pointer dereference vulnerability** that can cause a kernel crash. Here's the security analysis:
  ## Security Impact:
  1. **Null Pointer Dereference**: The commit explicitly fixes a null pointer dereference bug (`KASAN: null-ptr-deref in range [0x0000000000000010-0x0000000000000017]`) that occurs when accessing `arvif->deflink->ar` when it's uninitialized.
  2. **Kernel Crash/DoS**: The stack trace shows this causes a kernel panic, which represents a **Denial of Service (DoS)** vulnerability. The crash occurs in interrupt context (`swapper/5`) during beacon miss handling.
  3. **Attack Vector**: The vulnerability can be triggered through normal WiFi operations when:
     - P2P interfaces are created alongside station interfaces
     - Beacon miss events occur (which can happen naturally or be induced)
     - The driver attempts to handle beacon misses for P2P interfaces that have uninitialized `ar` pointers
  ## Code Analysis:
  The fix adds safety checks (`!arvif->is_created`) in multiple critical functions:
  - `ath12k_get_arvif_iter()` 
  - `ath12k_mac_handle_beacon_iter()`
  - `ath12k_mac_handle_beacon_miss_iter()`
  - `ath12k_mac_change_chanctx_cnt_iter()`
  - `ath12k_mac_change_chanctx_fill_iter()`
  - `ath12k_p2p_noa_update_vdev_iter()`
  These checks prevent dereferencing uninitialized `arvif->ar` pointers that result from the deferred vdev creation introduced in commit aa80f12f3bed.
  ## CVE Justification:
  This vulnerability meets CVE criteria because:
  - It's a **memory safety issue** (null pointer dereference)
  - It causes **system instability** (kernel crash/DoS)
  - It affects a **widely-used kernel subsystem** (WiFi/ath12k driver)
  - The issue is **exploitable** through normal WiFi operations
  - It's a **regression** introduced by a previous commit (aa80f12f3bed)
  The vulnerability allows local or remote attackers (through WiFi interactions) to crash the kernel, making this a legitimate security issue warranting CVE assignment.
05062834350f wifi: ath12k: Pass ab pointer directly to ath12k_dp_tx_get_encap_type()
- [sasha] Looking at this commit, I need to analyze both the message and code changes for security implications.
  **Commit Analysis:**
  1. **Security vulnerability being fixed?** YES - The commit explicitly mentions fixing a kernel panic condition that occurs when `arvif->ar` becomes NULL during vdev delete sequence.
  2. **Impact assessment:** 
     - The commit mentions "kernel panic" which is a denial of service condition
     - The backtrace shows this occurs in the TX (transmit) path during normal packet processing
     - A NULL pointer dereference leading to kernel panic is a security issue
  3. **Code changes analysis:**
     - The function signature changes from `ath12k_dp_tx_get_encap_type(struct ath12k_link_vif *arvif, ...)` to `ath12k_dp_tx_get_encap_type(struct ath12k_base *ab, ...)`
     - The problematic line was: `struct ath12k_base *ab = arvif->ar->ab;` where `arvif->ar` could be NULL
     - This is a classic NULL pointer dereference vulnerability that can crash the kernel
  4. **Race condition/timing issue:** The fact that this happens during "vdev delete sequence" suggests a race condition where the structure is being freed/nullified while still being accessed by the TX path.
  5. **Exploitability:** While this appears to be a reliability issue, an attacker who can trigger vdev deletion while packets are being transmitted could potentially cause a denial of service.
  **Answer:** YES
  This commit should be assigned a CVE. It fixes a NULL pointer dereference vulnerability that leads to kernel panic in the WiFi driver's TX path. The vulnerability occurs due to a race condition during vdev deletion where `arvif->ar` can become NULL while still being accessed. This is a denial of service vulnerability that could potentially be triggered by an attacker with the ability to influence WiFi operations, making it a security issue worthy of CVE assignment.
16d8fd74dbfc wifi: rtl818x: Kill URBs before clearing tx status queue
- [sasha] **Answer: YES**
  This commit should be assigned a CVE because:
  1. **It fixes a security vulnerability**: A use-after-free bug leading to kernel NULL pointer dereference
  2. **Exploitable impact**: Can cause kernel crash/DoS - the stack trace shows it triggers in interrupt context causing system instability
  3. **Clear vulnerability pattern**: The race condition between freeing skbs and killing URBs allows callbacks to access freed memory
  4. **Remote triggerable**: As a WiFi driver issue, this could potentially be triggered remotely through malformed wireless traffic
  5. **The fix is a security boundary correction**: Properly ordering the cleanup sequence (killing URBs before freeing associated data structures) to prevent use-after-free
  The commit explicitly shows a kernel oops with NULL pointer dereference in `ieee80211_tx_status_irqsafe`, which is called from `rtl8187_tx_cb` after the skb was already freed. This is a classic use-after-free vulnerability in kernel space.
5fb90421fa0f drm/amdgpu: fix slab-use-after-free in amdgpu_userq_mgr_fini+0x70c
- [sasha] Looking at this commit, I need to analyze both the security implications and the nature of the bug being fixed.
  **Security Analysis:**
  YES
  This commit fixes a **use-after-free vulnerability** that can be triggered through normal device operations (PCI unplug test). Here's why this warrants a CVE:
  1. **Memory Safety Violation**: The KASAN report shows a clear use-after-free condition where `amdgpu_fpriv` is freed in `amdgpu_driver_postclose_kms()` but then accessed in `amdgpu_drm_release()` via `amdgpu_userq_mgr_fini()`.
  2. **Exploitable Condition**: The bug can be triggered through the PCI unplug operation (`remove_store` in sysfs), which is accessible to users with appropriate permissions. The stack trace shows:
     ```
     remove_store+0xd7/0xf0
     dev_attr_store+0x3f/0x80
     sysfs_kf_write+0x125/0x1d0
     ```
  3. **Code Changes Show Clear Fix**: The patch moves the cleanup operations from `amdgpu_drm_release()` to `amdgpu_driver_postclose_kms()`:
     - Removes the custom `amdgpu_drm_release()` function entirely
     - Moves `amdgpu_eviction_fence_destroy()` and `amdgpu_userq_mgr_fini()` to execute BEFORE `kfree(fpriv)`
     - This ensures the freed memory is never accessed
  4. **Impact**: Use-after-free vulnerabilities can potentially lead to:
     - System crashes/DoS
     - Information disclosure (reading freed memory)
     - Potential privilege escalation (if the freed memory can be reallocated with controlled data)
  5. **Similar to Referenced Commit**: The referenced "Fixes" commit (adba0929736a) introduced this vulnerability by adding the `amdgpu_drm_release()` function that incorrectly accessed `fpriv` after it was freed.
  The vulnerability is a classic temporal memory safety issue in kernel driver code that could be exploited by local users with device access permissions, making it a legitimate security vulnerability requiring CVE assignment.
90a0d9f33996 iwlwifi: Add missing check for alloc_ordered_workqueue
- [sasha] 
bfb4fb77f9a8 team: replace team lock with rtnl lock
- [sasha] Let me analyze the commit based on the provided information:
  ## Analysis
  **CVE Status: YES**
  This commit should be assigned a CVE based on the following security-relevant factors:
  ### 1. **Fixes a Locking/Synchronization Issue**
  The commit replaces a custom team lock with RTNL lock to fix "various ordering issues for lower instance locks and team lock" as mentioned in the commit message. The referenced syzkaller reports indicate race conditions and locking order violations.
  ### 2. **Previous Related Fix Had Security Implications**
  The commit fixes "6b1d3c5f675c" which dealt with a critical locking issue where `team_change_rx_flags` was running under RCU lock instead of proper mutex protection. The original issue showed:
  - "BUG: sleeping function called from invalid context"
  - Incorrect locking leading to potential race conditions
  ### 3. **Code Changes Show Security-Critical Patterns**
  The diff shows systematic replacement of `mutex_lock(&team->lock)` with `ASSERT_RTNL()` throughout critical network device operations including:
  - Port addition/removal (`team_port_add`, `team_port_del`)
  - Network flag changes (`team_change_rx_flags`)
  - MAC address changes (`team_set_mac_address`)
  - VLAN operations (`team_vlan_rx_add_vid`, `team_vlan_rx_kill_vid`)
  ### 4. **Race Condition Potential**
  The incorrect locking could lead to:
  - **Data races** when modifying team port lists
  - **Use-after-free** if ports are removed while being accessed
  - **Inconsistent device state** during concurrent operations
  - **Kernel crashes** as indicated by the syzkaller reports
  ### 5. **Network Stack Impact**
  This affects the team network driver which is used in production environments for link aggregation and redundancy. Improper locking in network drivers can lead to:
  - Denial of service through kernel panics
  - Information leaks through race conditions
  - Potential privilege escalation if memory corruption occurs
  The systematic nature of the locking change (removing custom lock entirely and switching to RTNL) indicates this was a fundamental synchronization flaw that could be exploited to cause kernel instability or crashes, warranting CVE assignment.
a5b46aa7cf5f wifi: ath11k: clear initialized flag for deinit-ed srng lists
- [sasha] Let me analyze the commit based on the provided information.
  ## Analysis
  **CVE Status: YES**
  This commit fixes a kernel page fault vulnerability that can lead to a system crash. Here's why this warrants a CVE:
  ### Security Impact:
  1. **Kernel Page Fault/Crash**: The commit explicitly shows a kernel panic with page fault:
     ```
     BUG: unable to handle page fault for address: ffffa007404eb010
     #PF: supervisor read access in kernel mode
     ```
  2. **Use-After-Free Pattern**: The bug follows a classic use-after-free vulnerability pattern:
     - `ath11k_hal_srng_deinit()` destroys/deallocates srng lists
     - The `initialized` flag remains set (stale state)
     - Subsequent access via `ath11k_hal_dump_srng_stats()` dereferences freed memory
  3. **Triggerable Condition**: The vulnerability can be triggered through:
     - System suspend/resume cycles
     - Firmware crashes and recovery attempts
     - Driver reconfiguration failures
  ### Code Analysis:
  The fix adds:
  ```c
  for (i = 0; i < HAL_SRNG_RING_ID_MAX; i++)
      ab->hal.srng_list[i].initialized = 0;
  ```
  This properly clears the `initialized` flags when deinitializing srng lists, preventing the use-after-free condition.
  ### Security Severity:
  - **Local DoS**: Can cause kernel panic and system crash
  - **Potential for exploitation**: While shown as a crash, use-after-free vulnerabilities can sometimes be exploited for privilege escalation
  - **Affects production systems**: Occurs during normal operations (suspend/resume)
  The commit fixes a clear security vulnerability that results in kernel memory corruption and system instability, meeting the criteria for CVE assignment.
c27bb624b3d7 wifi: ath12k: Clear auth flag only for actual association in security mode
- [sasha] 
cf80c02a9fdb wifi: iwlwifi: Fix error code in iwl_op_mode_dvm_start()
- [sasha] **YES**
  This commit should be assigned a CVE. The commit explicitly mentions it fixes a potential use-after-free vulnerability. The error handling bug causes the function to return NULL (ERR_PTR(0)) instead of a proper error pointer when workqueue allocation fails, which the commit author states "potentially leads to a use after free involving debugfs." Use-after-free vulnerabilities are serious security issues that can lead to memory corruption, crashes, or potentially arbitrary code execution.
b3a431fe2e39 wifi: mt76: mt7925: fix off by one in mt7925_mcu_hw_scan()
- [sasha] YES
  This commit fixes an out-of-bounds array access vulnerability. The code changes show:
  1. **Array bounds checking error**: Changed `if (i > MT7925_RNR_SCAN_MAX_BSSIDS)` to `if (i >= MT7925_RNR_SCAN_MAX_BSSIDS)` in two locations
  2. **Arrays involved**: Both `ssid->ssids[]` and `sreq->ssids[]` arrays have `MT7925_RNR_SCAN_MAX_BSSIDS` elements (defined as 10)
  3. **Security impact**: The off-by-one error allowed access to index 10 when valid indices are 0-9, causing:
     - Potential memory corruption when writing to `ssid->ssids[10]`
     - Information disclosure by reading beyond array bounds
     - Possible system instability or crashes
  This is a classic buffer overflow vulnerability in kernel WiFi driver code that could be exploited for privilege escalation or denial of service, warranting CVE assignment.
64cbf0d7ce9a wifi: mt76: mt7996: Fix possible OOB access in mt7996_tx()
- [sasha] Looking at this commit, I need to analyze the security implications of the fix.
  **Analysis:**
  1. **Security Vulnerability Fixed:** YES - This fixes an Out-Of-Bounds (OOB) array access vulnerability.
  2. **Specific Security Issue:**
     - The commit message explicitly states "Fix possible OOB access in mt7996_tx()"
     - The vulnerable code path: When `link_id` is set to `IEEE80211_LINK_UNSPECIFIED`, the original code would attempt to access `mvif->mt76.link[link_id]` and `msta->link[link_id]` arrays
     - `IEEE80211_LINK_UNSPECIFIED` is typically a special value (often 15 or similar) that exceeds valid array bounds
  3. **Code Changes Showing the Fix:**
     - **Added bounds check:** `if (link_id < IEEE80211_LINK_UNSPECIFIED)` before accessing the arrays
     - **Fallback mechanism:** Uses `&mvif->deflink.mt76` as default when link_id is invalid
     - **Additional validation:** Added check for `link_id < IEEE80211_LINK_UNSPECIFIED` before accessing `msta->link[link_id]`
  4. **Potential Impact:**
     - **Memory corruption:** OOB array access could lead to reading/writing arbitrary memory
     - **System crash:** Could cause kernel panic or system instability
     - **Potential exploitation:** Depending on memory layout, could potentially be exploited for privilege escalation or code execution
  5. **Attack Vector:**
     - This occurs in the WiFi transmission path (`mt7996_tx`)
     - Could potentially be triggered by malformed WiFi packets or frames with invalid link_id values
     - Remote exploitation possible if attacker can inject packets with specific link_id values
  **Answer: YES**
  This commit should be assigned a CVE. It fixes a clear Out-Of-Bounds array access vulnerability in the WiFi driver's transmission path that could lead to memory corruption, system crashes, or potentially worse security impacts. The fix adds proper bounds checking before array access when `link_id` could be `IEEE80211_LINK_UNSPECIFIED`, preventing the OOB access. This type of vulnerability in kernel network drivers is typically CVE-worthy due to the potential for remote exploitation and system-level impact.
a886d26f2c8f drm/amdgpu: fix use-after-free in amdgpu_userq_suspend+0x51a/0x5a0
- [sasha] Let me analyze the commit based on the provided information:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Clear Security Vulnerability**: The commit fixes a use-after-free vulnerability, which is a well-established security issue class. The KASAN report shows memory being accessed after it has been freed.
  2. **Exploitable Race Condition**: The bug involves a race condition between delayed work (`suspend_work`) and memory deallocation during device removal. The code change from `flush_work(&fpriv->evf_mgr.suspend_work.work)` to `flush_delayed_work(&fpriv->evf_mgr.suspend_work)` shows that delayed work items were not properly synchronized, allowing them to execute after memory was freed.
  3. **Kernel Memory Corruption**: The stack trace shows this occurs in kernel space (`amdgpu_userq_suspend`) and involves freed kernel memory being accessed, which could potentially lead to:
     - Kernel crashes/DoS
     - Information disclosure (reading freed memory)
     - Potential privilege escalation if an attacker can control the freed memory contents
  4. **Triggerable by Userspace**: The vulnerability can be triggered through userspace operations - the stack trace shows it occurs during PCI device removal initiated via sysfs (`remove_store`), which can be triggered by users with appropriate permissions.
  5. **Specific Impact Window**: The freed memory region (4096 bytes) and the specific offset (3160 bytes) where the invalid access occurs provides a clear attack surface that could potentially be exploited.
  The fix properly ensures that all delayed work is completed before freeing the associated memory, closing the race condition window that allowed the use-after-free to occur.
f9f68bf1d0ef drm/rockchip: vop2: fail cleanly if missing a primary plane for a video-port
- [sasha] YES
  This commit should be assigned a CVE because it fixes a null pointer dereference vulnerability that can cause a kernel crash. The code changes show:
  1. **Null Pointer Dereference Vulnerability**: The commit message explicitly states "ended in a null-pointer dereference further down" when no primary plane is found for a video port.
  2. **Security Impact**: The code adds a critical check at the end of the window iteration:
  ```c
  +		if (!vp->primary_plane)
  +			return dev_err_probe(drm->dev, -ENOENT,
  +					     "no primary plane for vp %d\n", i);
  ```
  3. **Missing Input Validation**: The original code failed to validate that a primary plane was actually found before using it with `drm_crtc_init_with_planes()`, which expects a valid primary plane pointer. Without this check, the driver would proceed with a NULL pointer and crash when dereferencing it.
  4. **Real-world Trigger**: The commit mentions this issue was triggered on actual hardware (rk3576 vp2), demonstrating it's not just theoretical but can occur in practice when "vp0 is also in use".
  5. **Kernel Crash Potential**: A null pointer dereference in kernel space typically leads to a kernel panic or system crash, which is a denial of service condition that warrants CVE assignment.
  The fix adds proper error handling to fail cleanly during probe rather than crashing later during operation, preventing the security vulnerability.
fe69a3918084 drm/panthor: Fix UAF in panthor_gem_create_with_handle() debugfs code
- [sasha] Looking at this commit, I need to analyze both the commit message and code changes for security implications.
  **Commit Message Analysis:**
  - The subject explicitly mentions "Fix UAF" (Use-After-Free) which is a serious memory safety vulnerability
  - The message describes that "The object is potentially already gone after the drm_gem_object_put()"
  - This is a classic UAF pattern where an object is accessed after being freed
  **Code Changes Analysis:**
  Let me examine the key changes in `panthor_gem_create_with_handle()`:
  ```c
  // BEFORE (vulnerable):
  ret = drm_gem_handle_create(file, &shmem->base, handle);
  if (!ret)
      *size = bo->base.base.size;
  /* drop reference from allocate - handle holds it now. */
  drm_gem_object_put(&shmem->base);
  // Then accessing bo after the put:
  panthor_gem_debugfs_set_usage_flags(bo, 0);
  // AFTER (fixed):
  panthor_gem_debugfs_set_usage_flags(bo, 0);
  ret = drm_gem_handle_create(file, &shmem->base, handle);
  if (!ret)
      *size = bo->base.base.size;
  /* drop reference from allocate - handle holds it now. */
  drm_gem_object_put(&shmem->base);
  ```
  The vulnerability is clear: `drm_gem_object_put()` decrements the reference count and can potentially free the object. After this call, `bo` (which points to memory within `shmem`) could be pointing to freed memory. The original code then calls `panthor_gem_debugfs_set_usage_flags(bo, 0)` on this potentially freed pointer, causing a use-after-free.
  **Security Impact:**
  - UAF vulnerabilities can lead to arbitrary code execution
  - This occurs in kernel space (DRM driver)
  - Could potentially be triggered from userspace through DRM ioctls
  - Affects memory safety in a privileged context
  **Answer: YES**
  This commit fixes a use-after-free vulnerability in the panthor DRM driver where the code was accessing a GEM object (`bo`) after calling `drm_gem_object_put()` which could free it. The fix reorders the operations to ensure `panthor_gem_debugfs_set_usage_flags()` is called before the object reference is dropped. UAF vulnerabilities in kernel drivers are serious security issues that can potentially lead to privilege escalation or code execution, warranting CVE assignment.
2109e98503bc wifi: ath12k: update unsupported bandwidth flags in reg rules
- [sasha] 
ec8e0e3d7ade net/sched: Restrict conditions for adding duplicating netems to qdisc tree
- [sasha] **YES**
  This commit should be assigned a CVE based on the following security analysis:
  **1. Denial of Service (DoS) Vulnerability:**
  The commit explicitly fixes a **soft lockup and OOM (Out of Memory) loop** vulnerability, as stated in the commit message: "this can lead to a soft lockup and OOM loop in netem_dequeue". This is a clear denial of service condition that can crash or make a system unresponsive.
  **2. Attack Vector:**
  The vulnerability can be triggered when duplicating netems exist in the same qdisc tree, causing an infinite recursion/loop scenario during packet processing. The referenced bug report [1] confirms this was actively exploited.
  **3. Security Impact:**
  - **System availability impact**: Soft lockup leads to system freeze/unresponsiveness
  - **Resource exhaustion**: OOM condition can crash processes or the entire system
  - **Remote triggerable**: Network packet processing suggests this could potentially be triggered remotely
  **4. Code Analysis:**
  The fix adds `check_netem_in_tree()` function (lines 967-998) that prevents dangerous configurations by:
  - Checking if duplicating netems would coexist in the same tree
  - Returning -EINVAL to reject such configurations
  - Called before setting `q->duplicate` (line 1062-1066) to prevent the vulnerable state
  **5. Historical Context:**
  - The bug has existed since 2005 (commit 0afb51e72855)
  - Multiple reporters identified this as a security issue
  - The extensive discussion of failed mitigation attempts indicates the severity
  The combination of DoS impact, potential for remote exploitation, and the explicit nature of the security fix warrants CVE assignment.
532c8b51b3a8 xen: fix UAF in dmabuf_exp_from_pages()
- [sasha] YES
  This commit should be assigned a CVE as it fixes a critical use-after-free (UAF) vulnerability with clear security implications:
  1. **Memory Safety Vulnerability**: The commit explicitly fixes a UAF bug in `dmabuf_exp_from_pages()` where the code was accessing freed memory after `fd_install()`.
  2. **Race Condition Exploitation**: The vulnerability creates a race condition where one thread could close a file descriptor while another thread is still accessing the associated objects (like `gntdev_dmabuf`), leading to use-after-free.
  3. **Critical Code Changes**:
     - The fix reorders operations to reserve the file descriptor first using `CLASS(get_unused_fd, ret)` 
     - Moves `fd_install()` to the very end of the function after all setup is complete
     - Changes from `dma_buf_fd()` (which combines reservation and installation) to separate operations
     - The line `fd_install(take_fd(ret), no_free_ptr(gntdev_dmabuf)->dmabuf->file)` ensures atomic installation only after all initialization
  4. **Security Impact**: UAF vulnerabilities are typically exploitable for privilege escalation or code execution, especially in kernel/hypervisor contexts like Xen.
  5. **Affects Security Boundary**: This is in the Xen grant device driver's DMA buffer export functionality, which handles shared memory between VMs - a critical security boundary.
  The commit message explicitly states "we have a UAF" and describes the exact vulnerability mechanism, making this a clear security fix that warrants CVE assignment.
3141153816bf iommu/vt-d: Fix missing PASID in dev TLB flush with cache_tag_flush_all
- [sasha] Let me analyze the commit based on the provided information:
  ## Analysis of the Commit
  ### Security Implications:
  1. **Bug Description**: The commit fixes a missing PASID (Process Address Space ID) in device TLB flush operations. When `cache_tag_flush_all()` is called, it was incorrectly sending TLB invalidations without the PASID field.
  2. **Impact Assessment**:
     - **Stale TLB Entries**: When a PASID is attached (SVA/Shared Virtual Addressing scenarios), the device TLB invalidation without PASID means the device might not properly flush its cached translations for that specific process context.
     - **Potential Security Risk**: This could lead to stale TLB entries remaining in the device, potentially allowing:
       - A process to access memory it should no longer have access to after unmapping
       - Cross-process memory access if stale entries persist across context switches
       - Information leakage between different PASID contexts
  3. **Code Analysis**:
     - The fix replaces `cache_tag_flush_devtlb_all()` with `cache_tag_flush_devtlb_psi()` 
     - The removed function `cache_tag_flush_devtlb_all()` was using `qi_batch_add_dev_iotlb()` which doesn't handle PASID
     - The replacement `cache_tag_flush_devtlb_psi()` properly handles PASID with `qi_batch_add_pasid_dev_iotlb()` when `tag->pasid != IOMMU_NO_PASID`
  4. **Attack Scenarios**:
     - In SVA (Shared Virtual Addressing) configurations where processes share virtual addresses with devices
     - During transparent hugepage unmapping operations
     - When `iommu_flush_iotlb_all()` is called with PASID-tagged mappings
  5. **Affected Components**: 
     - IOMMU subsystem (critical security component)
     - Device TLB management (affects DMA isolation)
     - PASID handling (process isolation mechanism)
  ### Comparison with Referenced Commits:
  The referenced "Fixes" commits (4f609dbff51b and 4e589a53685c) introduced the problematic code by using cache helpers that didn't properly handle PASID in all scenarios.
  ## Conclusion
  **YES** - This commit should be assigned a CVE.
  **Explanation**: This fix addresses a security vulnerability where improper TLB invalidation with missing PASID could lead to stale device TLB entries. In SVA/PASID scenarios, this allows devices to potentially access memory through stale translations that should have been invalidated, breaking process isolation boundaries. The bug affects a critical security component (IOMMU) responsible for DMA protection and process isolation when devices share virtual address spaces with processes. The potential for unauthorized memory access or information leakage between different PASID contexts constitutes a security vulnerability warranting CVE assignment.
65c12b104cb9 wifi: ath11k: fix sleeping-in-atomic in ath11k_mac_op_set_bitrate_mask()
- [sasha] 
11e3e22fa533 wifi: mac80211: Do not schedule stopped TXQs
- [sasha] Looking at this commit, I need to analyze both the security implications and the nature of the fix.
  **Analysis:**
  The commit fixes a scheduling bug in the mac80211 TX queue implementation where:
  1. **The Bug**: After setting `IEEE80211_TXQ_STOP`, the driver would call `ieee80211_return_txq()`, which then calls `__ieee80211_schedule_txq()`. This would detect frames still in the queue and immediately restart the stopped TXQ, creating an infinite loop since the stopped queue cannot dequeue frames.
  2. **The Fix**: The code change adds a check for the `IEEE80211_TXQ_STOP` flag before considering a queue as having data:
  ```c
  has_queue = force ||
             (!test_bit(IEEE80211_TXQ_STOP, &txqi->flags) &&
              txq_has_queue(txq));
  ```
  3. **Security Impact Assessment**:
     - This creates a **denial of service condition** through CPU exhaustion
     - The infinite loop would consume CPU resources continuously
     - This could make the system unresponsive or degrade wireless performance significantly
     - The issue affects drivers using `ieee80211_txq_schedule_start()`
  4. **Attack Vector**: While this appears to be triggered by normal TX queue operations rather than requiring malicious input, the resulting infinite loop represents a denial of service vulnerability that could be triggered under certain traffic conditions.
  **Verdict: YES**
  This commit should be assigned a CVE because:
  1. It fixes a denial of service vulnerability (infinite loop causing CPU exhaustion)
  2. The bug could make wireless functionality unavailable or severely degraded
  3. The issue has been present since the introduction of the intermediate queue implementation (commit ba8c3d6f16a1 from 2015)
  4. It affects multiple drivers that use the `ieee80211_txq_schedule_start()` interface
  5. Similar scheduling/queueing bugs that cause denial of service conditions in the kernel are typically assigned CVEs
  The infinite loop represents a clear availability impact that warrants CVE assignment.
2ed9a9fc9976 wifi: nl80211: Set num_sub_specs before looping through sub_specs
- [sasha] Let me analyze the code changes directly from the diff provided:
  **Analysis:**
  Looking at the commit message and code changes:
  1. **The Issue Being Fixed**: The commit fixes an issue where `num_sub_specs` was not being set before the loop that processes the `sub_specs` flexible array. The referenced commit (aa4ec06c455d) added `__counted_by` annotations for bounds checking.
  2. **Security Implications**: 
     - The `__counted_by` attribute enables runtime bounds checking for flexible arrays
     - Without setting `num_sub_specs` before the loop, bounds checking would fail or be bypassed
     - This could potentially lead to out-of-bounds memory access when iterating through `sub_specs`
  3. **Code Analysis**:
     - The change adds `sar_spec->num_sub_specs = specs;` BEFORE the loop that processes sub_specs
     - Previously, `num_sub_specs` was only set AFTER the loop (line kept at the end)
     - The flexible array `sub_specs` is marked with `__counted_by(num_sub_specs)` according to the Fixes commit
  4. **Impact Assessment**:
     - This is a memory safety issue that could lead to out-of-bounds access
     - The vulnerability exists in the wireless subsystem's netlink interface (nl80211)
     - This is a kernel-level vulnerability in a network-facing component
     - Could potentially be exploited through crafted netlink messages
  **CVE Status: YES**
  This commit fixes a memory safety vulnerability where the bounds checking mechanism for a flexible array was ineffective due to incorrect initialization order. The issue could lead to out-of-bounds memory access in the kernel's wireless configuration interface, which handles untrusted input from userspace via netlink. This type of memory safety bug in kernel code that processes external input typically warrants a CVE assignment.
cbbcfb94c55c arm64/gcs: task_gcs_el0_enable() should use passed task
- [sasha] Let me analyze the commit based on the provided information:
  **Analysis of the commit:**
  1. **Nature of the bug being fixed:**
     - The function `task_gcs_el0_enabled()` was incorrectly using `current` instead of the passed `task` parameter
     - This is a logic error where the wrong task's GCS (Guarded Control Stack) state was being checked
  2. **Security implications:**
     - GCS is a security feature (shadow stack) designed to prevent ROP/JOP attacks
     - The bug could cause the function to check the wrong task's GCS state
     - This could lead to incorrect security decisions about whether GCS is enabled for a specific task
  3. **Impact assessment:**
     - The commit message notes "it hasn't yet been causing problems" because usually the correct task is passed
     - The fix also addresses a secondary issue with initialization order in `copy_thread_gcs()`
     - Could potentially lead to bypass of GCS protections or incorrect enforcement
  4. **Code changes analysis:**
     - Line change in `task_gcs_el0_enabled()`: `current->thread.gcs_el0_mode` → `task->thread.gcs_el0_mode`
     - Reordering in `copy_thread_gcs()` to initialize `gcs_el0_mode` before calling `gcs_alloc_thread_stack()`
  5. **Comparison with similar commits:**
     - The referenced commit (fc84bc5378a8) introduces the GCS context switching functionality
     - This is fixing a bug in that security feature implementation
  **CVE Decision: YES**
  **Reasoning:**
  This commit fixes a security-relevant bug in the GCS (Guarded Control Stack) implementation, which is a security hardening feature. The bug causes the wrong task's security state to be checked, potentially leading to:
  - Incorrect enforcement of shadow stack protections
  - Possible bypass of GCS security controls when checking if GCS is enabled for a task
  - Security state confusion between tasks
  While the commit message indicates it hasn't caused problems yet due to typical usage patterns, the potential exists for security bypass through task confusion. This type of logic error in security enforcement code typically warrants a CVE assignment, especially when it affects a security hardening feature like shadow stacks that protect against control-flow hijacking attacks.
f0b9d31c6edd iommu/vt-d: Fix UAF on sva unbind with pending IOPFs
- [sasha] Let me examine the patch content more carefully.
  ## Analysis
  **YES**, this commit should be assigned a CVE.
  ### Explanation:
  1. **Use-After-Free Vulnerability**: The commit explicitly fixes a use-after-free (UAF) vulnerability that can trigger kernel panics, as shown in the stack trace with "refcount_t: underflow; use-after-free."
  2. **Security Impact**: 
     - UAF vulnerabilities are serious security issues that can potentially lead to:
       - System crashes (demonstrated by the kernel panic trace)
       - Memory corruption
       - Potential privilege escalation or code execution in worst-case scenarios
  3. **Root Cause**: The vulnerability occurs because `iopf_for_domain_remove()` was called before `intel_pasid_tear_down_entry()`, meaning:
     - The device was removed from the IOPF queue while there were still pending IO Page Faults (IOPFs)
     - This creates a race condition where pending page faults can reference freed memory
  4. **The Fix**: The code change shows a critical reordering:
     ```diff
     - iopf_for_domain_remove(old, dev);
       intel_pasid_tear_down_entry(info->iommu, dev, pasid, false);
     + iopf_for_domain_remove(old, dev);
     ```
     This ensures that `intel_pasid_tear_down_entry()` blocks new page faults and flushes in-flight ones BEFORE removing the device from the IOPF queue.
  5. **Exploitability**: While this appears to be a race condition that may be difficult to reliably trigger, UAF vulnerabilities in kernel code are generally considered security-critical, especially in IOMMU/virtualization contexts where they could affect system isolation.
  The commit fixes a memory safety issue that can cause system instability and potentially be exploited, meeting the criteria for CVE assignment.
bc404dfddbf6 wifi: iwlwifi: mld: decode EOF bit for AMPDUs
- [sasha] 
2935e556850e Bluetooth: hci_sync: fix double free in 'hci_discovery_filter_clear()'
- [sasha] **YES**
  This commit fixes a double-free vulnerability that causes memory corruption in the kernel's Bluetooth subsystem. The code changes show:
  1. **Security vulnerability**: The race condition in `hci_discovery_filter_clear()` allows two threads to call `kfree(hdev->discovery.uuids)` on the same pointer, causing a double-free
  2. **Kernel impact**: The backtrace shows this causes a kernel BUG/crash (`kernel BUG at mm/slub.c:547!`)
  3. **Memory corruption**: Double-free vulnerabilities are serious memory safety issues that can lead to heap corruption and potential arbitrary code execution
  4. **Fix adds security control**: The patch adds a spinlock (`discovery.lock`) to protect the critical section where the free occurs
  The vulnerability can be triggered from userspace through bluetoothd, causing at minimum a denial of service (kernel crash) and potentially privilege escalation through heap corruption exploitation.
7af4d7b53502 Bluetooth: hci_devcd_dump: fix out-of-bounds via dev_coredumpv
- [sasha] Let me analyze the commit based on the provided information:
  **YES**
  This commit fixes a **use-after-free vulnerability** that leads to an out-of-bounds memory access. The security implications are:
  1. **Memory Safety Violation**: The bug causes a vmalloc-out-of-bounds read, as shown in the KASAN report. The code was accessing freed memory (`hdev->dump.head`) after `dev_coredumpv()` freed it.
  2. **Race Condition**: The vulnerability occurs when `dev_coredumpv()` discards and frees a buffer if a previous coredump hasn't been read yet, but then `skb_put_data()` tries to access that freed buffer.
  3. **Exploitable Pattern**: The fix shows reordering of operations - moving `skb_put_data()` before `dev_coredumpv()` to prevent use-after-free:
     ```c
     - /* Emit a devcoredump with the available data */
     - dev_coredumpv(&hdev->dev, hdev->dump.head, size, GFP_KERNEL);
     -
     /* Send a copy to monitor as a diagnostic packet */
     skb = bt_skb_alloc(size, GFP_ATOMIC);
     if (skb) {
         skb_put_data(skb, hdev->dump.head, size);
         hci_recv_diag(hdev, skb);
     }
     +
     + /* Emit a devcoredump with the available data */
     + dev_coredumpv(&hdev->dev, hdev->dump.head, size, GFP_KERNEL);
     ```
  4. **Kernel Context**: This occurs in kernel space (Bluetooth HCI driver), making it a privileged context vulnerability that could potentially be exploited for information disclosure or denial of service.
  The syzbot crash report confirms this is a real, reproducible security issue with memory corruption potential in the kernel's Bluetooth subsystem.
69b3d3acf3db Bluetooth: btintel_pcie: Make driver wait for alive interrupt
- [sasha] Looking at this commit, I need to analyze both the message and code changes to determine if this fixes a security vulnerability.
  **Commit Analysis:**
  The commit message states:
  - "The firmware raises an alive interrupt upon receiving the HCI_RESET or BTINTEL_HCI_OP_RESET"
  - "This change fixes the driver to properly wait for the alive interrupt to avoid driver sending commands to firmware before it is ready to process"
  - It's marked as a "Fixes:" commit
  **Code Changes:**
  1. **Added wait signals in interrupt handler** (lines 948-949, 955-956):
     - Added `signal_waitq = true;` to signal when firmware is ready after INTEL_HCI_RESET1
  2. **Extended alive interrupt wait** (lines 1993-1995):
     - Changed from only waiting on `HCI_OP_RESET` to also waiting on `BTINTEL_HCI_OP_RESET`
     - Both reset commands now set `data->gp0_received = false`
  3. **Added timeout handling** (lines 2030-2040):
     - Now waits for alive interrupt for both reset types
     - Implements proper timeout error handling with descriptive error message
  **Security Assessment:**
  This is a **race condition fix** where the driver could send commands to firmware before it was ready to process them. The potential security implications include:
  1. **Firmware state corruption** - Sending commands while firmware is not ready could potentially corrupt firmware state
  2. **Unpredictable behavior** - Commands sent before firmware readiness could lead to undefined behavior
  3. **Potential denial of service** - Could cause firmware to crash or become unresponsive
  The fix ensures proper synchronization between driver and firmware during reset operations, which is a security-relevant timing issue.
  **Answer: YES**
  This commit should be assigned a CVE. It fixes a race condition where the driver could send commands to firmware before it was ready after a reset operation. This timing vulnerability could lead to firmware state corruption, unpredictable behavior, or denial of service. The code changes show it adds proper synchronization by making the driver wait for the alive interrupt from both HCI_OP_RESET and BTINTEL_HCI_OP_RESET commands, preventing commands from being sent while the firmware is still initializing.
e09299225d5b bpf: Reject narrower access to pointer ctx fields
- [sasha] YES
  This commit should be assigned a CVE because:
  1. **It fixes a security vulnerability** - The commit explicitly states it fixes a kernel warning/crash that occurs during BPF program verification, which was triggered by a syzkaller fuzzer. The error "verifier bug: error during ctx access conversion(1)" indicates an internal verifier failure that could potentially be exploited.
  2. **The bug allows invalid memory access patterns** - The code changes show that narrow pointer access to context fields (like `sk`, `optval`, `data`, etc.) was incorrectly allowed. The fix changes these fields from using simple `offsetof()` to `bpf_ctx_range_ptr()` macro, which properly validates that pointer fields are only accessed with the correct size (64-bit).
  3. **Potential security impact** - The bug allowed BPF programs to perform narrower reads (e.g., reading 1 byte) from pointer fields that should only be accessed as full 64-bit pointers. This could lead to:
     - Information disclosure (reading partial pointer values)
     - Kernel crashes/DoS (as evidenced by the syzkaller crash)
     - Potential privilege escalation if the incorrectly accessed data could be leveraged
  4. **Multiple affected subsystems** - The changes span multiple BPF program types (socket, sockopt, sk_msg, sk_lookup), indicating a widespread issue in the BPF verifier's context access validation.
  5. **The Fixes tags reference security-relevant commits** - One of the fixed commits (0df1a55afa832) is explicitly about warning on internal verifier errors, which are often security-critical.
  The specific code pattern being fixed (changing from `offsetof(struct type, field)` to `bpf_ctx_range_ptr(struct type, field)`) ensures that pointer fields can only be accessed as complete 64-bit values, preventing the partial/narrow access that was causing the vulnerability.
6d19c44b5c6d net/mlx5e: Remove skb secpath if xfrm state is not found
- [sasha] **YES**
  This commit should be assigned a CVE based on the following security analysis:
  ## Security Vulnerability Fixed:
  1. **NULL Pointer Dereference causing Kernel Crash**: The commit fixes a critical kernel crash vulnerability where a NULL pointer dereference occurs in `__xfrm_policy_check()`. The crash trace shows:
     - Error accessing address `ffffffff000002c8` 
     - Occurs when trying to dereference `sp->xvec[sp->len - 1]` when `sp->len` is 0
  2. **Root Cause**: When hardware-decrypted IPsec packets have their xfrm state freed before lookup, the code previously:
     - Set up a secpath with `sp->len = 0` 
     - Did NOT remove the invalid secpath from the skb
     - Downstream XFRM policy checks attempted to access `xvec[sp->len - 1]` causing out-of-bounds access
  3. **Impact**: 
     - **Denial of Service**: Remote attackers could trigger kernel crashes by sending specially crafted IPsec packets
     - **Availability Impact**: System crash/reboot required
     - The crash occurs in interrupt context (shown in call trace), affecting network packet processing
  4. **Attack Vector**: 
     - Network-based attack via IPsec traffic
     - Exploitable when mlx5 hardware IPsec offload is enabled
     - Triggered when xfrm state is freed while packets are in-flight
  5. **Fix Applied**: The patch adds `secpath_reset(skb)` to properly clean up the invalid security path, preventing the NULL pointer dereference in downstream processing.
  This represents a remotely exploitable denial-of-service vulnerability in the kernel's IPsec processing path that can crash the entire system, warranting CVE assignment.
1bbb76a89948 neighbour: Fix null-ptr-deref in neigh_flush_dev().
- [sasha] Based on my analysis of the commit message and code changes, I'll provide my assessment:
  **YES**, this commit should be assigned a CVE.
  Here's my analysis:
  1. **Security Impact - Null Pointer Dereference**: The commit explicitly fixes a null pointer dereference vulnerability in `neigh_flush_dev()`. The crash dump shows:
     - "Oops: general protection fault"
     - "KASAN: null-ptr-deref in range [0x0000000000000d00-0x0000000000000d07]"
     - The crash occurs when accessing memory through a NULL device pointer
  2. **Root Cause**: The previous commit f7f52738637f introduced per-netdev neighbour lists but failed to handle the case where `neigh_table_clear()` calls `neigh_ifdown()` with a NULL device pointer. The code was trying to access `dev->neighbours[]` when `dev` was NULL.
  3. **Exploitability**: While the commit message notes this primarily occurs during IPv6 module initialization failure (which is rare), the vulnerability could potentially be triggered:
     - During module unload/reload scenarios
     - During specific network configuration changes
     - Could lead to denial of service through kernel panic
  4. **Code Changes Show Clear Security Fix**:
     ```c
     +	if (likely(dev)) {
     +		neigh_flush_dev(tbl, dev, skip_perm);
     +	} else {
     +		DEBUG_NET_WARN_ON_ONCE(skip_perm);
     +		neigh_flush_table(tbl);
     +	}
     ```
     The fix adds proper NULL device handling and creates a separate path (`neigh_flush_table()`) for when dev is NULL.
  5. **System Impact**: This is a kernel-level vulnerability that can crash the entire system, making it a significant security issue even if exploitation requires specific conditions.
  The combination of a clear null pointer dereference that can cause kernel panic, along with the potential for denial of service, makes this a legitimate security vulnerability deserving of a CVE assignment.
54e6fe9dd3b0 ipv6: prevent infinite loop in rt6_nlmsg_size()
- [sasha] ## Analysis
  **YES** - This commit should be assigned a CVE.
  ## Explanation:
  This commit fixes a **denial-of-service vulnerability** that can cause an infinite loop in the kernel's IPv6 routing code, leading to system hang/soft lockup. Here's the security analysis:
  ### 1. **Vulnerability Type**: Infinite Loop / DoS
  The commit message explicitly states: "I was able to trigger an infinite loop in rt6_nlmsg_size()"
  ### 2. **Root Cause**:
  The issue occurs because of improper RCU list handling when `list_del_rcu()` is used, which can confuse RCU readers traversing the sibling list. When a route is deleted while another thread is reading the list, the reader might lose track of the list head and loop infinitely.
  ### 3. **Critical Code Changes**:
  - **ip6_fib.c**: Changes `rt->fib6_nsiblings = 0` to `WRITE_ONCE(rt->fib6_nsiblings, 0)` to ensure atomic visibility
  - **route.c**: Adds a retry mechanism with `READ_ONCE()` checks to detect when the sibling count becomes zero during traversal, preventing infinite loops
  ### 4. **Security Impact**:
  - **High severity DoS**: An infinite loop in kernel space causes CPU lockup
  - **System stability**: Can make the system unresponsive, requiring reboot
  - **Exploitability**: Can be triggered through IPv6 routing operations
  ### 5. **Relationship to Prior CVE**:
  This is a **follow-up fix** to commit d9ccb18f83ea which already addressed soft lockups in `fib6_select_path()`. The fact that the original fix received attention for soft lockup issues and this fixes a related infinite loop problem in the same subsystem strongly suggests CVE assignment is warranted.
  ### 6. **Attack Vector**:
  The vulnerability can be triggered through IPv6 routing table manipulation, which could be exploited by:
  - Local users with CAP_NET_ADMIN
  - Remote attackers if they can influence routing updates (BGP, etc.)
  - Container escapes in multi-tenant environments
  The infinite loop prevention through atomic operations and retry logic is clearly a security-critical fix preventing system DoS.
f8d8ce1b515a ipv6: fix possible infinite loop in fib6_info_uses_dev()
- [sasha] Let me check the actual diff context provided to understand the pattern better:
  Based on my analysis of the commit:
  **YES**, this commit should be assigned a CVE.
  **Explanation:**
  This commit fixes a **possible infinite loop vulnerability** in the `fib6_info_uses_dev()` function that can lead to a system hang or denial of service. The key security-relevant aspects are:
  1. **Infinite Loop Vulnerability**: The commit message explicitly states "fix possible infinite loop in fib6_info_uses_dev()". The function was traversing the `fib6_siblings` linked list without proper RCU protection while other code paths (`fib6_del_route()` or `fib6_add_rt2node()`) could concurrently remove nodes from the list.
  2. **Race Condition Fix**: The code changes show:
     - Addition of `rcu_read_lock()`/`rcu_read_unlock()` to protect the list traversal
     - Change from `list_for_each_entry_safe()` to `list_for_each_entry_rcu()` 
     - Addition of `READ_ONCE()` checks for `f6i->fib6_nsiblings`
     - Early break condition `if (!READ_ONCE(f6i->fib6_nsiblings))` to detect list corruption
  3. **Direct Link to Previous CVE**: The Fixes tag references commit d9ccb18f83ea which fixed CVE-worthy soft lockups in IPv6 routing. This new issue is a **continuation of the same vulnerability pattern** - improper RCU protection leading to infinite loops during concurrent list modifications.
  4. **Exploitability**: An attacker who can trigger route updates while the system is checking device usage could potentially cause the kernel to enter an infinite loop, resulting in:
     - CPU soft lockup
     - System hang/DoS
     - Potential kernel panic (if soft lockup panic is enabled)
  The vulnerability pattern is identical to the referenced commit which dealt with soft lockups - concurrent modification of the fib6_siblings linked list without proper synchronization can cause infinite loops when traversing the list. This is a clear denial of service vulnerability that warrants CVE assignment.
b114fcee766d bpf, arm64: Fix fp initialization for exception boundary
- [sasha] ## Answer:
  **YES**
  This commit should be assigned a CVE because:
  1. **Kernel crash vulnerability**: The commit explicitly states "This can cause the kernel to crash due to a pagefault" - this is a clear denial-of-service vulnerability
  2. **Memory safety issue**: The bug involves an uninitialized frame pointer in BPF JIT-compiled code for ARM64, which is a memory safety vulnerability that can lead to kernel crashes
  3. **Exploitable attack vector**: BPF programs can potentially be loaded by unprivileged users (depending on system configuration), and a specially crafted BPF program acting as an exception boundary could trigger this crash
  4. **Clear security boundary violation**: The bug allows BPF programs to cause kernel crashes, violating the security boundary that BPF is supposed to maintain between user-provided code and kernel execution
  The fix is a one-line addition that ensures proper frame pointer initialization for exception boundary BPF programs, preventing potential kernel crashes from uninitialized memory access.
ee4cf798202d staging: media: atomisp: Fix stack buffer overflow in gmin_get_var_int()
- [sasha] Let me analyze this commit based on the provided information:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Stack Buffer Overflow Vulnerability**: The commit explicitly fixes a stack buffer overflow in `gmin_get_var_int()`. The vulnerability occurs when:
     - A 65-byte buffer (`val[CFG_VAR_NAME_MAX + 1]`) is allocated on the stack
     - When an EFI variable larger than 64 bytes is encountered, `efi.get_variable()` returns `EFI_BUFFER_TOO_SMALL` and updates `*out_len` to the required size
     - Due to improper error handling, the code incorrectly believes the call succeeded
     - The line `val[len] = 0` then writes beyond the 65-byte buffer boundary
  2. **Exploitable Security Impact**: The commit message explicitly states "this could potentially be exploited for code execution" since:
     - It's a stack-based buffer overflow
     - EFI variables can be controlled by firmware or system configuration
     - This provides an attack vector for potential code execution
  3. **Clear Security Fix Pattern**: The code change shows:
     - Before: Returns stale `ret` value regardless of EFI call status
     - After: Properly returns 0 on `EFI_SUCCESS` and `-ENOENT` on failure
     - This prevents the overflow by ensuring proper error propagation
  4. **Attack Surface**: The vulnerability affects camera sensor initialization on Intel Bay Trail and Cherry Trail platforms, which are real-world systems where firmware-controlled variables could be manipulated.
  The fix prevents writing past the stack buffer boundary by ensuring that when `efi.get_variable()` fails (including `EFI_BUFFER_TOO_SMALL`), the error is properly propagated to the caller, preventing the out-of-bounds write.
b6cd3cfb5afe crypto: sun8i-ce - fix nents passed to dma_unmap_sg()
- [sasha] Let me analyze the commit based on the provided information:
  **Analysis:**
  1. **Nature of the fix**: The commit fixes an incorrect call to `dma_unmap_sg()` where it was using the wrong count - the number returned by `dma_map_sg()` instead of the original number of entries.
  2. **Code changes**: 
     - Changes `rctx->nr_sgs = nr_sgs;` to `rctx->nr_sgs = ns;`
     - Changes `rctx->nr_sgd = nr_sgd;` to `rctx->nr_sgd = nd;`
     - Where `nr_sgs/nr_sgd` are the return values from `dma_map_sg()` and `ns/nd` are the original counts
  3. **Security implications**:
     - This is a DMA API usage bug - using wrong counts for unmapping
     - Could lead to incomplete DMA unmapping (if `nr_sgs < ns`)
     - Potential for DMA mappings to remain active when they shouldn't be
     - This could theoretically lead to:
       - Memory leaks in DMA space
       - Potential information disclosure if DMA mappings persist
       - Resource exhaustion over time
  4. **Comparison with reference commit**:
     - The reference commit (0605fa0f7826) was a refactoring that introduced this bug
     - That commit split operations but wasn't fixing a security issue itself
  5. **Impact assessment**:
     - The bug affects the crypto subsystem's DMA handling
     - Incorrect DMA unmapping is generally considered a security-relevant issue
     - Could potentially lead to information leaks through persistent DMA mappings
  **Answer: YES**
  This commit should be assigned a CVE. The incorrect DMA unmapping count is a security-relevant bug that could lead to:
  1. Persistent DMA mappings that shouldn't exist, potentially exposing sensitive cryptographic data
  2. Resource leaks that could be exploited for denial of service
  3. Violation of security boundaries in DMA memory management
  The fact that this occurs in cryptographic code handling sensitive data (keys, IVs, plaintext/ciphertext) makes the security impact more significant. Incorrect DMA handling in crypto drivers has historically been considered CVE-worthy.
71203f68c774 padata: Fix pd UAF once and for all
- [sasha] **YES**
  This commit should be assigned a CVE based on the following security-critical factors:
  1. **Use-After-Free (UAF) Vulnerability**: The commit explicitly states it fixes a "pd UAF" (Use-After-Free) vulnerability in the commit message. UAF vulnerabilities are serious memory corruption issues that can lead to arbitrary code execution.
  2. **Long-standing Security Issue**: The commit message indicates this vulnerability "goes back to the initial commit" (16295bec6398 from the Fixes tag), meaning this security issue has existed since the padata subsystem was first introduced, affecting many kernel versions.
  3. **Race Condition Leading to UAF**: The code changes show the fix for a race condition in `padata_reorder()` where:
     - Once `padata` is added to `queue->serial.list` and the lock is released
     - Another CPU could process it and free the reference count on `pd` 
     - Leading to use-after-free when the original CPU continues to access `pd`
  4. **Critical Code Path**: The padata subsystem is used for parallel processing in the kernel, including cryptographic operations. A UAF in this subsystem could potentially be exploited for privilege escalation or denial of service.
  5. **Concrete Fix Pattern**: The patch shows a clear security fix by restructuring the code to:
     - Get the next padata object before releasing the lock
     - Simplify the reordering logic to prevent the race condition
     - Remove the problematic `pd->lock` and `reorder_work` mechanism
  The removal of complex locking mechanisms and the restructuring to prevent accessing potentially freed memory clearly indicates this is fixing an exploitable memory safety issue.
51ad3b570ea7 media: imx-jpeg: Account for data_offset when getting image address
- [sasha] **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Out-of-bounds memory access vulnerability**: The driver was not accounting for `data_offset` when calculating memory addresses for DMA operations and virtual address access. When userspace applications set a `data_offset` value, the driver would access memory at incorrect offsets, potentially reading from or writing to memory outside the intended buffer boundaries.
  2. **User-controlled input affecting kernel memory access**: The `data_offset` is set by userspace applications through the V4L2 API. A malicious application could potentially exploit this by setting specific offset values to cause the kernel driver to access unintended memory regions.
  3. **Information disclosure and memory corruption potential**: The incorrect memory access could lead to:
     - Reading sensitive data from adjacent memory regions (information disclosure)
     - Writing to unintended memory locations (memory corruption)
  4. **Hardware DMA operations at wrong addresses**: The bug affects DMA addresses passed to hardware (`desc->buf_base0`, `desc->buf_base1`, `desc->stm_bufbase`), which could cause the hardware to perform DMA operations on incorrect memory regions.
  The fix properly accounts for `data_offset` in all memory access calculations and adds alignment validation, preventing these potential security issues.
803b9eabc649 media: v4l2-ctrls: Fix H264 SEPARATE_COLOUR_PLANE check
- [sasha] ## CVE Assignment Recommendation
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Input Validation Vulnerability**: The bug allows invalid H264 parameter combinations (specifically `SEPARATE_COLOUR_PLANE` flag set when `chroma_format_idc != 3`) to bypass validation checks, violating the H264 specification requirements.
  2. **Security-Sensitive Component**: The V4L2 media subsystem processes potentially untrusted media data. Improper validation in media codecs is a well-known attack vector that has led to numerous security vulnerabilities historically.
  3. **Potential for Exploitation**: Invalid parameter combinations reaching lower-level drivers or hardware that expect properly validated input could lead to:
     - Memory corruption
     - Crashes/DoS
     - Potentially more severe impacts depending on how drivers handle the invalid state
  4. **Clear Fix Pattern**: This is a classic input validation fix that prevents invalid states from propagating through the system - a common security vulnerability pattern in media handling code.
3b0abc443ac2 clk: xilinx: vcu: unregister pll_post only if registered correctly
- [sasha] Looking at this commit, I need to analyze the security implications:
  ## Analysis
  **What the commit fixes:**
  This commit fixes a NULL pointer dereference that occurs when trying to unregister a PLL post divider that was never successfully registered. The issue manifests as a kernel crash with a NULL pointer dereference at virtual address 0x008.
  **Code changes:**
  The fix adds a NULL/error pointer check before calling `clk_hw_unregister_fixed_factor()`:
  ```c
  -	clk_hw_unregister_fixed_factor(xvcu->pll_post);
  +	if (!IS_ERR_OR_NULL(xvcu->pll_post))
  +		clk_hw_unregister_fixed_factor(xvcu->pll_post);
  ```
  **Security implications:**
  1. **NULL pointer dereference** - This can cause a kernel panic/crash, leading to a denial of service
  2. **Triggerable condition** - This occurs during driver cleanup when PLL registration fails, which could potentially be triggered by:
     - Hardware misconfiguration
     - Resource exhaustion during registration
     - Invalid device tree configuration
  3. **Impact** - System crash/DoS requiring a reboot
  **Context from the Fixes commit:**
  The referenced commit (4472e1849db7) introduced the `pll_post` handling but didn't account for cleanup in error conditions where registration might fail.
  ## Verdict
  **YES**
  This commit should be assigned a CVE because:
  1. It fixes a **kernel NULL pointer dereference** vulnerability that leads to a system crash (denial of service)
  2. The vulnerability is in error handling paths that could potentially be triggered through misconfiguration or resource exhaustion
  3. The impact is a complete system crash requiring reboot, which is a clear availability/DoS issue
  4. Similar NULL pointer dereference fixes in kernel drivers have historically been assigned CVEs when they lead to system crashes
  While this is in a platform-specific driver (Xilinx VCU), it still represents a security vulnerability that affects system availability for affected platforms.
65bd0be48639 pinctrl: canaan: k230: add NULL check in DT parse
- [sasha] Looking at this commit, I need to analyze both the commit message and the code changes to determine if this fixes a security vulnerability.
  **Commit Analysis:**
  1. **What the commit fixes:**
     - Adds a NULL check for the return value of `of_get_property()` when retrieving the "pinmux" property
     - Fixes a typo in a comment (not security relevant)
  2. **The security-relevant code change:**
  ```c
  list = of_get_property(np, "pinmux", &size);
  +if (!list) {
  +    dev_err(dev, "failed to get pinmux property\n");
  +    return -EINVAL;
  +}
  size /= sizeof(*list);
  ```
  3. **The vulnerability:**
     - Without this check, if `of_get_property()` returns NULL (when the "pinmux" property is missing from the device tree), the code would:
       - Continue executing with `list = NULL`
       - Attempt to divide `size` by `sizeof(*list)` 
       - Later dereference the NULL pointer in the loop: `mux_data = be32_to_cpu(*list++)`
     - This would cause a NULL pointer dereference leading to a kernel crash
  4. **Security Impact:**
     - **NULL pointer dereference in kernel space** - This can cause a kernel panic/crash
     - The vulnerability is triggered by malformed or missing device tree data
     - Could be exploited locally by someone with ability to modify device tree (requires privileged access)
     - Results in denial of service (system crash)
  5. **Attack Vector:**
     - Requires local access with privileges to modify device tree
     - Could be triggered during system boot with a malformed device tree
     - Limited exploitability as it requires significant privileges
  **CVE Decision: YES**
  This commit should be assigned a CVE because:
  1. It fixes a **NULL pointer dereference vulnerability** in kernel code that leads to a system crash
  2. The vulnerability has a clear security impact (denial of service through kernel panic)
  3. Similar NULL pointer dereference fixes in kernel drivers are commonly assigned CVEs
  4. Even though exploitation requires privileged access, kernel crashes are considered security issues as they violate system availability
  5. The commit explicitly uses "Fixes:" tag indicating this addresses a bug in production code
  The vulnerability allows a local attacker with device tree modification capabilities to cause a kernel crash by omitting the "pinmux" property from a pinctrl device tree node.
d94a32ac688f pinctrl: canaan: k230: Fix order of DT parse and pinctrl register
- [sasha] Looking at this commit, I need to analyze both the changes and their security implications.
  **The commit changes:**
  The commit reorders operations in the `k230_pinctrl_probe()` function:
  - **Before**: `devm_pinctrl_register()` was called first, then `k230_pinctrl_parse_dt()`
  - **After**: `k230_pinctrl_parse_dt()` is called first, then `devm_pinctrl_register()`
  **Security Analysis:**
  1. **The vulnerability**: The original code registered the pinctrl device with uninitialized pin resources (groups, functions, etc.) because the DT parsing that initializes these resources happened after registration.
  2. **Potential impact**: When `devm_pinctrl_register()` is called with uninitialized data structures:
     - `info->groups` and `info->functions` would be NULL
     - `info->ngroups` and `info->nfunctions` would be 0
     - The pinctrl subsystem would operate on these uninitialized/NULL pointers
  3. **Security implications**: This could lead to:
     - NULL pointer dereferences when the pinctrl subsystem tries to access groups/functions
     - Use of uninitialized memory
     - Potential kernel crashes or unpredictable behavior
     - Could potentially be exploited for denial of service
  4. **Attack vector**: This would likely require local access to trigger pinctrl operations, as it's a driver initialization issue.
  **CVE Decision: YES**
  This commit should be assigned a CVE because:
  1. It fixes a clear use-of-uninitialized-value vulnerability where critical data structures are accessed before initialization
  2. The bug could lead to NULL pointer dereferences and kernel crashes, constituting a denial of service vulnerability
  3. The issue affects kernel memory safety, which is a security boundary
  4. Similar initialization order bugs in kernel drivers have historically been assigned CVEs when they can cause crashes or memory safety issues
  The vulnerability represents a legitimate security issue where improper initialization ordering leads to the use of uninitialized kernel data structures, potentially causing system instability or crashes.
f458ccd2aa2c RDMA/uverbs: Check CAP_NET_RAW in user namespace for flow create
- [sasha] ## CVE Decision: **YES**
  This commit should be assigned a CVE because:
  1. **Security Boundary Violation**: The bug incorrectly enforces security checks across namespace boundaries, denying legitimate access to containerized processes with proper capabilities
  2. **Denial of Service**: Prevents authorized containerized applications from functioning correctly with RDMA flow steering
  3. **Production Impact**: Affects real-world container deployments (Podman explicitly mentioned) using RDMA technology
  4. **Clear Security Fix**: The commit explicitly fixes an authorization/capability checking issue that has security implications
  While this is not a privilege escalation or data exposure vulnerability, it is a **security-relevant denial of service** bug that breaks the container security model by incorrectly denying access to properly authorized processes. CVEs are appropriate for bugs that impact the availability of security-sensitive functionality in production systems.
a6dca091ba76 RDMA/uverbs: Check CAP_NET_RAW in user namespace for RAW QP create
- [sasha] **YES**
  This commit should be assigned a CVE because it fixes a security vulnerability related to insufficient privilege checking that causes legitimate containerized applications to fail.
  The security issue is:
  1. **Incorrect privilege checking scope**: The original code used `capable(CAP_NET_RAW)` which only checks capabilities in the initial/default user namespace. This prevented legitimate processes running in containers (like Podman) from creating RAW QPs even when they had the appropriate CAP_NET_RAW capability within their container's user namespace.
  2. **Security impact**: This is a privilege escalation issue in reverse - it was overly restrictive, preventing authorized operations. However, the fix introduces a proper namespace-aware capability check (`rdma_uattrs_has_raw_cap()`) that correctly validates CAP_NET_RAW in the appropriate user namespace context.
  3. **The new check is security-critical**: The function `rdma_dev_has_raw_cap()` properly checks `ns_capable(net->user_ns, CAP_NET_RAW)` against the network namespace's owning user namespace, which is the correct security boundary for RDMA devices.
  4. **RAW QP access control**: RAW QPs (Queue Pairs) allow direct packet injection and are security-sensitive resources that require CAP_NET_RAW capability. The incorrect capability check could have security implications in multi-tenant environments where proper namespace isolation is critical.
  The commit message explicitly states this "fixes" the issue introduced in commit 6d1e7ba241e9, and the code change replaces a broken security check with a proper namespace-aware one. This type of authorization bypass/restriction bug in security-sensitive kernel subsystems typically warrants a CVE assignment.
1fdf938168c4 perf tools: Fix use-after-free in help_unknown_cmd()
- [sasha] **YES**
  This commit fixes a clear use-after-free vulnerability in the `exclude_cmds()` function. The vulnerability causes memory corruption and crashes (core dumps) when processing invalid commands. The code changes show the fix prevents double-free by replacing the problematic `zfree(&cmds->names[cj])` before assignment with a simple pointer move and NULL assignment. Use-after-free vulnerabilities are serious security issues that can potentially be exploited for arbitrary code execution, making this worthy of CVE assignment.
c6957b95ecc5 RDMA/hns: Fix double destruction of rsv_qp
- [sasha] ## Answer:
  **YES**
  This commit fixes a double-free vulnerability in the RDMA/hns kernel driver. The stack trace clearly shows `list_del corruption` with LIST_POISON1, indicating memory corruption from double destruction of rsv_qp. The vulnerability occurs in error handling paths where rsv_qp is freed twice - first in `free_mr_init()` and then in `hns_roce_exit()`. This is a kernel memory safety issue that could lead to system crashes or potentially privilege escalation. The fact that this fixes a previous security fix (fd8489294dd2 which addressed a Use-After-Free) that introduced a new vulnerability makes it security-relevant.
181698af38d3 crypto: ccp - Fix crash when rebind ccp device for ccp.ko
- [sasha] ## Decision: **YES**
  This commit should be assigned a CVE because:
  1. **Kernel Crash/DoS**: The vulnerability causes a kernel NULL pointer dereference resulting in a system crash, which is a denial of service condition
  2. **Memory Safety Issue**: This is a use-after-free vulnerability where the `ccp_debugfs_dir` pointer is not properly nullified after being freed, leading to dereferencing a stale pointer
  3. **Reproducible Attack**: The issue can be reliably triggered through sysfs operations (unbind/bind), though it requires privileged access
  4. **Security Boundary Violation**: Even though it requires privileged access, it still represents a security vulnerability as it can crash the kernel unexpectedly, potentially disrupting system availability
  While the attack requires local privileged access and a specific kernel configuration (CONFIG_CRYPTO_DEV_CCP_DEBUGFS), kernel crashes are generally considered security vulnerabilities worthy of CVE assignment, especially when they involve memory safety issues like use-after-free conditions.
ff7ec8dc1b64 proc: use the same treatment to check proc_lseek as ones for proc_read_iter et.al
- [sasha] **YES**
  This commit fixes a Use-After-Free (UAF) vulnerability in the proc filesystem that could be triggered during module removal (rmmod). The key security issue:
  1. **UAF Vulnerability**: The original code directly checked `pde->proc_ops->proc_lseek` in `proc_reg_open()`, which could cause a use-after-free if the module containing the proc_ops structure was removed while the check was happening.
  2. **Race Condition**: The vulnerability creates a race condition between:
     - Opening a /proc file (checking proc_lseek)
     - Module removal (freeing the proc_ops structure)
  3. **Security Impact**: UAF vulnerabilities can potentially lead to:
     - System crashes/denial of service
     - Information disclosure (reading freed memory)
     - Potential code execution (if attacker can control freed memory)
  4. **Fix Pattern**: The fix follows the same secure pattern used for other proc_ops members (proc_read_iter, proc_compat_ioctl) by:
     - Caching the proc_lseek presence in a flag during proc entry creation
     - Checking the cached flag instead of dereferencing potentially freed memory
  The commit message explicitly states it fixes a "UAF in rmmod scenario" and references commit 654b33ada4ab which addressed similar UAF issues. This is a classic memory safety vulnerability in kernel code that warrants CVE assignment.
023a293b9cd0 scsi: ibmvscsi_tgt: Fix dma_unmap_sg() nents value
- [sasha] YES
  This commit should be assigned a CVE because it fixes a memory corruption vulnerability in the DMA unmapping logic that could lead to security issues.
  The vulnerability is in the incorrect parameter passed to `dma_unmap_sg()`. The code was incorrectly using `nsg` (the return value from `dma_map_sg()`) instead of `cmd->se_cmd.t_data_nents` (the original number of entries):
  ```c
  // Before (incorrect):
  dma_unmap_sg(iue->target->dev, sg, nsg, DMA_BIDIRECTIONAL);
  // After (correct):
  dma_unmap_sg(iue->target->dev, sg, cmd->se_cmd.t_data_nents, DMA_BIDIRECTIONAL);
  ```
  This is a security-relevant bug because:
  1. **Memory corruption potential**: The `dma_map_sg()` function can return fewer entries than provided (due to coalescing), but `dma_unmap_sg()` must be called with the original count. Using the wrong count can lead to incomplete DMA unmapping, leaving stale DMA mappings.
  2. **DMA security implications**: Incorrect DMA unmapping can leave memory accessible to devices when it shouldn't be, potentially allowing unauthorized access to kernel memory or data leakage.
  3. **SCSI target driver context**: This affects the IBM VSCSI target driver which handles I/O operations between logical partitions. Improper DMA handling in this context could allow one partition to access memory from another partition.
  The bug has been present since the initial commit of the driver (88a678bbc34c from 2016), indicating it's a long-standing vulnerability that affects multiple kernel versions.
3a988d0b65d7 scsi: elx: efct: Fix dma_unmap_sg() nents value
- [sasha] YES
  This commit should be assigned a CVE because it fixes a memory corruption vulnerability that could lead to security issues.
  **Specific evidence from the code changes:**
  1. **Incorrect DMA unmapping**: The bug is in `efct_lio_sg_unmap()` where `dma_unmap_sg()` was incorrectly called with `ocp->seg_map_cnt` instead of `cmd->t_data_nents`:
     ```c
     - dma_unmap_sg(&io->efct->pci->dev, cmd->t_data_sg,
     -              ocp->seg_map_cnt, cmd->data_direction);
     + dma_unmap_sg(&io->efct->pci->dev, cmd->t_data_sg,
     +              cmd->t_data_nents, cmd->data_direction);
     ```
  2. **Security implications**: 
     - The `seg_map_cnt` value is the return value from `dma_map_sg()` which can be less than the original `t_data_nents` due to scatter-gather list coalescing
     - Using the wrong count means some DMA mappings remain active after the unmap call
     - This creates a DMA mapping leak that could potentially be exploited for:
       - Information disclosure (stale DMA mappings could expose memory)
       - Memory corruption (device could continue writing to unmapped memory)
       - Denial of service (resource exhaustion from DMA mapping leaks)
  3. **SCSI target context**: This occurs in the SCSI target (LIO) backend interface, which handles I/O from remote initiators, making it potentially exploitable over the network by malicious SCSI initiators.
  The commit message explicitly states this is fixing a functional bug in DMA handling, and the code shows it corrects improper resource cleanup that could lead to memory safety issues.
78447d4545b2 PCI: Fix driver_managed_dma check
- [sasha] ## CVE Assignment Recommendation
  **YES**
  This commit should be assigned a CVE because:
  1. **TOCTOU Vulnerability**: The commit explicitly fixes a Time-of-Check to Time-of-Use race condition, which is a well-recognized security vulnerability class (CWE-367)
  2. **DMA Security Impact**: The bug could cause incorrect handling of `driver_managed_dma`, potentially allowing devices to bypass intended DMA restrictions and access memory regions they shouldn't
  3. **IOMMU Isolation Bypass**: The vulnerability affects IOMMU configuration, which is a critical security boundary for device isolation and memory protection
  4. **Exploitable Race Condition**: While requiring specific timing, race conditions in kernel driver binding paths can be triggered through controlled device attachment/detachment
  5. **Security-Critical Component**: DMA and IOMMU configuration are fundamental to system security, preventing unauthorized memory access by devices
  The use of `READ_ONCE()` to ensure atomic read and consistent pointer usage is a classic fix for TOCTOU vulnerabilities that can have security implications in kernel space.
8b61d8ca751b watchdog: ziirave_wdt: check record length in ziirave_firm_verify()
- [sasha] **YES**
  This commit fixes a stack-based buffer overflow vulnerability in the watchdog driver's firmware verification function. The vulnerability occurs when `rec->len` from untrusted firmware data exceeds the size of the `data[ZIIRAVE_FIRM_PKT_DATA_SIZE]` buffer, causing memory corruption during the loop that writes `data[i] = ret`. An attacker could craft malicious firmware files to trigger this overflow, potentially leading to code execution or denial of service. The fix adds a critical bounds check (`if (len > sizeof(data)) return -EINVAL;`) to prevent the buffer overflow.
c678bdc99875 ext4: fix inode use after free in ext4_end_io_rsv_work()
- [sasha] **YES**
  This commit fixes a **use-after-free vulnerability** in the ext4 filesystem. The commit message explicitly states "triggering a use-after-free issue" and describes a race condition where an inode could be freed while still being referenced by pending I/O work (ext4_end_io_rsv_work). 
  The code changes fix this by:
  1. Adding consistent checking in `ext4_io_end_defer_completion()` to verify `!list_empty(&io_end->list_vec)` before deferring completion
  2. Refactoring `ext4_put_io_end_defer()` to use the same checking logic as `ext4_end_bio()`, preventing the race condition
  Use-after-free vulnerabilities are serious security issues that can potentially lead to memory corruption, crashes, or arbitrary code execution in kernel context.
d956692c7dd5 crypto: qat - disable ZUC-256 capability for QAT GEN5
- [sasha] Looking at this commit, I need to analyze whether it fixes a security vulnerability that warrants a CVE assignment.
  **Analysis:**
  **Commit Purpose:** This commit disables ZUC-256 encryption and integrity algorithms on QAT GEN5 devices because the current implementation doesn't comply with the NIST specification.
  **Key Points from the commit message:**
  1. The implementation uses an outdated initialization scheme from earlier ZUC-256 specifications
  2. This scheme doesn't align with the current 5G specification
  3. The fix removes support for these non-compliant algorithms
  **Code Changes:**
  The changes remove capability flags for ZUC-256:
  - Removes `ICP_ACCEL_CAPABILITIES_ZUC_256` from the initial capabilities
  - Removes lines that would clear `ICP_ACCEL_CAPABILITIES_ZUC_256` when certain fuses are set
  - Removes the check for `ICP_ACCEL_GEN4_MASK_ZUC_256_SLICE`
  **Security Implications:**
  This is fixing a **cryptographic specification compliance issue**. Using a non-compliant cryptographic algorithm implementation could lead to:
  - Weak encryption/integrity protection
  - Potential cryptographic vulnerabilities due to using an outdated/incorrect initialization scheme
  - Interoperability issues with systems expecting standard-compliant ZUC-256
  The fact that the implementation doesn't align with NIST specifications means the cryptographic protection provided may be compromised or weaker than expected.
  **Answer:** YES
  This commit should be assigned a CVE because it fixes a cryptographic implementation flaw where the ZUC-256 algorithms were implemented incorrectly according to an outdated specification. This could potentially lead to weakened cryptographic protection when these algorithms are used, which is a security vulnerability. The commit explicitly states the implementation "does not align with the NIST specification" and uses "a different initialization scheme" from what's required by the 5G specification, indicating the cryptographic implementation was fundamentally incorrect and could compromise security.
af470fb532fc perf tools: Remove libtraceevent in .gitignore
- [sasha] 
e1e6b933c56b mtd: rawnand: atmel: Fix dma_mapping_error() address
- [sasha] YES
  This commit should be assigned a CVE because it fixes a genuine security vulnerability - a logic error in DMA error handling that could lead to security issues.
  The bug is in the error checking after `dma_map_single()`:
  ```c
  buf_dma = dma_map_single(nc->dev, buf, len, dir);
  - if (dma_mapping_error(nc->dev, dev_dma)) {
  + if (dma_mapping_error(nc->dev, buf_dma)) {
  ```
  The code was checking the wrong DMA address (`dev_dma` instead of `buf_dma`) for mapping errors. This means if `dma_map_single()` failed and returned an error value, the check would not detect it because it was testing an unrelated address. The code would then proceed to use the invalid `buf_dma` address in DMA operations:
  ```c
  tx = dmaengine_prep_dma_memcpy(nc->dmac, dst_dma, src_dma, len, ...);
  ```
  This could lead to:
  1. **Memory corruption** - Using an invalid DMA address could cause the DMA engine to read from or write to arbitrary memory locations
  2. **Information disclosure** - Invalid DMA operations could potentially expose sensitive memory contents
  3. **System instability** - DMA operations on invalid addresses could crash the system
  The vulnerability affects the ATMEL NAND flash driver's DMA transfer functionality, which is used for reading and writing NAND flash data. This is a clear programming error with security implications in kernel driver code that handles DMA operations.
abad3d0bad72 bpf: Fix oob access in cgroup local storage
- [sasha] ## CVE Determination:
  **YES**
  This commit should be assigned a CVE because:
  1. **Fixes a clear security vulnerability**: Out-of-bounds memory access in kernel space
  2. **Exploitable**: The commit message describes a concrete exploitation path via tail calls between BPF programs with mismatched storage sizes
  3. **Memory safety violation**: The vulnerability allows accessing memory beyond the intended bounds when `bpf_get_local_storage()` incorrectly uses another program's storage map with different size
  4. **Kernel context impact**: BPF programs execute in kernel space, making OOB access particularly severe
  5. **Has a reporter**: "Reported-by: Lonial Con" indicates this was discovered as a security issue
  The code changes implement proper validation through storage_cookie tracking to ensure programs can only tail-call into compatible programs with matching storage configurations, preventing the OOB access vulnerability.
400cad513c78 vhost-scsi: Fix check for inline_sg_cnt exceeding preallocated limit
- [sasha] Looking at this commit, I need to analyze both the commit message and the code changes to determine if this represents a security vulnerability.
  **Code Analysis:**
  The bug is in the `vhost_scsi_set_inline_sg_cnt()` function:
  ```c
  ret = kstrtouint(buf, 10, &cnt);
  if (ret)
      return ret;
  -if (ret > VHOST_SCSI_PREALLOC_SGLS) {
  +if (cnt > VHOST_SCSI_PREALLOC_SGLS) {
  ```
  The original code incorrectly checked `ret` (which contains the return value of `kstrtouint()`, typically 0 on success) instead of `cnt` (which contains the actual parsed value). This means the validation check would never trigger, allowing users to set `inline_sg_cnt` to values exceeding `VHOST_SCSI_PREALLOC_SGLS`.
  **Security Impact Assessment:**
  1. **Input Validation Bypass**: The bug allows bypassing a critical limit check that was intended to prevent excessive values.
  2. **Potential Memory Issues**: Looking at the referenced commit `bca939d5bcd0`, the `inline_sg_cnt` parameter controls scatterlist allocation. Setting it beyond the intended limit could lead to:
     - Excessive memory allocation
     - Potential buffer overflows when the code assumes the value is within bounds
     - Resource exhaustion
  3. **Attack Vector**: This is a module parameter that can be set by privileged users, limiting the attack surface but still representing a security boundary violation.
  4. **Similar CVE Patterns**: Input validation bugs that allow bypassing intended limits are commonly assigned CVEs, especially in kernel subsystems dealing with memory management.
  **Answer: YES**
  This commit should be assigned a CVE. The bug allows bypassing an important validation check for a module parameter that controls memory allocation behavior in the vhost-scsi driver. The incorrect check (`ret` instead of `cnt`) completely defeats the intended security boundary, potentially allowing values that could cause memory corruption, excessive allocation, or other undefined behavior when the system expects values to be within the VHOST_SCSI_PREALLOC_SGLS limit. Input validation bypass bugs in kernel drivers, particularly those affecting memory management, are typically considered security vulnerabilities worthy of CVE assignment.
9e6448f7b1ef bpf: Check netfilter ctx accesses are aligned
- [sasha] **YES**
  This commit should be assigned a CVE because:
  1. **Memory safety vulnerability**: The missing alignment check allows unaligned memory accesses in kernel space through BPF programs, which can cause crashes on architectures that don't support unaligned access and potentially lead to information disclosure.
  2. **Verifier bypass**: The bug allows bypassing BPF verifier safety checks that are meant to ensure memory access safety, undermining a critical security boundary.
  3. **Kernel privilege context**: Netfilter BPF programs run with kernel privileges, making any memory safety issue a potential security vulnerability.
  4. **Similar to other CVE-worthy fixes**: The commit message references this as being "Similarly to the previous patch fixing the flow_dissector ctx accesses", and alignment check bypasses in BPF contexts have historically been assigned CVEs as they represent verifier security boundary violations.
154467f4ad03 f2fs: fix KMSAN uninit-value in extent_info usage
- [sasha] Based on my analysis, here is my determination:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Memory safety vulnerability**: The commit fixes a use of uninitialized memory that was detected by KMSAN (Kernel Memory Sanitizer). The `get_read_extent_info()` function only initializes three fields (`fofs`, `blk`, `len`) of the `struct extent_info`, leaving the `c_len` field uninitialized when CONFIG_F2FS_FS_COMPRESSION is enabled.
  2. **Security-relevant code path**: The uninitialized `c_len` field is accessed in security-sensitive merging operations in `__is_extent_mergeable()` (lines 154-156 in extent_cache.c), where it's used to make decisions about whether extents can be merged. This occurs when processing compressed files in F2FS.
  3. **Potential for exploitation**: Uninitialized memory can contain arbitrary values from previous operations, which could lead to:
     - Incorrect extent merging decisions
     - Information disclosure (leaking kernel memory contents)
     - Potential denial of service if the uninitialized values cause unexpected behavior
  4. **Clear security fix**: The fix explicitly zero-initializes the entire `extent_info` structure (`struct extent_info ei = {0};`) before populating it, ensuring all fields including `c_len` are properly initialized.
  5. **Affects a stable component**: This affects the F2FS filesystem's extent cache mechanism, particularly when handling compressed files, which is a stable kernel component that could be exploited by local users with filesystem access.
  The commit message clearly identifies this as fixing undefined behavior from accessing uninitialized memory, and the code change demonstrates this is a memory safety issue in the kernel filesystem layer that could have security implications.
a509a55f8eec f2fs: fix to avoid panic in f2fs_evict_inode
- [sasha] **YES**
  This commit should be assigned a CVE based on the following analysis:
  1. **Use-After-Free (UAF) Vulnerability**: The commit explicitly fixes a KASAN-detected use-after-free vulnerability in `__list_del_entry_valid()`. The stack trace shows the UAF occurs when accessing memory at `ffff88812d962278` during `f2fs_inode_synced()` after the inode has already been freed.
  2. **Memory Safety Impact**: The bug allows accessing freed memory (856 bytes inside a 1200-byte freed f2fs_inode object), which can lead to:
     - System crashes/denial of service (kernel BUG/panic)
     - Potential information disclosure from reading freed memory
     - Possible memory corruption
  3. **Triggerable via Crafted Input**: The vulnerability can be triggered using a fuzzed/corrupted filesystem image, as shown by the syzbot reproducer. This means an attacker could craft a malicious filesystem image to trigger the vulnerability.
  4. **Root Cause**: The code failed to properly handle error conditions where both `f2fs_truncate()` and `f2fs_update_inode_page()` fail due to corrupted inode data. This leaves the inode in a dirty state (`FI_DIRTY_INODE` flag set) without properly cleaning it up, leading to the UAF when the inode is later accessed in `f2fs_sync_inode_meta()`.
  5. **Fix Implementation**: The patch adds proper error handling by calling `f2fs_inode_synced()` to clear the dirty inode status even when errors occur (lines 943-949), preventing the later use-after-free.
  The combination of memory safety violation, system crash potential, and the ability to trigger via crafted input makes this a security vulnerability warranting CVE assignment.
7c30d7993013 f2fs: fix to avoid UAF in f2fs_sync_inode_meta()
- [sasha] Looking at this commit, I need to analyze both the security implications and the code changes.
  **Security Analysis:**
  1. **The vulnerability**: This fixes a Use-After-Free (UAF) vulnerability in `f2fs_sync_inode_meta()` where freed inode memory could be accessed during checkpoint operations.
  2. **Root cause**: With a fuzzed/malformed filesystem image, f2fs could fail to clear the `FI_DIRTY_INODE` flag, leaving a freed inode in the global `sbi->inode_list[DIRTY_META]` list. When a checkpoint occurs, `f2fs_sync_inode_meta()` would traverse this list and access the already-freed inode.
  3. **Impact**: The KASAN report shows this is a real memory safety issue that could lead to:
     - System crashes/denial of service
     - Potential information disclosure (reading freed memory)
     - Possible arbitrary code execution (typical UAF exploitation scenario)
  4. **Attack vector**: Requires mounting a specially crafted/malformed f2fs filesystem image.
  **Code Changes:**
  The fix ensures `f2fs_inode_synced()` is always called in `f2fs_evict_inode()` to:
  - Clear the `FI_DIRTY_INODE` flag
  - Remove the inode from the global dirty list
  The key change is moving from conditional execution:
  ```c
  - else
  -     f2fs_inode_synced(inode);
  ```
  To unconditional execution:
  ```c
  + /*
  +  * anyway, it needs to remove the inode from sbi->inode_list[DIRTY_META]
  +  * list to avoid UAF in f2fs_sync_inode_meta() during checkpoint.
  +  */
  + f2fs_inode_synced(inode);
  ```
  **CVE Assessment: YES**
  This should be assigned a CVE because:
  1. It fixes a demonstrable memory safety vulnerability (Use-After-Free)
  2. The vulnerability has security implications beyond just crashes - UAF bugs are commonly exploitable
  3. It affects a production filesystem that could be exposed to untrusted input (mounting external media, container images, etc.)
  4. The bug has been present since commit 0f18b462b2e5 (2016), affecting multiple kernel versions
  5. Similar f2fs UAF fixes have received CVEs in the past
  The fact that this requires a malformed filesystem image doesn't diminish the security impact, as filesystem drivers must handle malformed input safely, and mounting untrusted filesystems is a common attack vector.
08a7efc5b02a f2fs: vm_unmap_ram() may be called from an invalid context
- [sasha] Now I understand the full context. Looking at the commit:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Kernel BUG/Warning with Security Impact**: The commit fixes a "BUG: sleeping function called from invalid context" issue, which represents a kernel programming violation that can lead to system instability and potential security issues. The stack trace shows this occurs in interrupt context (irq/22-ufshcd).
  2. **Invalid Context Memory Operations**: The bug involves calling `vm_unmap_ram()` (which may sleep due to the `might_sleep()` check at line 2986 in mm/vmalloc.c) from an atomic context (interrupt handler with interrupts disabled). This violates kernel locking rules and can lead to:
     - Potential deadlocks
     - Memory corruption if the sleep actually occurs
     - System instability or crashes
  3. **Attack Surface**: The issue is triggered during F2FS filesystem operations with compressed data, specifically when handling decompression in interrupt context. An attacker could potentially craft specific filesystem operations or compressed data to reliably trigger this condition.
  4. **Code Fix Analysis**: The fix changes line 283 from:
     ```c
     bool intask = in_task();
     ```
     to:
     ```c  
     bool intask = in_task() && !irqs_disabled();
     ```
     This ensures that memory unmapping operations are deferred to a safe context when called from interrupt handlers, preventing the invalid context issue.
  5. **Similar to Previous CVEs**: This type of "sleeping in atomic context" bug has historically been assigned CVEs when it can lead to system instability or crashes, as it represents a violation of kernel safety invariants that could be exploited for denial of service.
  The commit fixes a legitimate kernel safety violation that can cause system instability when processing F2FS compressed data in interrupt context, warranting CVE assignment.
5661998536af f2fs: fix to avoid out-of-boundary access in devs.path
- [sasha] Based on my analysis of the commit and code changes, here's my assessment:
  **YES**, this commit should be assigned a CVE.
  ## Explanation:
  This is a classic **out-of-bounds read vulnerability** with the following security implications:
  1. **Buffer Overflow Issue**: The on-disk structure `f2fs_device` has a `path[MAX_PATH_LEN]` field (64 bytes) followed immediately by `__le32 total_segments`. When memcpy copies exactly MAX_PATH_LEN bytes without ensuring null termination, string operations on this path can read beyond the intended boundary.
  2. **Information Disclosure**: The vulnerability causes the kernel to treat memory beyond the path array as part of the device path string. This is clearly shown in the commit message example where additional bytes (`\xff\x01, 511, 0 - 3ffff`) from adjacent fields are exposed in kernel log messages.
  3. **Kernel Memory Exposure**: The path is used in multiple places:
     - Printed in kernel logs via `f2fs_info()` (fs/f2fs/super.c:4694, 4701)
     - Exposed via sysfs (fs/f2fs/sysfs.c:1741)
     - Used in error messages (fs/f2fs/segment.c:2009)
     - Passed to `bdev_file_open_by_path()` (fs/f2fs/super.c:4668)
  4. **Attack Vector**: A malicious or corrupted f2fs filesystem image with a device path exactly 64 bytes long (no null terminator) can trigger this vulnerability when mounted, potentially exposing kernel memory contents.
  5. **Fix**: The patch adds one extra byte to the in-memory structure (`char path[MAX_PATH_LEN + 1]`) to ensure space for null termination, preventing the out-of-bounds read.
  This vulnerability allows reading adjacent kernel memory which could contain sensitive information, making it a security issue worthy of CVE assignment. The fact that it's triggered by mounting a specially crafted filesystem image makes it exploitable by unprivileged users who can mount filesystems (via USB, container mounts, etc.).
982ddd59ed97 vfio: Prevent open_count decrement to negative
- [sasha] **YES**
  This commit should be assigned a CVE for the following security-relevant reasons:
  1. **State Corruption Vulnerability**: The bug allows `open_count` to become negative (-1) when `vfio_df_close()` is called with `open_count=0`. This corrupts the device state tracking mechanism.
  2. **Security Bypass**: The corrupted state enables a security bypass where a subsequent open incorrectly passes the `open_count == 0` check in `vfio_df_open()`. This allows:
     - Setting `df->access_granted = true` when it shouldn't be allowed
     - Bypassing intended access control checks
     - Potential unauthorized device access
  3. **Reproducible Attack Vector**: The commit message explicitly describes a reproducible scenario using VFIO no-IOMMU tests where:
     - First run: Correctly fails with warning
     - Second run: Incorrectly succeeds due to the negative open_count
  4. **Access Control Impact**: VFIO (Virtual Function I/O) is a critical kernel subsystem that provides device passthrough capabilities. Improper access control in VFIO can lead to:
     - Unauthorized device access
     - Potential privilege escalation
     - Bypass of intended isolation boundaries
  5. **Code Fix Analysis**: The fix adds a check `if (!vfio_assert_device_open(device)) return;` to prevent decrementing when `open_count` is already 0, confirming this is a security-critical state validation issue.
  The vulnerability affects the kernel's device access control mechanisms and could potentially be exploited to gain unauthorized access to VFIO devices, making it worthy of CVE assignment.
7bdc68921481 scsi: Revert "scsi: iscsi: Fix HW conn removal use after free"
- [sasha] **YES**
  This commit should be assigned a CVE because it reintroduces a use-after-free vulnerability that was previously fixed. The reverted commit (c577ab7ba5f3) specifically addressed "HW conn removal use after free" - a security vulnerability. By adding back the `iscsi_put_conn()` call in `iscsi_iter_destroy_conn_fn()`, the code now has a double-free condition for non-qla4xxx drivers where both `iscsi_remove_conn()` and `iscsi_put_conn()` will attempt to free the connection object. This creates a use-after-free vulnerability that could potentially be exploited for privilege escalation or denial of service attacks. While the revert fixes a memory leak for qla4xxx drivers, it reintroduces a more serious security vulnerability for all other iSCSI drivers.
86624ba3b522 vfio/pci: Do vf_token checks for VFIO_DEVICE_BIND_IOMMUFD
- [sasha] **YES**
  This commit fixes an authentication bypass vulnerability where the VFIO_DEVICE_BIND_IOMMUFD ioctl path failed to enforce vf_token validation. The vf_token is a security mechanism that requires a shared UUID between PF and VF drivers to establish trust and prevent unauthorized access. Without this check, VF devices could be accessed without proper authentication when using the cdev interface, bypassing the security boundary between PF and VF in SR-IOV configurations. The fix adds the missing `vfio_df_check_token()` validation to enforce token requirements consistently across all device access paths.
1010b4c012b0 powerpc/eeh: Make EEH driver device hotplug safe
- [sasha] Key code changes identified:
  1. **Removal of locking around critical sections**: Lines 260-263 in the diff show removal of `pci_lock_rescan_remove()` and `pci_unlock_rescan_remove()` calls around device access in `eeh_pe_report_edev()`. This was previously protecting against race conditions when accessing PCI devices.
  2. **Moving locks to broader scope**: The locks are moved to wrap larger sections - in `eeh_handle_normal_event()` (lines 846-1126) and `eeh_handle_special_event()` (lines 1136-1234), creating coarser-grained locking.
  3. **Added NULL checks**: Line 674 in eeh_pe.c adds a check for `if (edev->pdev)` before accessing link_active_reporting, preventing potential NULL pointer dereference.
  4. **Added error handling**: Lines 1103-1107 add handling for when the bus disappears during device removal.
  **Security Impact Assessment:**
  This commit fixes race conditions that could lead to:
  - **Kernel crashes (oopses)** - These are denial of service conditions
  - **Use-after-free vulnerabilities** - When the bus/device is removed while EEH is still trying to access it
  - **NULL pointer dereferences** - When devices are accessed without proper synchronization
  The race conditions could potentially be triggered by:
  - Unprivileged users with physical access to PCIe devices (hotplug operations)
  - Malicious PCIe devices that trigger EEH errors at specific times
  - Timing attacks to cause crashes during error recovery
  **Answer: YES**
  This commit should be assigned a CVE because it fixes multiple race conditions in the kernel's EEH (Enhanced Error Handling) driver that lead to kernel crashes and potential denial of service. The vulnerabilities arise from improper synchronization between the PCIe hotplug driver and EEH error recovery, allowing use-after-free and NULL pointer dereference conditions. While these require specific hardware access or conditions to exploit, they represent legitimate security vulnerabilities in kernel code that handles hardware error recovery, and kernel crashes are considered security-relevant denial of service issues.
ef93a685e01a NFS: Fix filehandle bounds checking in nfs_fh_to_dentry()
- [sasha] **YES**
  This commit fixes a critical bounds checking vulnerability in the NFS filehandle processing code. The security issue is evident from the code changes:
  1. **Out-of-bounds memory access vulnerability**: The original code accessed `server_fh->size` at line 69 (in the diff's before state) **before** checking if the filehandle had sufficient length to contain that field. This could lead to reading beyond allocated memory boundaries.
  2. **The fix reorders operations** to perform bounds checking first:
     - Lines 77-80: Now checks minimum bounds BEFORE accessing `server_fh->size`
     - Line 82: Only accesses `server_fh->size` AFTER validating the filehandle has sufficient length
  3. **Attack vector**: This vulnerability could be triggered through the NFS export operations interface when handling crafted filehandles via `open_by_handle` syscall or NFS re-export operations, potentially leading to:
     - Information disclosure (reading out-of-bounds memory)
     - Possible denial of service through crashes
     - Potential for more severe exploitation depending on memory layout
  4. **The function `nfs_exp_embedfh()`** returns a pointer into the raw filehandle data, and accessing the `size` field of that structure without bounds checking creates the vulnerability.
  This is a classic bounds checking vulnerability where untrusted input (filehandle from userspace or network) is used to access memory without proper validation, which is a common pattern for CVE assignments in kernel code.
de9c4861fb42 pptp: ensure minimal skb length in pptp_xmit()
- [sasha] **YES**
  This commit should be assigned a CVE because it fixes a security vulnerability with the following characteristics:
  1. **Uninitialized memory read vulnerability**: The commit message explicitly states "otherwise we might read uninit data as reported by syzbot" with a KMSAN (Kernel Memory Sanitizer) bug report showing an "uninit-value" issue at drivers/net/ppp/pptp.c:193.
  2. **Missing bounds checking**: The key fix adds `if (!pskb_may_pull(skb, 3))` at line 191-192 to ensure the skb has at least 3 bytes before accessing `data[0]`, `data[1]`, and `data[2]` at line 195. Without this check, the code was reading potentially uninitialized or out-of-bounds memory.
  3. **Information disclosure risk**: Reading uninitialized kernel memory can potentially leak sensitive information from kernel memory to attackers, which is a classic security vulnerability class.
  4. **Long-standing vulnerability**: The Fixes tag references "Linux-2.6.12-rc2" from 2005, indicating this has been present in the kernel for nearly 20 years.
  5. **Similar pattern to known CVE-worthy fix**: The commit message references a similar fix in commit aabc6596ffb3 for ppp_sync_txmunge() that added bounds checking, suggesting this is a known vulnerability pattern in PPP code.
  The vulnerability allows reading uninitialized kernel memory through the PPTP protocol handler, which could potentially expose sensitive kernel data, making it a legitimate security issue warranting CVE assignment.
ffcfd071eec7 spi: cs42l43: Property entry should be a null-terminated array
- [sasha] **YES**
  This commit fixes a memory safety vulnerability that can lead to out-of-bounds memory access and potential kernel crashes.
  **Key security indicators:**
  1. **Memory safety bug**: The original code allocated only one `property_entry` struct but failed to null-terminate the array. The fix changes from `devm_kmalloc(priv->dev, sizeof(*props), GFP_KERNEL)` to `devm_kcalloc(priv->dev, 2, sizeof(*props), GFP_KERNEL)`, allocating space for 2 entries with the second being zero-initialized as a terminator.
  2. **Out-of-bounds read**: The commit message explicitly states "the node parse walks off the end of the array into unknown memory" - this is a classic buffer overread vulnerability that can access arbitrary kernel memory.
  3. **Downstream impact**: The bug affects the cs35l56 amplifier driver which processes this unterminated array, potentially reading sensitive kernel memory or causing crashes.
  4. **Kernel context**: This occurs in kernel driver code where memory safety violations can have severe consequences including information disclosure, denial of service, or potentially privilege escalation depending on what memory is accessed.
  5. **Bug report reference**: The commit references a kernel bugzilla entry (220371), indicating this was a real issue encountered in production.
  The vulnerability allows reading beyond allocated memory boundaries in kernel space, which is a well-established security issue class that typically warrants CVE assignment.
d45cf1e7d718 ipv6: reject malicious packets in ipv6_gso_segment()
- [sasha] ## **YES**
  This commit should be assigned a CVE because:
  1. **Integer Overflow Vulnerability**: The commit fixes a 16-bit integer overflow in `skb->transport_header` that occurs when processing IPv6 packets with very long extension headers
  2. **Remote Exploitation**: The vulnerability can be triggered remotely by sending specially crafted IPv6 packets without authentication, as evidenced by the syzbot reproducer
  3. **Security Boundary Violation**: The fix adds explicit bounds checking (`skb_reset_transport_header_careful()`) to reject malicious packets that would cause the overflow, preventing kernel memory corruption
  4. **Kernel-Level Impact**: The stack trace shows this affects the kernel's network stack at a fundamental level (ipv6_gso_segment), potentially leading to denial of service or worse consequences
  5. **Clear Security Fix Pattern**: The commit explicitly states it "reject[s] malicious packets" and adds defensive validation that wasn't present before, which is a classic security hardening pattern
  The vulnerability allows remote attackers to cause kernel warnings and potentially more severe impacts through crafted IPv6 packets with excessive extension headers.
cc5d59081fa2 sunrpc: fix client side handling of tls alerts
- [sasha] **YES**
  This commit should be assigned a CVE. The commit message explicitly states "A security exploit was discovered" and the code fixes an exploitable vulnerability in NFS over TLS where invalid assumptions about the msghdr iterator's kvec could lead to memory safety issues. The vulnerability occurs in `tls_alert_recv()` when processing TLS control messages, where the code incorrectly assumed valid data existed in the iterator without proper validation. This could potentially be exploited remotely through crafted TLS messages to cause crashes or potentially worse impacts in the kernel's network stack.
4b31bcb025cb eth: fbnic: unlink NAPIs from queues on error to open
- [sasha] **YES**
  This commit should be assigned a CVE because it fixes a **Use-after-Free (UaF) vulnerability** that can be triggered through normal network operations:
  ## Security Impact Analysis:
  1. **Use-after-Free Vulnerability**: The commit message explicitly states "CI hit a UaF in fbnic" - a Use-after-Free condition where the NAPI pointer was accessed after the NAPI structure had been freed.
  2. **Triggerable Path**: The vulnerability occurs when:
     - Device fails to open (error in `__fbnic_open()`)
     - NAPI structures are freed but the queue->NAPI association remains
     - Later, AF_XDP socket binding (`xsk_bind()`) tries to access the freed NAPI through `__sk_mark_napi_id_once()`
  3. **Code Fix**: The patch adds a critical cleanup step:
     - **Before fix**: On error after `fbnic_set_netif_queues()`, the code jumped directly to `free_resources` without unlinking NAPIs from queues
     - **After fix**: Added `fbnic_reset_netif_queues(fbn)` call at new `err_reset_queues` label (line 36 and 60-61)
  4. **Memory Safety Violation**: Use-after-free vulnerabilities are serious security issues that can potentially lead to:
     - System crashes (DoS)
     - Information disclosure (reading freed memory)
     - Potentially arbitrary code execution (if attacker can control freed memory contents)
  5. **Attack Surface**: This affects the Meta fbnic network driver's AF_XDP functionality, which is accessible to users with appropriate network permissions.
  The vulnerability represents a clear memory safety issue in kernel space that can be triggered through user-space operations (AF_XDP socket binding), making it a legitimate security vulnerability warranting CVE assignment.
fa516c0d8bf9 net: devmem: fix DMA direction on unmapping
- [sasha] YES
  This commit should be assigned a CVE based on the following security-relevant aspects:
  1. **Incorrect DMA Direction During Unmapping**: The bug involves always unmapping DMA buffers with `DMA_FROM_DEVICE` direction regardless of the actual direction used during mapping. Looking at the code changes:
     - The fix changes from hardcoded `DMA_FROM_DEVICE` to `binding->direction` in the unmapping call
     - A new `direction` field is added to track the correct DMA direction (FROM_DEVICE for Rx, TO_DEVICE for Tx)
  2. **Security Impact**: Using the wrong DMA direction during unmapping can lead to:
     - **Data corruption**: DMA operations with incorrect direction hints can cause cache coherency issues, potentially exposing stale or sensitive data
     - **Information disclosure**: Improper DMA unmapping could leave sensitive data accessible in memory that should have been properly synchronized/flushed
     - **Memory safety violations**: Incorrect DMA direction can bypass important memory synchronization barriers
  3. **Exploitability**: This affects the TX path implementation in the network device memory (devmem) subsystem, which handles DMA buffers for network operations. An attacker could potentially:
     - Trigger the TX path with specially crafted network traffic
     - Exploit the incorrect unmapping to access memory contents that should be protected
     - Leverage cache coherency issues to read or modify data inappropriately
  The commit message explicitly states "Fixes: bd61848900bf" indicating this is fixing a security-relevant bug introduced in the TX path implementation. DMA direction bugs are a well-known class of security vulnerabilities in kernel code that handle device memory mappings.
5a40f8af2ba1 benet: fix BUG when creating VFs
- [sasha] ## CVE Assignment Recommendation:
  **YES**
  This commit should be assigned a CVE because:
  1. **It fixes a kernel crash vulnerability** - The bug causes a kernel BUG/Oops leading to system crash when creating SR-IOV VFs, which is a denial of service condition
  2. **Security boundary violation** - While it requires administrative privileges, in virtualized environments or systems with delegated network management, this could allow a privileged user in one security domain to crash the entire system
  3. **Real-world impact** - The crash occurs during legitimate SR-IOV operations that are commonly used in production virtualization environments
  4. **Clear exploit path** - The vulnerability is reliably triggered by creating VFs: `echo N > /sys/class/net/ethX/device/sriov_numvfs`
  5. **Similar to other CVE-assigned bugs** - "Sleeping while atomic" bugs that cause kernel crashes have historically been assigned CVEs when they can be triggered through normal operations
  The fix correctly addresses the issue by moving the `dma_free_coherent()` call outside the spinlock-protected critical section, preventing the atomic context violation that causes the crash.
ffd2dc4c6c49 net/sched: mqprio: fix stack out-of-bounds write in tc entry parsing
- [sasha] **YES**
  This commit should be assigned a CVE based on the following analysis:
  1. **Stack-based Buffer Overflow**: The bug causes a 4-byte out-of-bounds write to the stack-allocated `fp[]` array. The array is declared as `u32 fp[TC_QOPT_MAX_QUEUE]` (where TC_QOPT_MAX_QUEUE=16), giving it indices 0-15. However, the validation allowed values up to and including 16, leading to writing at `fp[16]` which is beyond the array bounds.
  2. **Security Impact**: 
     - This is a **stack-based buffer overflow** triggered via netlink attributes from userspace
     - At line 197: `fp[tc] = nla_get_u32(tb[TCA_MQPRIO_TC_ENTRY_FP])` - when `tc=16`, this writes 4 bytes past the end of the fp array
     - Stack overflows can potentially lead to code execution or denial of service
  3. **Attack Vector**: The vulnerability can be triggered by unprivileged users who can send netlink messages to configure traffic control settings, making it accessible from userspace.
  4. **Clear Security Boundary Violation**: The bug violates memory safety by writing beyond allocated stack memory, which is a fundamental security issue in kernel space.
  The fix correctly changes the validation from `TC_QOPT_MAX_QUEUE` to `TC_QOPT_MAX_QUEUE - 1`, preventing the out-of-bounds access.
fdd015de7679 NFS/localio: nfs_uuid_put() fix races with nfs_open/close_local_fh()
- [sasha] **YES**
  This commit fixes a critical race condition that could lead to use-after-free vulnerabilities. The key security-relevant changes:
  1. **New race condition fix in `nfs_uuid_add_file()`**: The commit adds a check for `nfs_uuid->net == NULL` (line 251-252) to prevent adding files after shutdown has begun. Without this check, new files could be added while `nfs_uuid_put()` is cleaning up, potentially leading to use-after-free when accessing those files.
  2. **Proper error handling in `nfs_open_local_fh()`**: When the race is detected (lines 294-297), the code now properly cleans up by calling `nfs_to_nfsd_file_put_local(pnf)` to release the cached file reference, preventing resource leaks and potential dangling references.
  3. **Synchronization variable fix**: Changes `wait_var_event_spinlock()` and `wake_up_var_locked()` to use `nfs_uuid` instead of `nfl` addresses (lines 180, 347). Using inconsistent addresses for synchronization could lead to missed wake-ups and deadlocks, potentially causing denial of service.
  The commit message explicitly states it "fixes races" between concurrent operations that could result in accessing freed memory structures. The referenced commit (21fb44034695) it fixes was itself addressing race conditions that could lead to use-after-free scenarios, and this commit addresses remaining gaps in that fix.
  These race conditions could potentially be exploited to cause kernel crashes, information leaks through use-after-free, or denial of service, making this a security-relevant fix warranting CVE assignment.
afb4108c9289 smb: server: make sure we call ib_dma_unmap_single() only if we called ib_dma_map_single already
- [sasha] YES
  This commit should be assigned a CVE because it fixes a memory management vulnerability that could lead to system instability or potential security issues.
  The vulnerability involves improper handling of DMA-mapped memory in the SMB server's RDMA transport layer. Specifically:
  1. **Double-free/Use-after-free potential**: The original code could call `ib_dma_unmap_single()` on memory that was either never mapped or already unmapped, which could lead to memory corruption or crashes.
  2. **Key code changes showing the fix**:
     - Added a check in `put_recvmsg()`: `if (likely(recvmsg->sge.length != 0))` before calling `ib_dma_unmap_single()`
     - Sets `recvmsg->sge.length = 0` after unmapping to prevent double unmapping
     - Initializes `recvmsg->sge.length = 0` in `smb_direct_create_pools()`
  3. **Security impact**: Improper DMA memory management in kernel space can lead to:
     - Kernel crashes/DoS attacks
     - Potential memory corruption that could be exploited
     - System instability affecting availability
  4. **Attack surface**: This affects the SMB server's RDMA transport, which handles network communications, making it potentially exploitable by remote attackers who can send malformed RDMA requests.
  The commit explicitly states it "Fixes" a bug introduced in the initial implementation (commit 0626e6641f6b), indicating this is addressing a real defect rather than a theoretical issue.
cfe76fdbb972 smb: server: let recv_done() consistently call put_recvmsg/smb_direct_disconnect_rdma_connection
- [sasha] YES
  This commit should be assigned a CVE because it fixes critical bugs in the RDMA transport error handling that could lead to security issues:
  1. **Use-after-free vulnerability**: The original code called `smb_direct_disconnect_rdma_connection()` before `put_recvmsg()` in error paths. This could cause a use-after-free condition since the disconnect might wake up callers who could then access the recvmsg structure before it was properly released.
  2. **Stale connection handling**: The code failed to call `smb_direct_disconnect_rdma_connection()` in several error paths (lines 542, 562, 572 in the new code), which could leave stale RDMA connections active. This could potentially be exploited to maintain unauthorized connections or cause resource exhaustion.
  3. **Missing bounds checks**: The added error handling for malformed packets (checking `wc->byte_len` against expected sizes) prevents processing of invalid data that could lead to memory corruption or information disclosure.
  The commit message explicitly states this "Fixes" a commit from the initial implementation ("cifsd: add server handler..."), indicating these are long-standing bugs in the SMB server's RDMA transport layer. The issues affect connection state management and memory handling in network-facing code, which are classic security-sensitive areas.
a6c015b7ac2d smb: server: let recv_done() avoid touching data_transfer after cleanup/move
- [sasha] YES
  This commit should be assigned a CVE because it fixes a **use-after-free vulnerability** in the SMB server's RDMA transport layer that could lead to memory corruption and potential security impacts.
  **Key security-relevant aspects:**
  1. **Use-After-Free Race Condition**: The commit message explicitly states that "the recvmsg/data_transfer pointer might get re-used by another thread" after calling `enqueue_reassembly()` and `wake_up_interruptible()` or `put_recvmsg()`. This is a classic use-after-free scenario.
  2. **Incorrect Operation Order (Before Fix)**: 
     - The original code would call `enqueue_reassembly()` and `wake_up_interruptible()` BEFORE updating credit counters and handling flags
     - This allowed another thread to potentially consume and free the memory while the current thread was still accessing `data_transfer` fields
  3. **Security Impact**: The code changes show that after enqueueing or putting the recvmsg buffer, the original code continued to access the `data_transfer` structure for:
     - Reading `credits_requested` 
     - Reading `credits_granted`
     - Reading `flags` field
     
     If another thread had already freed and reused this memory, these reads would access corrupted/attacker-controlled data.
  4. **Fix Pattern**: The fix reorders operations to ensure all accesses to `data_transfer` complete before the buffer is made available to other threads through `enqueue_reassembly()` or released via `put_recvmsg()`.
  This vulnerability could potentially be exploited by a malicious SMB client to cause memory corruption in the kernel, potentially leading to denial of service or possibly code execution, making it a legitimate security issue requiring a CVE.
24b6afc36db7 smb: client: remove separate empty_packet_queue
- [sasha] Looking at this commit, I need to analyze whether it fixes a security vulnerability that warrants a CVE.
  ## Analysis
  **What the commit does:**
  - Removes the separate `empty_packet_queue` and consolidates to a single `receive_queue`
  - Fixes a bug where `ib_dma_unmap_single()` was not being called for empty keepalive packets in `recv_done()`
  **Security implications:**
  The key issue is in the `recv_done()` function. In the original code:
  ```c
  if (data_length) {
      ...
      enqueue_reassembly(info, response, data_length);
  } else
      put_empty_packet(info, response);
  ```
  The `put_empty_packet()` function would add the response to the empty packet queue WITHOUT unmapping the DMA buffer. The DMA unmapping only happened in `put_receive_buffer()`.
  After the fix:
  ```c
  if (data_length) {
      ...
      enqueue_reassembly(info, response, data_length);
  } else
      put_receive_buffer(info, response);
  ```
  Now both paths properly call `put_receive_buffer()` which includes:
  ```c
  ib_dma_unmap_single(info->id->device, response->sge.addr,
      response->sge.length, DMA_FROM_DEVICE);
  ```
  **Security Impact:**
  The missing `ib_dma_unmap_single()` call is a **DMA mapping leak**. This could lead to:
  1. **Resource exhaustion** - DMA mappings are limited resources, continuous leaking could exhaust them
  2. **Memory exposure** - Unmapped DMA buffers could potentially remain accessible to the device
  3. **Denial of Service** - System could become unstable when DMA resources are exhausted
  This is particularly concerning for keepalive packets which are sent regularly, making the leak continuous over time.
  **Answer:**
  **YES**
  This commit fixes a DMA mapping leak where `ib_dma_unmap_single()` was not called for empty keepalive packets received through SMB Direct/RDMA. This resource leak could lead to denial of service through DMA resource exhaustion and potentially expose memory that should have been unmapped. The vulnerability affects all SMB Direct connections since the introduction of the feature in the referenced Fixes commit.
24eff17887cb smb: client: let recv_done() avoid touching data_transfer after cleanup/move
- [sasha] Looking at this commit, I need to analyze both the security implications and the actual code changes.
  ## Analysis
  **Security Impact Assessment:**
  The commit fixes a **use-after-free vulnerability** in the SMB Direct (RDMA) receive handler. The issue occurs when `recv_done()` accesses the `data_transfer` pointer after calling functions that could allow another thread to reuse that memory:
  1. **Race Condition**: After calling `enqueue_reassembly()` or `put_receive_buffer()`, the response/data_transfer pointer can be immediately reused by another thread
  2. **Use-After-Free**: The original code continued to access `data_transfer` fields (for credits and flags) after these calls, potentially accessing freed/reused memory
  **Code Changes Analysis:**
  The fix reorders operations to ensure all accesses to `data_transfer` occur **before** the buffer is released:
  ```c
  // BEFORE: Dangerous pattern
  enqueue_reassembly(info, response, data_length);  // Buffer can be reused after this
  atomic_dec(&info->receive_credits);               // Still accessing data_transfer
  info->receive_credit_target = le16_to_cpu(data_transfer->credits_requested); // UAF!
  // AFTER: Safe pattern  
  atomic_dec(&info->receive_credits);               // Access data_transfer first
  info->receive_credit_target = le16_to_cpu(data_transfer->credits_requested);
  // ... all other accesses ...
  enqueue_reassembly(info, response, data_length);  // Release buffer last
  ```
  **Exploitability:**
  This vulnerability could potentially lead to:
  - Memory corruption if the freed memory is reallocated
  - Information disclosure if sensitive data is placed in the reused memory
  - Possible code execution in worst-case scenarios with careful heap manipulation
  The vulnerability affects the SMB Direct (RDMA) protocol implementation, which is used in high-performance network file sharing scenarios.
  ## Conclusion
  **YES**
  This commit should be assigned a CVE because it fixes a clear use-after-free vulnerability in the SMB client's RDMA receive path. The vulnerability allows a race condition where one thread could access memory (`data_transfer` pointer) that has already been freed and potentially reallocated by another thread. This is a memory safety issue that could lead to memory corruption, information disclosure, or potentially code execution, particularly in multi-threaded environments using SMB Direct connections.
ae633388cae3 pptp: fix pptp_xmit() error path
- [sasha] **YES**
  This commit fixes a kernel NULL pointer dereference that causes a system crash (kernel panic). The vulnerability allows unprivileged users to trigger a denial of service by sending malformed PPP packets through the PPTP interface. The code change shows the fix splits error handling into `tx_drop` (before route allocation) and `tx_error` (after route allocation), preventing `ip_rt_put()` from being called on an uninitialized route pointer. The crash trace in the commit message confirms this causes a kernel Oops with page fault, representing a clear availability/DoS vulnerability.
03537826f77f smb: client: return an error if rdma_connect does not return within 5 seconds
- [sasha] Looking at this commit, I need to analyze both the security implications and the nature of the change.
  **Code Analysis:**
  The change modifies the RDMA connection establishment in the SMB Direct protocol implementation:
  1. **Before**: Used `wait_event_interruptible()` with no timeout - could wait indefinitely
  2. **After**: Uses `wait_event_interruptible_timeout()` with a 5-second timeout (`RDMA_RESOLVE_TIMEOUT`)
  ```c
  -	wait_event_interruptible(
  -		info->conn_wait, sc->status != SMBDIRECT_SOCKET_CONNECTING);
  +	wait_event_interruptible_timeout(
  +		info->conn_wait,
  +		sc->status != SMBDIRECT_SOCKET_CONNECTING,
  +		msecs_to_jiffies(RDMA_RESOLVE_TIMEOUT));
  ```
  **Security Implications:**
  This change fixes a **denial of service vulnerability** where:
  - A malicious or misbehaving RDMA server could cause the client to hang indefinitely during connection establishment
  - The client thread would be blocked forever waiting for the connection to complete
  - This could lead to resource exhaustion if multiple connections are attempted
  - System resources (threads, memory) would be tied up indefinitely
  The commit message states this "matches the timeout for tcp connections," indicating this brings RDMA connections in line with existing TCP connection behavior, which already had proper timeout handling.
  **CVE Determination:**
  **YES**
  This commit should be assigned a CVE because:
  1. It fixes a clear denial of service vulnerability where clients could hang indefinitely
  2. The vulnerability is exploitable by a malicious RDMA server or through network manipulation
  3. It affects the availability of the client system by causing thread hangs
  4. The fix implements a security boundary (timeout) that was missing in the original implementation
  5. Similar timeout-related fixes in network protocols are commonly assigned CVEs as they prevent resource exhaustion attacks
  The vulnerability allows remote attackers to cause a denial of service condition, which is a valid CVE-worthy security issue.
e5a73150776f nfsd: avoid ref leak in nfsd_open_local_fh()
- [sasha] ## CVE Assignment Recommendation
  **YES**
  This commit should be assigned a CVE because:
  1. **Clear security impact**: Resource leak causing denial of service (server hang during shutdown)
  2. **Exploitable condition**: Race condition that can be triggered by concurrent operations
  3. **Availability compromise**: Prevents normal system administration (shutdown/restart)
  4. **Production impact**: Affects NFS server availability in production environments
  5. **Stable backport**: Marked for stable kernel branches indicating widespread impact
  The vulnerability allows attackers to cause a denial of service by triggering a reference leak through racing nfsd_open_local_fh() calls, ultimately preventing the NFS server from shutting down properly. This is a classic resource exhaustion vulnerability with clear security implications.
bee47cb026e7 sunrpc: fix handling of server side tls alerts
- [sasha] **YES**
  This commit should be assigned a CVE because:
  1. **Explicitly identified security exploit**: The commit message directly states "Scott Mayhew discovered a security exploit in NFS over TLS"
  2. **Memory access vulnerability**: The bug involves incorrect assumptions about reading data from msg iterator's kvec in `tls_alert_recv()`, which could lead to improper memory access and potential exploitation
  3. **Attack vector**: The vulnerability affects NFS over TLS server-side handling, providing a network-accessible attack surface where malicious clients could send specially crafted TLS alerts
  4. **Stable backport**: The commit includes "Cc: stable@vger.kernel.org" indicating this affects multiple kernel versions and needs security backporting
  5. **Code fix pattern**: The changes show fixing unsafe iterator usage (`iov_iter_revert()` addition) and proper separation of control message handling, classic indicators of fixing exploitable memory handling issues
f74b9f4ba63f perf/core: Handle buffer mapping fail correctly in perf_mmap()
- [sasha] Now let me analyze the issue. Based on my review of the commit message and code changes:
  **YES**, this commit should be assigned a CVE.
  ## Analysis:
  ### Security Vulnerability Details:
  1. **Resource Leak Vulnerability**: The commit fixes a bug where if `map_range()` fails after successful buffer allocation/attachment, the cleanup is incomplete, leading to:
     - **Reference count leaks** - The mmap_count and other reference counts remain elevated
     - **Memory accounting corruption** - user->locked_vm and vm_mm->pinned_vm accounting becomes corrupted
     - **Unbalanced event callbacks** - event_mapped() is called but event_unmapped() is never called
  2. **Attack Impact**:
     - **Memory exhaustion/DoS**: The reference count leaks prevent proper cleanup of perf buffers. An attacker could repeatedly trigger this failure path to leak kernel memory resources.
     - **VM accounting bypass**: The corrupted user->locked_vm accounting could allow bypassing memory limits (RLIMIT_MEMLOCK), potentially allowing unprivileged users to lock more memory than permitted.
     - **System instability**: The unbalanced event_mapped/unmapped callbacks could lead to use-after-free conditions or other memory safety issues depending on the PMU driver implementation.
  3. **Triggering Condition**: 
     The vulnerability is triggered when `map_range()` fails (e.g., due to memory pressure or other conditions) after successful buffer setup. The fix ensures `perf_mmap_close()` is called to properly clean up in this error path.
  4. **Code Evidence**:
     - Lines 7137-7141: Shows reference counting and VM accounting being done
     - Original code: `event_mapped()` was called before `map_range()` but no cleanup on failure
     - Fix: Calls `perf_mmap_close(vma)` on `map_range()` failure to properly undo all side effects
  This is a clear security vulnerability with potential for resource exhaustion attacks and memory accounting bypass, warranting CVE assignment.
07091aade394 perf/core: Exit early on perf_mmap() fail
- [sasha] **YES**
  This commit fixes a reference counting vulnerability that causes resource leaks. The issue occurs when `perf_mmap()` fails to allocate a buffer but still calls the `event_mapped()` callback, which on X86 increases the `perf_rdpmc_allowed` reference counter. Since `perf_mmap_close()` is never called on failure, this reference is never decremented, creating a persistent leak.
  Key security implications:
  1. **Reference count leak**: The bug causes unbounded reference counter increases on failed mmap operations
  2. **Resource exhaustion potential**: Repeated failed mmap attempts could accumulate leaked references
  3. **Stable backport requested**: The commit explicitly includes `Cc: stable@vger.kernel.org`, indicating the maintainers consider this a significant issue worth backporting
  The fix adds an early return (`if (ret) return ret;`) after mutex unlocking but before calling the `event_mapped()` callback, preventing the reference leak when allocation fails. This is a clear security-relevant bug fix addressing improper resource management that could be exploited for denial of service.
b024d7b56c77 perf/core: Prevent VMA split of buffer mappings
- [sasha] **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Clear Security Vulnerability**: The commit fixes a reference counting vulnerability that can lead to memory corruption issues (reference count leaks, potential use-after-free).
  2. **External Security Report**: The presence of "ZDI-CAN-27504" indicates this was reported through Zero Day Initiative's vulnerability disclosure program, which typically handles CVE-worthy vulnerabilities.
  3. **Long-standing Issue**: The bug has existed since 2015 (commit 45bfb2e50471), affecting multiple kernel versions over many years.
  4. **Exploitable Attack Vector**: Local attackers can trigger the vulnerability through standard system calls (mmap/munmap/mremap) on perf event file descriptors.
  5. **Security Impact**: Reference counting bugs in kernel space are serious security issues that can lead to memory corruption, denial of service, or potentially privilege escalation.
  6. **Stable Backport**: The Cc to stable@vger.kernel.org indicates this is considered a serious issue requiring fixes in stable kernels.
  The code change adds the `perf_mmap_may_split()` callback that unconditionally prevents VMA splits for perf mappings, effectively closing the vulnerability by preventing the problematic split operations that cause reference count leaks.
01d3c8417b9c net/packet: fix a race in packet_set_ring() and packet_notifier()
- [sasha] **YES**, this commit should be assigned a CVE.
  **Explanation:**
  This commit fixes a **race condition** vulnerability in the Linux kernel's packet socket implementation. The critical security aspects are:
  1. **Race Condition Between Critical Sections**: The vulnerability occurs when `packet_set_ring()` temporarily releases `po->bind_lock` (line 4580), allowing another thread to run `packet_notifier()` and process a `NETDEV_UP` event while the socket is in an inconsistent state.
  2. **Security Impact**: The code change shows that previously, `po->num` was only set to 0 when the socket was running (inside the `if (was_running)` block). The fix moves `WRITE_ONCE(po->num, 0)` outside the conditional (line 4576), ensuring the socket is always temporarily unhooked during the critical operation, preventing the race condition.
  3. **Similar CVE Precedent**: The commit message explicitly references a similar vulnerability (commit 15fe076edea7) that had the same race condition pattern in `packet_bind()`, suggesting this is a known vulnerability class in the packet socket subsystem.
  4. **Kernel Networking Component**: This affects the AF_PACKET socket implementation, which is a privileged networking interface that could potentially be exploited for privilege escalation or denial of service if the race condition is triggered.
  5. **Stable Tag**: The commit includes `Cc: stable@vger.kernel.org` and a Fixes tag going back to Linux 2.6.12, indicating this is a long-standing security issue affecting many kernel versions.
  The race condition could potentially lead to use-after-free conditions or other memory corruption issues when the socket state becomes inconsistent between the two racing threads.
aba0c94f61ec vsock: Do not allow binding to VMADDR_PORT_ANY
- [sasha] YES
  This commit should be assigned a CVE based on the following analysis:
  1. **Security Vulnerability Type**: The commit explicitly fixes a **use-after-free vulnerability**, which is a memory safety issue that can lead to crashes or potentially arbitrary code execution.
  2. **Root Cause**: The vulnerability occurs when:
     - A vsock socket autobinds to `VMADDR_PORT_ANY` (port value 0xFFFFFFFF/-1)
     - A connection is made to this bound socket
     - The accepted socket also has port `VMADDR_PORT_ANY` but is not on the unbound sockets list
     - Binding this accepted socket causes an extra refcount decrement, leading to use-after-free
  3. **Code Fix**: The patch adds a critical security check in `__vsock_bind_connectible()`:
     ```c
     if (port == VMADDR_PORT_ANY ||
         port <= LAST_RESERVED_PORT)
     ```
     This prevents binding to `VMADDR_PORT_ANY`, which was the root cause of the reference counting issue.
  4. **Impact**: Use-after-free vulnerabilities are serious security issues that can lead to:
     - System crashes (DoS)
     - Memory corruption
     - Potential code execution in some scenarios
  5. **Historical Context**: The commit message references that this is similar to a previous CVE-worthy fix in commit fcdd2242c023 ("vsock: Keep the binding until socket destruction"), indicating this is part of a pattern of security-relevant reference counting issues in the vsock subsystem.
  The combination of fixing a use-after-free vulnerability with clear security implications warrants CVE assignment.
9b493ab6f351 ksmbd: fix null pointer dereference error in generate_encryptionkey
- [sasha] **YES**
  This commit should be assigned a CVE because:
  1. It fixes a **remotely triggerable null pointer dereference** in the ksmbd (kernel SMB server) authentication code
  2. The vulnerability was **reported through ZDI** (ZDI-CAN-27654), a well-known vulnerability disclosure program
  3. The issue occurs in **security-critical authentication code** where a malicious client can send specific krb5 session setup sequences to trigger the null dereference
  4. The fix prevents the null pointer dereference by checking if the session is already valid (reauthentication case) before attempting to generate encryption keys with potentially NULL Preauth_HashValue
44a3059c4c8c ksmbd: fix Preauh_HashValue race condition
- [sasha] **YES**
  This commit should be assigned a CVE based on the following analysis:
  1. **Race Condition Fix**: The commit explicitly states it fixes a "Preauh_HashValue race condition" that occurs when clients send multiple session setup requests concurrently. Race conditions in authentication/session handling are security-critical vulnerabilities.
  2. **ZDI Disclosure**: The commit is reported by ZDI (Zero Day Initiative) with tracking number ZDI-CAN-27661, indicating this was discovered through security research and likely has exploitation potential.
  3. **Authentication Component**: The affected code is in the SMB2 session setup authentication path (ksmbd is the kernel SMB server). The removed lines were freeing `sess->Preauth_HashValue` during active authentication, which could lead to use-after-free conditions when multiple threads access the same session structure.
  4. **Memory Safety Issue**: The race condition involves premature freeing of memory (`kfree(sess->Preauth_HashValue)`) that could still be accessed by concurrent session setup requests, potentially leading to:
     - Use-after-free vulnerabilities
     - Memory corruption
     - Possible code execution or privilege escalation
  5. **Stable Backport**: The commit includes "Cc: stable@vger.kernel.org", indicating this fix needs to be backported to stable kernels due to its security importance.
  The code changes show removal of two `kfree(sess->Preauth_HashValue)` calls that were creating the race condition, allowing the memory to be properly freed only at connection termination instead of during active session setup.
e6bb91939740 ksmbd: limit repeated connections from clients with the same IP
- [sasha] **YES**
  This commit fixes a denial of service vulnerability where an attacker could exhaust the maximum number of SMB server connections by repeatedly connecting from the same IP address, preventing legitimate users from accessing the service. The code adds a check in `fs/smb/server/transport_tcp.c:258-265` that rejects new connections if the IP already has an active connection, directly mitigating this DoS attack vector. The presence of `Cc: stable@vger.kernel.org` further confirms this is a security-relevant fix requiring backporting.
8e7d178d06e8 smb: server: Fix extension string in ksmbd_extract_shortname()
- [sasha] 
8cbe56497424 ALSA: intel_hdmi: Fix off-by-one error in __hdmi_lpe_audio_probe()
- [sasha] YES
  This commit should be assigned a CVE because it fixes an off-by-one error that results in improper string copying, which is a security-relevant bug. 
  Specifically, the code change shows:
  ```c
  - strscpy(pcm->name, card->shortname, strlen(card->shortname));
  + strscpy(pcm->name, card->shortname, sizeof(pcm->name));
  ```
  The bug incorrectly uses `strlen(card->shortname)` as the size parameter to `strscpy()`, which should be the destination buffer size. This causes one character less to be copied than intended (as noted in the commit message: "This results in one character less being copied"). 
  While this appears to be a minor truncation issue rather than a buffer overflow (since strscpy is safe against overflows), it still represents:
  1. A data integrity issue that could lead to incorrect device identification
  2. A boundary condition error in string handling
  3. The commit explicitly marks it with "Cc: stable@vger.kernel.org", indicating it's considered important enough for stable backports
  Similar string handling bugs, even those that don't cause memory corruption, have historically been assigned CVEs when they affect data integrity or proper system operation. The bug could potentially cause issues with audio device identification or functionality depending on how the truncated name is used elsewhere in the system.
7b306dfa326f x86/sev: Evict cache lines during SNP memory validation
- [sasha] **YES**
  This commit should be assigned a CVE as it addresses a critical **cache coherency vulnerability** in AMD SEV-SNP (Secure Encrypted Virtualization - Secure Nested Paging) that could potentially compromise memory isolation between guests and host.
  Key evidence from the code:
  1. **Explicit vulnerability mention in commit message**: "An SNP cache coherency vulnerability requires a cache line eviction mitigation when validating memory after a page state change to private"
  2. **Security mitigation implementation**: The code adds `sev_evict_cache()` function that touches first and last bytes of 4K pages to force cache line eviction:
     ```c
     val = bytes[page_idx * PAGE_SIZE];
     val = bytes[page_idx * PAGE_SIZE + PAGE_SIZE - 1];
     ```
  3. **Hardware vulnerability indicator**: New CPUID bit `X86_FEATURE_COHERENCY_SFW_NO` (bit 31 of Fn8000001F_EBX) indicates whether the software mitigation is needed, suggesting this is a hardware-level vulnerability
  4. **Critical security context**: The vulnerability affects memory validation during page state transitions from shared to private in SEV-SNP environments, which is fundamental to the security isolation guarantees
  5. **Conditional mitigation**: The code only applies the mitigation when making memory private AND when the hardware is vulnerable (!COHERENCY_SFW_NO), indicating this addresses a real security issue in specific hardware configurations
  This type of cache coherency vulnerability in confidential computing environments could potentially allow unauthorized access to private memory or enable side-channel attacks, making it a legitimate security vulnerability worthy of CVE assignment.
54d5cd4719c5 platform/x86/intel/pmt: fix a crashlog NULL pointer access
- [sasha] **YES**
  This commit fixes a NULL pointer dereference vulnerability that causes a kernel crash. The key evidence:
  1. **NULL pointer dereference causing crash**: The commit message shows a BUG with "kernel NULL pointer dereference, address: 0000000000000000" occurring in `intel_pmt_read+0x3b/0x70`.
  2. **Root cause**: The code was accessing `entry->ep->pcidev` (line 102 in the diff's old version) where `entry->ep` could be NULL for crashlog usage, as stated: "The current use of the endpoint value is only valid for telemetry endpoint usage."
  3. **Security impact**: This is a locally exploitable denial-of-service vulnerability where reading from the binary sysfs interface (`/sys/class/intel_pmt/...`) would trigger a kernel panic, affecting system availability.
  4. **Fix**: The patch adds a `pcidev` pointer directly to `struct intel_pmt_entry` and changes the problematic line from `entry->ep->pcidev` to `entry->pcidev`, eliminating the NULL dereference.
  5. **Exploitability**: The vulnerability is triggered through normal sysfs read operations (`ksys_read` in the call trace), making it easily exploitable by any local user with access to the sysfs files.
  This meets the criteria for a CVE as it's a security vulnerability that allows local users to crash the kernel through NULL pointer dereference, impacting system availability.
c6e35dff58d3 KVM: arm64: Check for SYSREGS_ON_CPU before accessing the CPU state
- [sasha] Looking at this commit, I need to analyze both the commit message and code changes for security implications.
  **Commit Message Analysis:**
  - States that code making registers visible to guests is "completely broken on VHE"
  - Mentions failure to check if system registers are loaded on CPU
  - Uses language like "as bad as it gets" indicating severity
  - Tagged with `Cc: stable@vger.kernel.org` indicating it's a fix for stable kernels
  **Code Changes Analysis:**
  The changes add critical safety checks before accessing CPU state:
  1. **In `__vcpu_read_sys_reg()`** (arch/arm64/kvm/hyp/exception.c:29):
     - Added check: `vcpu_get_flag(vcpu, SYSREGS_ON_CPU) &&` before calling `__vcpu_read_sys_reg_from_cpu()`
     
  2. **In `__vcpu_write_sys_reg()`** (arch/arm64/kvm/hyp/exception.c:38):
     - Added check: `!vcpu_get_flag(vcpu, SYSREGS_ON_CPU) ||` before system register operations
  3. **Documentation updates** emphasizing that "SYSREGS_ON_CPU *MUST* be checked before using this helper"
  **Security Implications:**
  - Without these checks, the code could access system registers when they're not loaded on the CPU
  - This could lead to:
    - Reading stale/incorrect register values
    - Writing to wrong memory locations
    - Potential guest escape or host compromise in VHE (Virtualization Host Extensions) environments
    - Information disclosure between VMs or between host and guest
  The fix prevents accessing CPU state when registers aren't properly loaded, which is a critical safety violation that could compromise VM isolation.
  **Answer: YES**
  This commit fixes a critical security vulnerability in KVM's ARM64 virtualization where system registers could be accessed incorrectly on VHE systems without verifying they're loaded on the CPU. This could lead to VM escape, information disclosure, or host compromise. The severity is emphasized by the commit message stating it's "as bad as it gets" and the stable kernel CC, indicating this is a serious issue affecting production systems.
303084ad1276 KVM: arm64: Filter out HCR_EL2 bits when running in hypervisor context
- [sasha] **YES**
  This commit fixes a security vulnerability where a nested hypervisor (L1) could inadvertently affect its own execution context when trying to inject virtual exceptions to its guest (L2). The specific security issues are:
  1. **Privilege boundary violation**: The commit message explicitly states "L1 trying to inject a virtual SError for L2, and getting a taste of its own medicine" - this means L1's attempt to inject an error to L2 was incorrectly affecting L1 itself, breaking the isolation between nested virtualization levels.
  2. **Improper HCR_EL2 bit merging**: The code change shows that previously, when running in hypervisor context, the system was merging guest-controlled HCR_EL2 bits directly (`__vcpu_sys_reg(vcpu, HCR_EL2)`). The fix now uses `kvm_vcpu_apply_reg_masks(vcpu, HCR_EL2, 0)` instead, which properly sanitizes these bits.
  3. **Context confusion**: The vulnerability allowed guest-controlled register bits to affect the hypervisor's own execution context. As stated in the new comment: "Nothing in HCR_EL2 should impact running in hypervisor context" - but the previous code was allowing this to happen.
  4. **Impact on nested virtualization security**: This affects KVM's nested virtualization feature (FEAT_NV2), where improper handling of HCR_EL2 bits could lead to unexpected behavior and potential security issues in the hypervisor itself.
  The fix properly filters out guest-controlled bits when running in hypervisor context, ensuring that only sanitized RES1 bits are used, preventing the guest from affecting the hypervisor's execution environment.
323a80a1a5ac usb: gadget: uvc: Initialize frame-based format color matching descriptor
- [sasha] YES
  This commit should be assigned a CVE because it fixes a critical security vulnerability - a NULL pointer dereference that leads to a kernel crash. Here's the specific evidence:
  1. **Security Impact**: The commit fixes a NULL pointer dereference that causes a kernel crash (Denial of Service), as shown in the crash log with "Unable to handle kernel NULL pointer dereference at virtual address 000000000000008c"
  2. **Root Cause**: The vulnerability occurs in `uvcg_framebased_make()` function where the code fails to properly initialize the `color_matching` descriptor for frame-based formats. Without this initialization, when userspace configuration via configfs doesn't explicitly define a color matching descriptor, the code attempts to dereference a NULL pointer.
  3. **Code Fix**: The patch adds critical NULL checking and initialization:
  ```c
  +	struct uvcg_color_matching *color_match;
  +	struct config_item *streaming;
  ...
  +	streaming = group->cg_item.ci_parent;
  +	color_match = uvcg_format_get_default_color_match(streaming);
  +	if (!color_match)
  +		return ERR_PTR(-EINVAL);
  ...
  +	h->fmt.color_matching = color_match;
  +	color_match->refcnt++;
  ```
  4. **Attack Vector**: This vulnerability can be triggered through userspace via configfs when configuring USB gadget UVC (USB Video Class) devices, making it accessible to local attackers with appropriate permissions.
  5. **Affected Component**: The vulnerability is in the USB gadget subsystem, specifically in the UVC (webcam) gadget driver, which is a kernel component that could affect system stability.
  The combination of kernel crash capability, userspace triggerable condition, and the fact it's fixing a clear programming error (missing initialization) that leads to NULL pointer dereference makes this a legitimate security vulnerability worthy of CVE assignment.
1bb3363da862 HID: apple: validate feature-report field count to prevent NULL pointer dereference
- [sasha] YES
  This commit should be assigned a CVE based on the following security vulnerability indicators:
  1. **NULL Pointer Dereference Vulnerability**: The commit explicitly fixes a NULL pointer dereference that can be triggered by a malicious HID device. The commit message states: "A malicious HID device with quirk APPLE_MAGIC_BACKLIGHT can trigger a NULL pointer dereference whilst the power feature-report is toggled".
  2. **Kernel Crash/DoS Impact**: The vulnerability causes a kernel crash as shown by the KASAN splat in the commit message, resulting in a denial of service condition.
  3. **Attack Vector**: The vulnerability can be exploited by a malicious USB HID device that provides a specially crafted descriptor with fewer fields than expected.
  4. **Security Fix Pattern**: The code change adds validation checks to prevent accessing array elements that may be NULL:
  ```c
  -	if (!backlight->brightness || !backlight->power)
  +	if (!backlight->brightness || backlight->brightness->maxfield < 2 ||
  +	    !backlight->power || backlight->power->maxfield < 2)
  ```
  5. **Stable Backport**: The commit includes "Cc: stable@vger.kernel.org", indicating this is considered a security-relevant fix that needs to be backported to stable kernels.
  6. **Fixes Tag**: References commit 394ba612f941 which introduced the vulnerable code path when adding support for magic keyboard backlight.
  This is a classic example of insufficient input validation leading to a NULL pointer dereference in kernel space, which is a security vulnerability warranting CVE assignment.
a6b87bfc2ab5 HID: core: Harden s32ton() against conversion to 0 bits
- [sasha] YES
  This commit should be assigned a CVE based on the following analysis:
  1. **Security-relevant crash fix**: The commit explicitly fixes a "shift-out-of-bounds exception" that causes the HID core to crash. This is a denial-of-service vulnerability where malformed HID reports can crash the kernel.
  2. **Input validation vulnerability**: The code change in `s32ton()` adds bounds checking:
  ```c
  +	if (!value || !n)
  +		return 0;
  +
  +	a = value >> (n - 1);
  ```
  Previously, when `n` was 0, the code would execute `value >> (0 - 1)` which results in `value >> -1`, causing undefined behavior and a shift-out-of-bounds exception.
  3. **Exploitable by malicious devices**: The commit message states "there are buggy devices and some might have a report field with size set to zero", indicating this can be triggered by external HID devices (USB/Bluetooth).
  4. **Kernel crash impact**: A shift-out-of-bounds exception in kernel space can lead to system crashes, making this a denial-of-service vulnerability.
  5. **Stable backport requested**: The commit includes `Cc: stable@vger.kernel.org`, indicating this is considered a security-relevant fix that needs to be backported to stable kernels.
  6. **Long-standing issue**: The Fixes tag references commit `dde5845a529f` from 2006, showing this vulnerability has existed for many years in the kernel.
  The vulnerability allows malicious or malformed HID devices to crash the system by sending reports with 0-bit field sizes, which is a clear security issue warranting CVE assignment.
151c0aa896c4 usb: gadget : fix use-after-free in composite_dev_cleanup()
- [sasha] Looking at this commit, I need to analyze both the security implications and the code changes.
  **Analysis:**
  1. **The vulnerability described:** This is a use-after-free vulnerability in the USB gadget subsystem. The commit message clearly describes a scenario where:
     - `kmalloc()` fails in `composite_os_desc_req_prepare()`
     - The pointer `cdev->os_desc_req` is freed but not set to NULL
     - Later, `composite_dev_cleanup()` checks if `cdev->os_desc_req` is NULL and attempts to use it if not, causing use-after-free
  2. **Security impact:** Use-after-free vulnerabilities are serious security issues that can potentially lead to:
     - System crashes/denial of service
     - Information disclosure 
     - Potentially arbitrary code execution depending on how the freed memory is reused
  3. **The code change:** The fix adds lines to set `cdev->os_desc_req = NULL` after freeing it on the error path, preventing the use-after-free condition.
  4. **KASAN detection:** The commit includes a KASAN (Kernel Address Sanitizer) stack trace showing the use-after-free was detected in real conditions.
  5. **Component affected:** This is in the USB gadget subsystem which handles USB device-mode functionality, a core kernel component that could be exposed to malicious USB hosts.
  **Answer:** YES
  This commit should be assigned a CVE because it fixes a legitimate use-after-free vulnerability in the kernel's USB gadget subsystem. Use-after-free vulnerabilities are well-established security issues that can have serious consequences including potential privilege escalation or code execution. The bug is triggered by a memory allocation failure which could potentially be induced by an attacker through resource exhaustion. The commit clearly identifies this as a security fix for a memory safety issue that has been present since commit 37a3a533429e (from 2014), affecting a significant timespan of kernel versions.
9bbffee67ffd mm: fix a UAF when vma->mm is freed after vma->vm_refcnt got dropped
- [sasha] **YES**
  This commit should be assigned a CVE because it fixes a critical Use-After-Free (UAF) vulnerability in the Linux kernel's memory management subsystem.
  The vulnerability is a race condition in `lock_vma_under_rcu()` that can lead to a UAF when:
  1. **The UAF occurs in `vma_refcount_put()`** - The function uses `vma->vm_mm` after dropping the refcount (line 146 in the original code: `rcuwait_wake_up(&mm->vma_writer_wait)`), but if the VMA was recycled and attached to a different mm, that mm could be freed between dropping the refcount and calling `rcuwait_wake_up()`.
  2. **The fix moves the vm_mm verification** from `lock_vma_under_rcu()` into `vma_start_read()` (lines 198-214 in the patch) and importantly **grabs a reference to the other_mm** via `mmgrab(other_mm)` before calling `vma_refcount_put(vma)`. This ensures the mm structure remains valid during the `rcuwait_wake_up()` call inside `vma_refcount_put()`.
  3. **Security Impact**: This is a memory corruption vulnerability that could potentially be exploited for:
     - Privilege escalation
     - Information disclosure
     - System crashes/DoS
  The commit message explicitly states this fixes a UAF vulnerability with a working reproducer created by Jann Horn, and includes a `Fixes:` tag and `Cc: stable` indicating it's a security-relevant fix that needs backporting.
