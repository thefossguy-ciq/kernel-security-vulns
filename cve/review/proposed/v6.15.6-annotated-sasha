8e786a85c0a3c x86/process: Move the buffer clearing before MONITOR
- [sasha] Based on my analysis, here's my assessment:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Performance optimization, not security fix**: The commit moves the VERW instruction (used for MDS mitigation) to execute before the MONITOR instruction rather than after it. This is done because VERW can "disarm" MONITOR, preventing the CPU from entering the C1 idle state properly.
  2. **No security vulnerability being fixed**: The commit message clearly states this is about fixing a functional/performance issue where "VERW doesn't disarm it and the machine never enters C1". This is a power management efficiency problem, not a security vulnerability.
  3. **MDS mitigation remains intact**: The security mitigation (VERW clearing CPU buffers) is still being performed - it's just being moved to a different location in the code sequence to avoid interfering with MONITOR/MWAIT idle functionality.
  4. **Code changes confirm this**: Looking at the changes:
     - In `mwait_idle_with_hints()`: `x86_idle_clear_cpu_buffers()` is moved before the MONITOR instruction
     - In `__mwait()` and `__sti_mwait()`: The buffer clearing calls are removed since they're now done earlier
     - The security mitigation is preserved, just reordered for better interaction with power management
  5. **Similar to non-CVE commits**: This is similar to the analyzed commits that optimize or restructure existing mitigations without fixing actual security vulnerabilities.
  The commit is addressing a functional issue where the MDS mitigation (VERW) was interfering with proper CPU idle state transitions, not fixing a security vulnerability.
2329f250e04d3 x86/microcode/AMD: Add TSA microcode SHAs
- [sasha] Based on my analysis of this commit, here is my determination:
  **NO**
  This commit should NOT be assigned a CVE. Here's my analysis:
  1. **Nature of the change**: The commit is adding new SHA256 checksums for AMD microcode patches (specifically TSA microcode). These are hash values being added to an allowlist of verified microcode patches.
  2. **Not fixing a vulnerability**: This commit is not fixing any security vulnerability. It's expanding the list of microcode patches that can be verified through SHA256 checksums. The verification mechanism was already in place (introduced in commit 50cef76d5cb0).
  3. **Preventive security measure**: The SHA256 verification is a security enhancement that ensures only authentic microcode patches are loaded. Adding more checksums to the allowlist enables verification for additional microcode versions but doesn't fix any existing security issue.
  4. **Similar to commit 1**: This is very similar to the first example commit "x86/microcode/AMD: Add some forgotten models to the SHA check" which was marked as "CVE Status: NO". Both commits are expanding the coverage of the SHA verification system by adding more entries.
  5. **No exploitable condition fixed**: The commit doesn't address any condition that could be exploited by an attacker. It's simply allowing more legitimate microcode patches to be verified.
  The commit is part of ongoing maintenance to ensure microcode integrity verification covers all AMD processor microcode patches, which is a security best practice but not a vulnerability fix.
31272abd5974b KVM: SVM: Advertise TSA CPUID bits to guests
- [sasha] **NO**
  This commit should not be assigned a CVE. Here's my analysis:
  1. **Not a vulnerability fix**: This commit is advertising CPUID feature bits (TSA_SQ_NO and TSA_L1_NO) to KVM guests, which indicate that the CPU is **not vulnerable** to TSA (Transient Scheduler Attacks). The "_NO" suffix indicates these are immunity bits, not vulnerability indicators.
  2. **Feature advertisement only**: The code changes in `kvm_cpu_cap_init()` and `cpuid_entry_override()` are purely about exposing existing CPU capabilities to virtual machines through CPUID. This allows guests to know whether they're running on hardware that's immune to TSA vulnerabilities.
  3. **No security boundary changes**: The commit doesn't fix any security vulnerability, change access controls, or modify any security-sensitive behavior. It's simply passing through hardware capability information from the host CPU to guest VMs.
  4. **Related to mitigation infrastructure**: Looking at the related TSA commits in the kernel tree (d8010d4ba43e), TSA is a known vulnerability that already has its own mitigation infrastructure. This KVM commit is just ensuring guests can properly detect whether they need TSA mitigations based on the underlying hardware.
  5. **Similar to other non-CVE commits**: This follows the same pattern as the similar commits shown (commits 1-5), which advertise various CPUID feature bits to guests without fixing vulnerabilities themselves.
  The commit is part of the virtualization stack's responsibility to accurately represent hardware capabilities to guests, allowing them to make appropriate security decisions, but it doesn't fix any vulnerability itself.
49c140d5af127 KVM: x86: Sort CPUID_8000_0021_EAX leaf bits properly
- [sasha] **NO**
  This commit does not warrant a CVE. The change is purely cosmetic - it reorders the CPUID feature bits in the KVM code to match their proper bit positions according to the hardware specification. Specifically:
  1. **Nature of change**: The commit moves `F(WRMSR_XX_BASE_NS)` from its incorrect position to bit 1 position where it belongs according to the x86 architecture (as confirmed by the cpufeatures.h definition showing it's bit 1: `(20*32+ 1)`).
  2. **No security impact**: This is a code organization change that doesn't affect functionality. The bits are still being set in the same way, just declared in the correct order in the source code.
  3. **Comment additions**: The commit also adds placeholder comments for other bits that aren't implemented yet (`/* UpperAddressIgnore */`, `/* GpOnUserCpuid */`, `/* EPSF */`).
  4. **No vulnerability fixed**: There's no security vulnerability being addressed - the previous code worked correctly despite the wrong ordering in the source declaration.
  This is similar to the other "NO CVE" examples shown, which involve KVM CPUID handling improvements that don't fix security issues but rather improve code organization or add new feature support.
d8010d4ba43e9 x86/bugs: Add a Transient Scheduler Attacks mitigation
- [sasha] Let me analyze the code changes directly from the commit. Looking at the key parts:
  1. **Bug Definition**: The commit adds `X86_BUG_TSA` to the CPU bugs list
  2. **Vulnerability Detection**: It adds TSA vulnerability detection for AMD CPUs (family 0x19)
  3. **Mitigation**: It implements VERW-based mitigation similar to other transient execution attacks
  4. **Sysfs Interface**: It adds `/sys/devices/system/cpu/vulnerabilities/tsa`
  5. **Kernel Parameter**: It adds `tsa=` parameter to control mitigation
  The key security-relevant code changes show:
  - TSA is a hardware security vulnerability affecting AMD Zen3/Zen4 CPUs
  - It can lead to information leakage between processes/VMs
  - The mitigation uses VERW instruction to clear CPU buffers
  - This is similar to other transient execution vulnerabilities like MDS
  Looking at the commit message reference to "Technical guidance for mitigating transient scheduler attacks", this appears to be a real hardware vulnerability that AMD has disclosed.
  **CVE Decision: YES**
  This commit should be assigned a CVE because:
  1. It fixes a hardware security vulnerability (Transient Scheduler Attacks) that affects AMD CPUs
  2. The vulnerability can lead to information disclosure between different security contexts (user/kernel, VM/host)
  3. The commit adds X86_BUG_TSA enumeration, showing it's recognized as a security bug
  4. It implements mitigation using VERW instruction to clear CPU buffers, similar to other CVE-worthy transient execution vulnerabilities
  5. The vulnerability affects specific AMD CPU families (0x19 - Zen3/Zen4) and requires microcode updates
  6. It adds a new entry in `/sys/devices/system/cpu/vulnerabilities/tsa`, consistent with other CPU vulnerabilities that have CVEs
  7. The mitigation has different modes (user/kernel, VM, full) indicating different attack surfaces
  This is similar to other transient execution vulnerabilities like MDS, TAA, and RFDS that have received CVEs.
f9af88a3d384c x86/bugs: Rename MDS machinery to something more generic
- [sasha] Now let me analyze the specific commit changes more carefully. Based on my analysis:
  **NO** - This commit should NOT be assigned a CVE.
  Explanation:
  1. **No security vulnerability is being fixed**: This commit is purely a code refactoring/renaming operation. The commit message explicitly states "No functional changes."
  2. **Analysis of the code changes**:
     - The commit renames MDS-specific function and variable names to more generic names:
       - `mds_clear_cpu_buffers()` → `x86_clear_cpu_buffers()`
       - `mds_idle_clear_cpu_buffers()` → `x86_idle_clear_cpu_buffers()` 
       - `mds_idle_clear` → `cpu_buf_idle_clear`
       - `mds_verw_sel` → `x86_verw_sel`
     
  3. **The security mitigation remains unchanged**: The VERW instruction-based CPU buffer clearing mitigation for MDS (Microarchitectural Data Sampling) vulnerabilities remains functionally identical. The code is simply being renamed to be more generic because it will be reused for other x86 mitigations.
  4. **Documentation updates reflect renaming only**: The documentation changes show that the functionality remains the same, just with updated function names.
  5. **Similar commits analysis**: The historical commits shown (commits 1-5 with CVE Status: NO) are all related to improving or adjusting the MDS mitigation implementation, but none introduce or fix new vulnerabilities - they are performance optimizations or code reorganizations.
  This is a maintenance/cleanup commit that prepares the codebase for future code reuse by making the naming more generic. It does not address any security vulnerability.
5c5f0468d172d mm/vmalloc: fix data race in show_numa_info()
- [sasha] Now let me analyze this commit thoroughly:
  **NO**
  This commit fixes a data race issue in the `/proc/vmallocinfo` interface, but it does not warrant a CVE assignment for the following reasons:
  1. **Low Security Impact**: The data race occurs in diagnostic/informational code that displays vmalloc area statistics through `/proc/vmallocinfo`. This is a read-only interface with permissions 0400 (readable only by root).
  2. **Nature of the Race Condition**: The race is between concurrent reads to `m->private` when multiple processes read `/proc/vmallocinfo` simultaneously. The worst case scenario is that the counters array might contain inconsistent data, leading to incorrect NUMA node statistics being displayed - this is a data corruption issue in diagnostic output only.
  3. **No Privilege Escalation or System Compromise**: The race condition cannot be exploited to:
     - Gain elevated privileges
     - Cause memory corruption in kernel space
     - Leak sensitive kernel memory
     - Cause system crashes or denial of service
     - Bypass security boundaries
  4. **Limited Attack Surface**: The interface is only accessible to root (mode 0400), significantly limiting potential attackers.
  5. **Information Disclosure Risk is Minimal**: While the interface shows kernel virtual addresses (using %pK format specifier which respects kptr_restrict), the race condition itself doesn't introduce new information disclosure - it only affects the accuracy of NUMA statistics.
  The fix moves the allocation of the counters array from `proc_vmalloc_init()` (where it was stored in `m->private` and shared between concurrent readers) to `vmalloc_info_show()` (where each reader gets its own allocation), properly eliminating the race condition. This is a correctness fix rather than a security fix.
099cf1fbb8afc usb: typec: displayport: Fix potential deadlock
- [sasha] Based on my analysis of the commit and the code:
  **NO** - This commit should NOT be assigned a CVE.
  Here's my reasoning:
  1. **Nature of the Issue**: This is a deadlock bug that causes system hangs, not a security vulnerability. The deadlock occurs due to recursive mutex acquisition in a specific call path:
     - `cros_typec_altmode_work()` holds `cros_typec_altmode_data::mutex`
     - Calls `typec_altmode_vdm()` → `dp_altmode_vdm()`
     - Which calls `typec_altmode_exit()` → `cros_typec_altmode_exit()`
     - `cros_typec_altmode_exit()` tries to acquire the same mutex again
  2. **Impact**: The issue causes a deadlock/hang when a DisplayPort Status Update NAK is received, which is a reliability/availability issue, not a security vulnerability. There's no:
     - Memory corruption
     - Privilege escalation
     - Information disclosure
     - Unauthorized access
  3. **Trigger Conditions**: The deadlock only occurs in a specific scenario when ChromeOS typec altmode driver receives a DP Status Update NAK response, which requires:
     - ChromeOS platform with specific hardware
     - DisplayPort alternate mode in use
     - Specific NAK response from the device
  4. **Fix Analysis**: The fix simply defers the `typec_altmode_exit()` call by changing the state to `DP_STATE_EXIT` instead of calling it directly, avoiding the recursive lock acquisition. This is a typical deadlock avoidance pattern.
  5. **Comparison with Similar Commits**: Looking at the similar commits marked with "CVE Status: YES", they involve more complex race conditions and deadlocks that could potentially be exploited or have broader system impact. This commit is a straightforward deadlock fix with limited scope.
  The commit is a valid bug fix for a deadlock issue, but it does not meet the criteria for a CVE assignment as it's not a security vulnerability.
4f30f946f27b7 platform/x86: think-lmi: Fix sysfs group cleanup
- [sasha] **NO**
  This commit should not be assigned a CVE. The changes fix incorrect error handling in `tlmi_sysfs_init()` where `sysfs_remove_group()` was being called on sysfs groups that might not have been created yet. While this is a bug that could cause issues in error paths, it does not represent a security vulnerability.
  The fix moves sysfs group management to the kobject core using `default_groups`, which is the proper way to handle attribute groups. The removed `sysfs_remove_group()` calls in error paths were incorrect but would typically just fail silently without causing exploitable conditions like memory corruption, privilege escalation, or information disclosure.
  This is similar to Similar Commit 1 (NO CVE) and Similar Commit 4 (NO CVE) which fixed error handling and cleanup issues without security implications, unlike the commits that received CVEs which involved use-after-free vulnerabilities or password handling security issues.
9110056fe10b0 platform/x86: think-lmi: Fix kobject cleanup
- [sasha] Based on my analysis of this commit and the similar commits provided, I determine:
  **NO**, this commit should not be assigned a CVE.
  Here's my reasoning:
  1. **Memory leak vs Reference leak**: While this commit fixes a kobject lifecycle issue similar to the CVE-assigned commits, the key difference is in the failure mode. The similar commits fix **reference leaks** where `kset_find_obj()` or `kobject_init_and_add()` return a reference that must be released with `kobject_put()`. This commit fixes a different issue where structs with embedded kobjects are being freed with `kfree()` instead of `kobject_put()` in error paths.
  2. **Impact assessment**: The commit fixes improper cleanup in error paths during driver initialization (`tlmi_analyze()`). This would only occur if the driver fails to initialize properly, which is a rare condition. The memory leak would be:
     - Limited in scope (only during failed initialization)
     - Not continuously exploitable
     - Not remotely triggerable
     - Requires specific hardware (Lenovo ThinkPad/ThinkStation)
  3. **Attack surface**: Unlike the similar commits which could potentially be triggered repeatedly to exhaust memory, this issue only occurs during driver probe failure, making it difficult to exploit intentionally.
  4. **Code changes**: The fix moves `kobject_init()` calls from `tlmi_analyze()` to `kobject_init_and_add()` in `tlmi_sysfs_init()`, and properly iterates through kset lists for cleanup. This is a standard kobject lifecycle fix but in a limited error path scenario.
  While this is a legitimate bug fix that prevents potential memory leaks, it lacks the security impact necessary for CVE assignment due to its limited scope and difficult exploitability.
8dab34ca77293 platform/x86: think-lmi: Create ksets consecutively
- [sasha] **NO**
  This commit fixes an error handling issue where `tlmi_release_attr()` could be called when `authentication_kset` has not been created yet. The commit reorganizes the code to create both `attribute_kset` and `authentication_kset` consecutively early in `tlmi_sysfs_init()`.
  The issue is that in the original code:
  1. `attribute_kset` is created first
  2. Many operations occur that could fail and jump to `fail_create_attr`
  3. `authentication_kset` is created much later (line 1499)
  4. If failure occurs before `authentication_kset` creation, `tlmi_release_attr()` is called
  5. `tlmi_release_attr()` assumes both ksets exist and performs operations on authentication-related kobjects
  While this could cause a NULL pointer dereference or improper cleanup in error paths leading to a kernel oops, this is a reliability/stability issue rather than a security vulnerability because:
  - It only occurs during driver initialization error paths
  - It cannot be triggered remotely
  - It doesn't lead to privilege escalation or information disclosure
  - It's a local crash condition at worst
  Unlike the similar commits marked as CVE=YES which fixed reference leaks (memory exhaustion) or authentication bypass issues, this commit only addresses proper error handling during initialization.
2b29be967ae45 riscv: cpu_ops_sbi: Use static array for boot_data
- [sasha] Now let me understand the exact security issue. Based on my analysis:
  **YES**
  This commit fixes a security vulnerability that causes secondary CPUs to access invalid memory addresses during boot, leading to system hangs and potential crashes. Here's why this deserves a CVE:
  1. **Memory Safety Violation**: The bug causes the kernel to incorrectly use `__pa()` (physical address conversion) on percpu data that may be allocated in the vmalloc area. The `__pa()` macro only works correctly for linear mapped addresses, not vmalloc addresses.
  2. **System Availability Impact**: When triggered, secondary CPUs attempt to dereference invalid physical addresses during boot (`hsm_data = __pa(bdata)` at line 78), causing them to hang immediately. This results in a partially functional system with reduced CPU capacity.
  3. **Triggered by Configuration**: The vulnerability is triggered when:
     - `CONFIG_NUMA=y` is enabled
     - The percpu page allocator is used (either on sparse NUMA configs or when `percpu_alloc=page` boot parameter is set)
     - This causes `boot_data` to be allocated in vmalloc space instead of the linear mapping
  4. **Real-World Impact**: The commit message explicitly states "This fixes NUMA=y SMP boot on Sophgo SG2042", indicating this affects real hardware systems.
  5. **Security Boundary Crossed**: The issue involves incorrect memory address translation leading to invalid memory access by the CPU firmware (SBI), which expects a valid physical address but receives an incorrectly translated vmalloc address.
  The fix changes from `DEFINE_PER_CPU(struct sbi_hart_boot_data, boot_data)` to `static struct sbi_hart_boot_data boot_data[NR_CPUS]`, ensuring the boot data is always in the kernel's static data section where `__pa()` works correctly.
964209202ebe1 powercap: intel_rapl: Do not change CLAMPING bit if ENABLE bit cannot be changed
- [sasha] This bug has been present since the initial RAPL driver introduction in 2013.
  **CVE Decision: NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **No Security Boundary Violation**: The bug does not cross any security boundaries. It requires privileged access (CAP_SYS_ADMIN) to interact with the powercap sysfs interface.
  2. **Functional Issue, Not Security**: The issue is that when trying to disable power limiting, the system may operate at higher power levels than the configured limit. This is a functional correctness issue, not a security vulnerability.
  3. **No Unauthorized Access**: The bug doesn't allow:
     - Privilege escalation
     - Unauthorized data access
     - System compromise
     - Denial of service
  4. **Limited Impact**: The worst-case scenario is that the system consumes more power than the configured limit, which is an operational concern rather than a security issue.
  5. **Hardware Safety Mechanisms**: Modern Intel processors have built-in thermal and power protection mechanisms that prevent damage regardless of software settings.
  The code change correctly fixes the issue by checking whether the ENABLE bit was actually changed before proceeding to modify the CLAMPING bit, preventing the inconsistent state. However, this is a bug fix for proper power management functionality, not a security vulnerability fix.
25b1b75bbaf96 iommu/vt-d: Assign devtlb cache tag on ATS enablement
- [sasha] Based on my analysis of the commit and the historical context, here is my determination:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Security Impact - Stale TLB Entries**: The bug causes device TLB (Translation Lookaside Buffer) entries to not be invalidated when memory mappings are unmapped. This means devices with ATS (Address Translation Service) enabled can continue to access memory regions that have been unmapped, leading to:
     - Use-after-free vulnerabilities
     - Information disclosure (accessing freed/reallocated memory)
     - Potential privilege escalation if the stale mappings point to sensitive memory
  2. **Clear Security Boundary Violation**: The IOMMU is a critical security component that enforces memory isolation between devices and the system. When device TLB entries are not properly invalidated, this isolation is broken.
  3. **Real-World Impact**: The commit message explicitly states "leading to the device TLB not being invalidated in the iommu_unmap paths." This is a direct security issue where devices can access memory they should no longer have access to.
  4. **Similar Historical CVEs**: The similar commits show patterns where cache/TLB invalidation issues have been assigned CVEs:
     - Similar Commit 1 (CVE Status: YES) - "Remove cache tags before disabling ATS" - dealt with use-after-free
     - Similar Commit 5 (CVE Status: YES) - "Fix NULL domain on device release" - also dealt with improper cleanup
  5. **Code Analysis**: The fix adds cache tag assignment for DEVTLB when ATS is enabled in `probe_finalize()`. Without this, the `cache_tag_flush_range()` function skips device TLB invalidation because no DEVTLB cache tags exist for the domain, leaving stale translations in the device.
  The vulnerability allows devices to bypass IOMMU protection by using stale TLB entries to access memory that should be inaccessible after unmapping.
62e062a29ad51 iommu/rockchip: prevent iommus dead loop when two masters share one IOMMU
- [sasha] **YES**
  This commit fixes a **denial of service vulnerability** that can cause kernel hangs through an infinite loop.
  **Security Analysis:**
  1. **The Bug**: When two masters share one IOMMU, `rk_iommu_of_xlate()` is called for each master and incorrectly overwrites `iommu->domain = &rk_identity_domain`. This causes the check `if (iommu->domain == domain)` in `rk_iommu_attach_device()` (line 1026) to fail, resulting in the same `iommu->node` being added to `&rk_domain->iommus` list twice via `list_add_tail()` at line 1036.
  2. **Impact**: Adding the same node twice creates a circular linked list. When `rk_iommu_zap_iova()` traverses this list using `list_for_each(pos, &rk_domain->iommus)` at line 687, it enters an **infinite loop**, causing a complete system hang.
  3. **Attack Vector**: This vulnerability can be triggered during device initialization when specific hardware configurations exist (two masters sharing one IOMMU). The infinite loop occurs during normal IOMMU operations like TLB invalidation.
  4. **The Fix**: Moving `iommu->domain = &rk_identity_domain` initialization from `rk_iommu_of_xlate()` to `rk_iommu_probe()` ensures it's set only once during IOMMU hardware probe, preventing the domain from being incorrectly overwritten.
  This vulnerability has similar severity to the CVE-assigned commit that fixed a NULL pointer dereference, as both can cause kernel crashes/hangs leading to denial of service.
312d02adb959e optee: ffa: fix sleep in atomic context
- [sasha] Based on my analysis, here is my verdict:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Security-Relevant Bug**: The commit fixes a "sleeping function called from invalid context" bug in the kernel's OP-TEE driver. This is a violation of kernel's atomic context rules that can lead to kernel instability.
  2. **Exploitable Condition**: The bug occurs when processing FF-A asynchronous notifications in atomic context. The notif_callback() function is called in atomic context (as shown by the call trace: in_atomic(): 1, irqs_disabled(): 1), but it calls optee_do_bottom_half() which eventually calls mutex_lock() through optee_get_msg_arg().
  3. **System Impact**: From the stack trace, we can see:
     - The bug triggers a kernel BUG warning
     - It happens in interrupt/atomic context (in_atomic(): 1, irqs_disabled(): 1)
     - The problematic path is through workqueue handling (ffa_pcpu_irq_notification)
  4. **Attack Vector**: An attacker with access to trigger OP-TEE asynchronous notifications could potentially cause kernel crashes or denial of service by triggering this atomic sleep violation repeatedly.
  5. **Similar to CVE-assigned commits**: Looking at the similar commits provided:
     - Similar Commit 1 & 2 (CVE Status: YES) fixed atomic context violations in dm-bufio
     - Similar Commit 3 & 5 (CVE Status: YES) fixed GFP_KERNEL usage in atomic context
     - These are the same class of bugs - sleeping/blocking operations in atomic context
  The fix properly addresses this by adding a workqueue to defer the processing to a non-atomic context, which is the correct approach for handling operations that need to sleep when called from atomic/interrupt context.
cee4392a57e14 Logitech C-270 even more broken
- [sasha] Based on my analysis, here's my assessment:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **No Security Vulnerability Fixed**: The commit adds `USB_QUIRK_NO_LPM` (disabling Link Power Management) to an existing `USB_QUIRK_RESET_RESUME` quirk for the Logitech C-270 webcam. These quirks address functionality/compatibility issues, not security vulnerabilities.
  2. **Nature of the Quirks**:
     - `USB_QUIRK_RESET_RESUME`: Forces the device to be reset instead of resumed after suspend, addressing audio quality issues (the original commit mentioned fixing "chipmunk-like voice")
     - `USB_QUIRK_NO_LPM`: Disables USB Link Power Management for devices that don't work properly with power management features
  3. **Similar to Reference Commits**: This change follows the same pattern as the similar commits provided that were marked "CVE Status: NO" - they all add device-specific quirks to address hardware compatibility issues rather than security vulnerabilities.
  4. **Impact**: The issue being fixed is that "Some varieties of this device don't work with RESET_RESUME alone" - this is a functionality problem where certain variants of the webcam fail to work properly, not a security issue that could be exploited.
  The commit is purely a hardware compatibility fix to ensure the Logitech C-270 webcam works properly across different device variations, with no security implications.
3d30048958e0d i2c/designware: Fix an initialization issue
- [sasha] Based on my analysis, I can now provide a determination:
  **NO**, this commit should not be assigned a CVE.
  Here's my reasoning:
  1. **Limited Attack Surface**: The vulnerability only affects AMD NAVI GPU I2C controllers (specific hardware with MODEL_AMD_NAVI_GPU flag), not general-purpose I2C controllers. This significantly limits the attack surface.
  2. **No Memory Corruption**: The uninitialized `msg_write_idx` would cause an out-of-bounds array access when dereferencing `msgs[dev->msg_write_idx]` in `i2c_dw_xfer_init()` at lines 257 and 276. However, this is a read operation that would likely cause a kernel crash/panic rather than exploitable memory corruption.
  3. **Hardware-Specific Driver Path**: The vulnerable code path (`amd_i2c_dw_xfer_quirk`) is only executed for specific AMD NAVI GPU hardware through the PCI driver. This is not a general-purpose code path that unprivileged users can trigger.
  4. **Local Access Required**: To trigger this bug, an attacker would need:
     - Physical presence of AMD NAVI GPU hardware
     - Ability to perform I2C operations on that specific controller
     - This typically requires root or specific device permissions
  5. **Initialization Bug, Not Security Boundary Violation**: This is a programming error that causes incorrect behavior/crashes but doesn't cross security boundaries or allow privilege escalation.
  6. **Similar Commits Pattern**: Looking at the similar commits provided, none of them received CVEs despite fixing various error handling and initialization issues in the same I2C driver subsystem.
  The fix correctly initializes `dev->msg_write_idx = 0` before calling `i2c_dw_xfer_init()`, preventing the out-of-bounds access. While this is an important bug fix that prevents kernel crashes on affected hardware, it doesn't meet the threshold for CVE assignment as it doesn't represent a security vulnerability that can be exploited for unauthorized access, privilege escalation, or information disclosure.
5f05fc6e2218d dt-bindings: i2c: realtek,rtl9301: Fix missing 'reg' constraint
- [sasha] **NO**
  This commit is a documentation-only change that fixes a missing constraint in Device Tree bindings. The change adds a proper YAML schema constraint to the 'reg' property by wrapping it with `items:` to ensure it only accepts a single address space entry.
  Key points:
  1. **No runtime impact**: Device Tree bindings are schema validation files used during kernel build/development to validate device tree source files. They don't affect kernel runtime behavior.
  2. **Documentation fix only**: The change only affects how the binding is validated during compilation, not any actual driver code or kernel functionality.
  3. **No security implications**: Missing this constraint could at worst allow an incorrectly formatted device tree to pass validation, but this wouldn't create any security vulnerabilities since the driver would still validate inputs at runtime.
  4. **Similar to reference commits**: Like the similar commits provided (which all have CVE Status: NO), this is a pure schema/documentation fix in the dt-bindings directory.
  The fix ensures proper validation of device tree files but has no impact on system security or stability.
38224c472a038 HID: appletb-kbd: fix slab use-after-free bug in appletb_kbd_probe
- [sasha] Now I have enough information to analyze this commit. Based on my analysis:
  **YES**, this commit should be assigned a CVE.
  **Explanation:**
  1. **Security Vulnerability Type**: This is a **use-after-free (UAF) vulnerability** in the kernel's HID driver for Apple Touch Bar keyboards. The commit message explicitly states "fix slab use-after-free bug" and includes a KASAN (Kernel Address Sanitizer) stack trace showing the UAF occurring.
  2. **Root Cause**: The vulnerability occurs when:
     - In `appletb_kbd_probe()`, a timer (`kbd->inactivity_timer`) is set up and armed to run after 60 seconds
     - If probe fails after the timer is armed (e.g., during `input_register_handler()` or `appletb_kbd_set_mode()`), the error path does not cancel the timer
     - The `kbd` structure is freed because it's allocated with `devm_kzalloc()` (device-managed memory)
     - After 60 seconds, the timer fires and `appletb_inactivity_timer()` attempts to access the freed `kbd` structure
  3. **Security Impact**: 
     - **Memory corruption**: The timer handler accesses freed memory which could be reallocated to other kernel structures
     - **Potential for exploitation**: While this appears to be a local attack vector (requires physical access to trigger probe failure), UAF vulnerabilities in the kernel can potentially lead to privilege escalation or kernel crashes
  4. **Fix Analysis**: The commit properly fixes the issue by:
     - Adding `timer_delete_sync()` calls in error paths after the timer is set up
     - Ensuring the timer is only deleted if `kbd->backlight_dev` exists (since the timer is only set up in that case)
     - Moving the `timer_delete_sync()` call in `appletb_kbd_remove()` to only execute when `kbd->backlight_dev` exists
  5. **Comparison to Similar Commits**: This matches the pattern of CVE-assigned commits:
     - Similar Commit 1 (CVE: YES) - Fixed a reference counting bug leading to use-after-free
     - Similar Commit 2 (CVE: YES) - Fixed a use-after-free with delayed work timer
     - Similar Commit 5 (CVE: YES) - Fixed timer-related use-after-free by using `del_timer_sync()`
  The commit includes proper tags (`Fixes:` and `Cc: stable@vger.kernel.org`), indicating it's a security-relevant fix that needs backporting to stable kernels.
2b95a7db6e0f7 dma-buf: fix timeout handling in dma_resv_wait_timeout v2
- [sasha] Now let me analyze the bug and the fix. Looking at the code changes and documentation:
  **NO**
  This commit should NOT be assigned a CVE. Here's my analysis:
  1. **Bug Type**: This is a functional bug, not a security vulnerability. The issue is with incorrect behavior when `timeout=0` is passed to `dma_resv_wait_timeout()`.
  2. **What the bug does**: 
     - The old code would pass the remaining timeout value (`ret`) to subsequent fence waits in the loop
     - When `timeout=0`, it starts with `ret=1` and passes this to `dma_fence_wait_timeout()`
     - This causes the function to wait for at least one jiffy instead of returning immediately
  3. **Expected behavior vs actual**:
     - Documentation states: "timeout value in jiffies or zero to return immediately"
     - The function should check if fences are signaled and return 1 (success) without waiting when timeout=0
     - Instead, it waits for at least one jiffy due to the bug
  4. **Security Impact**: None identified
     - No memory corruption
     - No privilege escalation
     - No information disclosure
     - No denial of service (beyond a minor delay)
     - Just incorrect timing behavior - waiting ~1 jiffy when it should return immediately
  5. **Similar commits analysis**:
     - The CVE-assigned similar commits (2 and 4) involve:
       - Deadlocks that can hang the system
       - Use-after-free vulnerabilities
       - Race conditions with security implications
     - This commit just fixes a timing discrepancy
  The fix correctly passes the original `timeout` value to each fence wait and only updates it when timeout is non-zero, ensuring zero timeout truly returns immediately. This is a quality/correctness fix, not a security fix.
74ebd02163fde cifs: all initializations for tcon should happen in tcon_info_alloc
- [sasha] Based on my analysis, this commit should be assigned a CVE: **YES**
  Here's my reasoning:
  1. **The bug creates uninitialized memory usage**: When `tcon_info_alloc()` is called outside of `cifs_get_tcon()` (specifically in `smb2_reconnect_server()` and `cifs_setup_ipc()`), the following fields are left uninitialized:
     - `pending_opens` list head
     - `query_interfaces` delayed work struct  
     - `dfs_cache_work` delayed work struct
  2. **This leads to kernel crashes/corruption**: 
     - Uninitialized list heads will cause kernel crashes when operations like `list_for_each_entry()` are performed on `pending_opens` (as seen in `smb2misc.c`)
     - Uninitialized work structs will cause crashes when `queue_delayed_work()` is called on them
  3. **Security impact**:
     - These crashes can be triggered during normal SMB operations like reconnection scenarios
     - The crashes occur in kernel space, potentially leading to denial of service
     - Uninitialized memory usage could potentially be exploited for information disclosure or privilege escalation
  4. **The fix is marked for stable**: The commit includes `Cc: <stable@vger.kernel.org>`, indicating the maintainers consider this a serious bug requiring backporting.
  5. **Similar to CVE-assigned commits**: Looking at the similar commits, CVE-2024-53049 was assigned for a tcon reference leak that could cause issues. This uninitialized memory bug is arguably more severe as it directly leads to kernel crashes.
  The commit fixes a real security vulnerability where uninitialized memory structures in the kernel can be accessed, leading to crashes and potential security exploitation.
b8f89cb723b9e smb: client: fix readdir returning wrong type with POSIX extensions
- [sasha] Now I'll analyze the bug. The issue is clear from the code and commit message:
  1. In `cifs_posix_to_fattr()` at line 267 of readdir.c, the code was incorrectly using:
     ```c
     fattr->cf_dtype = S_DT(le32_to_cpu(info->Mode));
     ```
     This applies the S_DT macro directly to the raw wire format mode from the SMB response.
  2. However, the correct implementation (as shown in `smb311_posix_info_to_fattr()` at line 874 of inode.c) is:
     ```c
     fattr->cf_dtype = S_DT(fattr->cf_mode);
     ```
     This applies the S_DT macro to the already-converted POSIX mode value.
  The problem is that the wire format mode values from SMB3.1.1 POSIX extensions use different bit assignments for file types compared to standard POSIX file types. The `wire_mode_to_posix()` function properly converts the wire format to POSIX format, but the buggy code was extracting the directory entry type from the unconverted wire format.
  This would cause applications like `ls` or `find` to misidentify file types when using readdir(), potentially treating directories as regular files or vice versa, which could prevent directory traversal.
  **CVE Status: NO**
  This bug does not warrant a CVE assignment because:
  1. **No security boundary is crossed** - This is a functional bug that causes incorrect behavior in userspace applications, but does not expose any security vulnerabilities
  2. **No privilege escalation** - The bug doesn't allow access to files/directories that shouldn't be accessible
  3. **No data corruption or loss** - The bug only affects how file types are reported via readdir(), not the actual files or their permissions
  4. **No denial of service** - While applications may behave incorrectly, the system remains stable
  5. **The impact is limited to display/traversal logic** - Applications using stat() would still get correct information, only readdir() results were affected
  This is similar to the other SMB client commits shown as examples, which fixed functional bugs in file type detection or mode display but were not assigned CVEs. The bug affects usability and correctness but does not introduce security vulnerabilities.
3b18405763c1e usb: acpi: fix device link removal
- [sasha] Based on my analysis of the commit and the surrounding context, I can now provide my assessment:
  **NO**
  This commit does not warrant a CVE assignment. Here's why:
  1. **Not a security vulnerability**: The issue being fixed is a resource leak (memory leak) of device link structures, not a security vulnerability. When the device link flag was changed from `DL_FLAG_AUTOREMOVE_CONSUMER` to `DL_FLAG_STATELESS` in commit 623dae3e7084, it created a situation where the device links needed to be manually removed, but the disconnect path wasn't updated to handle this.
  2. **Impact is limited to resource leak**: The code changes show that the fix simply adds proper cleanup by calling `device_link_del()` during USB device disconnection. The missing cleanup would cause device link structures to remain allocated after USB device removal, leading to a memory leak, but not a security issue.
  3. **No exploitable condition**: There's no evidence of:
     - Privilege escalation potential
     - Information disclosure
     - Denial of service beyond gradual memory consumption
     - Use-after-free or other memory corruption issues
     - Any way for an attacker to trigger or exploit this condition
  4. **Similar to non-CVE commits**: Looking at the similar commits provided, commit 2 (net: usb: usbnet: fix race in probe failure) which also fixes a cleanup/resource management issue was marked as "CVE Status: NO", which is consistent with this assessment.
  The commit is a proper bug fix for a resource management issue introduced by a previous change in the device link handling logic, but it does not represent a security vulnerability requiring CVE assignment.
31a6afbe86e8e usb: chipidea: udc: disconnect/reconnect from host when do suspend/resume
- [sasha] Based on my analysis of this commit, here's my assessment:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Not a security vulnerability**: The issue being fixed is a system hang/denial of service condition that occurs during normal suspend/resume operations when there's active USB traffic. It's a reliability/functionality bug, not a security vulnerability.
  2. **No privilege escalation or data exposure**: The commit fixes a hang that occurs when:
     - USB controller is suspended (clock gated)
     - USB host continues sending data
     - Device continues queueing requests and accessing registers
     - System hangs due to register access with gated clocks
  3. **Limited impact scope**: This only affects systems during suspend/resume cycles with active USB Ethernet traffic. It doesn't allow:
     - Remote code execution
     - Privilege escalation
     - Information disclosure
     - Memory corruption
  4. **Operational issue**: The fix adds proper disconnect/reconnect logic during suspend/resume to prevent the host from continuing to send data when the controller is suspended. This is a proper operational flow fix, not a security hardening.
  5. **Similar to non-CVE commits**: Looking at the similar commits provided, this is more like commits 1, 3, and 4 which handle suspend/resume states and operational issues without security implications. It's unlike commit 2 (which got a CVE) that fixed a deadlock with potential security implications.
  The commit message clearly describes this as a hang issue during normal operation, and the code changes simply add proper USB disconnect/reconnect logic to handle the suspend/resume flow correctly. This is a quality/reliability fix, not a security fix.
80e0839437755 usb: dwc3: gadget: Fix TRB reclaim logic for short transfers and ZLPs
- [sasha] Based on my analysis, I can now provide my assessment.
  **NO**, this commit should not be assigned a CVE.
  This is a functional bug fix rather than a security vulnerability. Here's my reasoning:
  1. **Nature of the bug**: The issue is about incorrect TRB (Transfer Request Block) reclaim logic that causes stale TRBs to remain in the ring with the HWO (Hardware Own) bit still set. This leads to broken data transfers in userspace applications like MTP over FunctionFS.
  2. **Impact analysis**: 
     - The bug causes functional failures in USB data transfers
     - It results in userspace applications receiving incorrect or incomplete data
     - There's no evidence of memory corruption, privilege escalation, or information disclosure
  3. **Code change**: The fix simply changes:
     ```c
     if (chain && (trb->ctrl & DWC3_TRB_CTRL_HWO))
     ```
     to:
     ```c
     if (trb->ctrl & DWC3_TRB_CTRL_HWO)
     ```
     This ensures the HWO bit is always cleared during TRB reclaim, preventing stale TRBs.
  4. **Security implications**: While the bug could cause data transfer failures, there's no indication that:
     - It allows unauthorized access to memory
     - It enables privilege escalation
     - It causes memory corruption that could be exploited
     - It leaks sensitive information
  5. **Comparison with similar commits**: Unlike the CVE-assigned commits in the examples which dealt with:
     - Deadlock conditions that could lead to DoS
     - Infinite loops processing malformed packets
     - Potential memory corruption issues
     
     This commit only fixes a functional issue where USB transfers fail to complete correctly.
  The bug is clearly a regression that breaks functionality, but it doesn't meet the criteria for a security vulnerability requiring CVE assignment.
630a1dec3b0eb usb: dwc3: Abort suspend on soft disconnect failure
- [sasha] Based on my analysis of the commit and the code, here is my assessment:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Security Impact - System Crash/DoS**: The commit fixes a scenario where the kernel can crash when attempting to access DWC3 USB controller registers after the power domain has been shut down. The commit message explicitly states this causes an "error" when `vbus_event_work()` attempts to access DWC3 registers for endpoint disabling.
  2. **Race Condition with Security Implications**: The bug creates a time window where:
     - The power domain is off (controller registers inaccessible)
     - But the gadget driver remains connected
     - Any VBUS event during this window triggers register access attempts, causing system crashes
  3. **Exploitable Attack Vector**: An attacker with physical access to the USB port could potentially trigger VBUS events (by connecting/disconnecting USB cables or devices) during system suspend, causing kernel crashes and denial of service.
  4. **Similar to Other CVE-Assigned Commits**: The reference commits show similar USB suspend/resume issues were assigned CVEs:
     - Similar Commit 1 & 2: Fixed crashes during system suspend with runtime suspended devices
     - Similar Commit 3 & 4: Fixed deadlock issues during suspend
     - Similar Commit 5: Fixed NULL pointer dereference issues
  5. **Code Analysis Shows Critical Failure Path**:
     - When `dwc3_gadget_soft_disconnect()` fails, the original code continued with suspend
     - This left the system in an inconsistent state where hardware is powered down but software thinks it's still connected
     - Any subsequent register access (via `dwc3_readl`/`dwc3_writel`) would access unmapped memory regions
  The fix properly aborts the suspend sequence when soft disconnect fails, preventing the dangerous inconsistent state that could lead to system crashes.
2831a81077f51 usb: cdnsp: Fix issue with CV Bad Descriptor test
- [sasha] Based on my analysis of the commit and the additional context from the kernel tree, here is my assessment:
  **NO**, this commit should not be assigned a CVE.
  Here's my reasoning:
  1. **Not a Security Vulnerability**: This commit fixes a USB compliance test failure ("TD 9.10 Bad Descriptor Test") rather than a security vulnerability. The issue is about proper protocol compliance with USB certification tests, not about any exploitable security weakness.
  2. **Functional Enhancement**: The change adds the ESP (Endpoint State Preserve) bit for EP0 (endpoint 0) during Halt Endpoint commands on SSP2 controllers. This is a functional enhancement to maintain proper endpoint state during halt operations, which is required for passing USB compliance tests.
  3. **Limited Impact**: The code changes show:
     - Only affects EP0 (the control endpoint): `(!ep_index ? TRB_ESP : 0)`
     - Only relevant for SSP2 controllers (as mentioned in the commit message)
     - Doesn't affect SSP controllers (no impact mentioned)
     - The state synchronization added in `cdnsp_setup_analyze()` is defensive programming to ensure software and hardware states match
  4. **No Security Boundary Crossed**: The changes don't involve:
     - Memory corruption or buffer overflows
     - Privilege escalation
     - Information disclosure
     - Access control bypass
     - Any other security-relevant issues
  5. **Similar to Previous Non-CVE Commits**: Looking at the similar commits provided (commits 1-4), none received CVEs despite fixing various functional issues in the same driver, including:
     - Link TRB handling fixes
     - USB request status corrections
     - Speed detection issues
     - Index corrections
  The only similar commit that received a CVE (commit 5) was because it fixed a NULL pointer dereference that could potentially cause a denial of service.
  This commit is purely about USB protocol compliance and doesn't introduce or fix any security vulnerabilities.
7e2c421ef88e9 usb: cdnsp: do not disable slot for disabled slot
- [sasha] **NO**
  This commit fixes a functional bug, not a security vulnerability. The change prevents the driver from sending a DISABLE_SLOT command with an invalid slot ID (0) to the USB controller hardware. According to the commit message, this results in a 'Slot Not Enabled Error' status from the hardware.
  The fix adds a simple check `if (pdev->slot_id)` before calling `cdnsp_disable_slot()` to avoid disabling an already disabled slot. This is a robustness improvement that prevents unnecessary error conditions but does not address any security concerns like memory corruption, privilege escalation, or information disclosure.
  The historical similar commits provided also show functional fixes to the cdnsp driver (incorrect index usage, status returns, speed detection, etc.) and none were assigned CVEs, further supporting that this type of fix doesn't warrant a CVE assignment.
63f4970a1219b Input: iqs7222 - explicitly define number of external channels
- [sasha] Now I can see the issue clearly:
  **NO**
  This commit fixes a functional bug but does not address a security vulnerability. Here's the analysis:
  1. **Nature of the Bug**: The issue is that for IQS7222D devices, which have 14 channels (not a multiple of 10), the code was incorrectly calculating `ext_chan = rounddown(14, 10) = 10`. This means channels 10-13 were being wrongly excluded from CRx pin assignments.
  2. **Code Analysis**: 
     - In line 2366: `int min_crx = chan_index < ext_chan / 2 ? 0 : 4;`
     - For IQS7222D with 14 channels, ext_chan would be 10, so channels 0-4 could use CRx0-3, and channels 5+ could use CRx4-7
     - But channels 10-13 would be incorrectly restricted because the code at line 2276 checks `if (val >= ext_chan)` for reference channel validation
  3. **Impact**: This is a functionality limitation where certain hardware pins (CRx pins) couldn't be properly assigned to certain channels (10-13) on IQS7222D devices. This prevents proper configuration of the touchpad controller but does not create any security risks.
  4. **No Security Implications**:
     - No memory corruption or buffer overflows
     - No privilege escalation possibilities
     - No information disclosure
     - No denial of service beyond the intended functionality limitation
     - Just a configuration restriction that prevents full hardware utilization
  The fix adds an `ext_chan` field to the device descriptor to explicitly define the number of external channels rather than assuming it's always a multiple of 10, which is correct for IQS7222D which has 14 channels total.
22c69d786ef8f Input: xpad - support Acer NGR 200 Controller
- [sasha] Based on my analysis, I can now provide a determination:
  **NO**
  This commit does not fix a security vulnerability. It simply adds support for a new Xbox controller model (Acer NGR 200) to the existing device recognition table.
  The change adds a single line:
  ```c
  { 0x0502, 0x1305, "Acer NGR200", 0, XTYPE_XBOX },
  ```
  This is a routine device ID addition that:
  1. **Does not fix any security issue** - It's adding support for hardware, not fixing a vulnerability
  2. **Does not change security-sensitive code** - The xpad_device array is just a lookup table for known controllers
  3. **Has no security impact** - Controllers not in the list still work; they just use generic handling with the last entry `{ 0x0000, 0x0000, "Generic X-Box pad", 0, XTYPE_UNKNOWN }`
  4. **Similar commits have no CVE history** - All the similar commits shown (adding 8BitDo controllers, Hyperkin controllers, etc.) were marked as "CVE Status: NO"
  The commit simply ensures the Acer NGR 200 controller is recognized by name and uses the XTYPE_XBOX profile instead of falling back to generic handling. This is a feature addition for better hardware support, not a security fix.
c80f2b047d5cc HID: appletb-kbd: fix memory corruption of input_handler_list
- [sasha] Based on my analysis of the commit and the kernel code, here's my determination:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Use-After-Free (UAF) Vulnerability**: The commit fixes a clear use-after-free vulnerability where the `kbd->inp_handler` remains in the global `input_handler_list` after the `kbd` structure is freed during probe failure.
  2. **Memory Corruption**: As shown in the KASAN report, this leads to memory corruption of the `input_handler_list`, which is a critical kernel data structure used throughout the input subsystem.
  3. **Security Impact**: The vulnerability can be triggered when:
     - The appletb-kbd probe fails after `input_register_handler()` is called
     - Any subsequent input device is plugged in (like a USB mouse)
     - The kernel traverses the corrupted `input_handler_list` and accesses freed memory
  4. **Remote Exploitation Potential**: While local physical access is required to plug in a USB device, this could potentially be exploited through:
     - USB devices that trigger specific probe failure conditions
     - Chained with other vulnerabilities for privilege escalation
  5. **Clear Security Fix Pattern**: The fix adds proper cleanup by calling `input_unregister_handler()` on the error path, which is a classic security fix pattern for resource management vulnerabilities.
  The code changes show:
  - Adding a new error label `unregister_handler:` 
  - Changing the error path from `goto close_hw` to `goto unregister_handler`
  - Properly calling `input_unregister_handler(&kbd->inp_handler)` to remove the handler from the global list before the memory is freed
  This follows the same pattern as similar CVE-assigned commits like the HID Sony and HID Elan fixes that addressed memory management issues in driver probe paths.
cd65ee81240e8 xhci: Disable stream for xHC controller with XHCI_BROKEN_STREAMS
- [sasha] Based on my analysis, here's my determination:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **No Security Vulnerability**: This is a functional bug fix, not a security vulnerability. The commit fixes a logic error where platform-based xHCI controllers with the `XHCI_BROKEN_STREAMS` quirk were incorrectly advertising stream support via `can_do_streams = 1`.
  2. **No Exploitable Impact**: The bug would cause UAS (USB Attached SCSI) devices to potentially fail to work properly on affected controllers, but this is a functionality issue, not a security issue. The storage subsystem has checks (in `uas_use_uas_driver()`) that prevent using UAS when streams aren't supported, so this wouldn't lead to memory corruption or other security issues.
  3. **Graceful Fallback**: When UAS cannot be used due to lack of stream support, the system falls back to the standard USB mass storage driver (usb-storage), ensuring devices still function, just potentially with reduced performance.
  4. **Similar Commits Pattern**: The referenced similar commits (all marked "CVE Status: NO") show that quirk additions and stream-related fixes in the xHCI driver are typically not considered security vulnerabilities. They are hardware compatibility fixes.
  5. **Limited Scope**: The fix only affects platform-based xHCI controllers (xhci-plat) that have the `XHCI_BROKEN_STREAMS` quirk set, which is a specific hardware configuration issue rather than a broadly exploitable vulnerability.
  The commit is fixing a logic inconsistency introduced in commit 14aec589327a6 where the platform driver wasn't checking the `XHCI_BROKEN_STREAMS` quirk before setting `can_do_streams`, unlike the PCI driver (xhci-pci.c) which already had this check.
efe3e3ae5a66c xhci: dbc: Flush queued requests before stopping dbc
- [sasha] Based on my analysis of the commit and code, here is my assessment:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Memory Leak Only**: The issue is primarily a memory leak that occurs when dbc (Debug Capability) is stopped without flushing pending requests. The commit message explicitly states "Failure to flush them lead to leaking memory."
  2. **Limited Attack Surface**: The xHCI Debug Capability (DbC) is a debugging feature that requires physical access or privileged access to enable. It's not a standard user-accessible interface.
  3. **No Security Boundary Crossed**: The issue doesn't allow:
     - Privilege escalation
     - Unauthorized access to data
     - Remote code execution
     - Denial of service beyond a memory leak
  4. **Error Messages Only**: The secondary impact mentioned is "dbc completing odd requests after resuming from suspend, leading to error messages" - this is just incorrect behavior that prints error messages, not a security vulnerability.
  5. **Similar to Previous Non-CVE Commits**: Looking at the similar commits provided, they handle various DbC issues (stall handling, performance improvements, busy-loop fixes) and none were assigned CVEs. This follows the same pattern.
  The fix simply adds a call to `xhci_dbc_flush_requests(dbc)` before disconnecting in the DS_CONFIGURED state to properly clean up pending requests and prevent the memory leak. This is a quality/stability fix rather than a security fix.
2b857d69a5e11 xhci: dbctty: disable ECHO flag by default
- [sasha] Based on my analysis, here's my determination:
  **NO**, this commit should not be assigned a CVE.
  Here's my reasoning:
  1. **Nature of the issue**: The ECHO flag being enabled by default causes incoming data to be echoed back to the sender. While this is undesirable behavior for a debug interface, it's not a security vulnerability per se. It's a functional/usability issue.
  2. **No privilege escalation or access control bypass**: The change doesn't fix any privilege escalation, unauthorized access, or bypass of security boundaries. Users who can access `/dev/ttyDBC0` already have the intended permissions to use the debug interface.
  3. **Limited impact**: The issue only affects data flow behavior - data that arrives gets echoed back. While the commit message mentions potential issues if data arrives before an application configures the terminal, this is more of a race condition affecting functionality rather than security.
  4. **Comparison with similar commit**: The referenced similar commit (00af4f3dda14) for `usb_debug.c` that disabled ECHO flags was marked with "Cc: stable" but was not assigned a CVE despite describing more severe potential consequences (commands being executed, system reboots). That commit explicitly mentioned security concerns like "log messages be executed as shell commands" and "instant reboot" scenarios.
  5. **Debug interface context**: This is a debug interface (`/dev/ttyDBC0`) that requires physical access (USB debug cable) and is intended for development/debugging purposes. The ECHO behavior is more of a configuration default issue rather than a security vulnerability.
  6. **No data disclosure or integrity violation**: The echoing doesn't expose any privileged information that wasn't already accessible to the connected debug host, nor does it allow modification of system state beyond what the debug interface already permits.
  The fix is appropriate for stability and correct behavior, which is why it has "Cc: stable", but it doesn't meet the threshold for a CVE assignment as it doesn't represent a security vulnerability with meaningful security impact.
cbc889ab01223 usb: xhci: quirk for data loss in ISOC transfers
- [sasha] Based on my analysis of this commit and the historical similar commits, I'll now provide my determination:
  **NO**
  This commit should NOT be assigned a CVE based on the following analysis:
  1. **Nature of the fix**: This is a hardware quirk workaround, not a security vulnerability fix. The commit addresses a specific hardware limitation in certain AMD platforms where isochronous (audio/video) transfers experience momentary data loss due to scheduling issues.
  2. **Scope and impact**: The issue only affects:
     - Specific older AMD platforms (listed in the PCI device IDs)
     - Only isochronous transfers (typically audio/video streaming)
     - Causes Missed Service Errors (MSE) resulting in audio/video glitches
     - Does not affect system security, memory corruption, or allow privilege escalation
  3. **Comparison with CVE-assigned commits**:
     - The NEC commit (bb0ba4cb1065) that received a CVE involved potential **memory corruption** where "data from the isochronous device were written to random buffers" and caused IOMMU faults
     - This AMD quirk only adjusts endpoint intervals to prevent scheduling conflicts - no memory safety issues
  4. **Code changes analysis**:
     - Simply adds `XHCI_LIMIT_ENDPOINT_INTERVAL_9` quirk flag
     - Limits endpoint intervals from 9 to 8 (64ms to 32ms service interval)
     - Pure timing adjustment, no security boundary violations
  5. **Lack of security indicators**:
     - No buffer overflows
     - No memory corruption
     - No access control bypass
     - No data leakage across security boundaries
     - Only affects quality of service for audio/video streaming
  The commit is a functional fix for a hardware compatibility issue, not a security vulnerability fix.
7aed15379db9c Revert "usb: xhci: Implement xhci_handshake_check_state() helper"
- [sasha] Based on my analysis of the commit and its security implications:
  **NO** - This commit should NOT be assigned a CVE.
  **Explanation:**
  1. **This is a bug fix, not a vulnerability fix**: The revert addresses a functional regression where the DWC3 USB controller with dual-role capability malfunctions when exiting host mode. The issue causes register reads to return 0 and affects device mode operation, but this is a reliability/functionality problem rather than a security vulnerability.
  2. **The original commit (6ccb83d6c497) was a workaround, not a security fix**: It was introduced to handle watchdog timeout issues on some platforms by allowing early exit from xhci_reset() without waiting for completion. This was a platform-specific workaround that created other problems.
  3. **The security implications are theoretical**: While skipping the reset handshake *could* potentially lead to security issues (as outlined in my analysis), the actual manifestation described in the commit is:
     - Register reads returning 0
     - DWC3 device mode malfunction
     - These are availability/functionality issues, not exploitable security vulnerabilities
  4. **No actual security exploitation described**: The commit message describes a specific hardware malfunction scenario (DWC3 dual-role switching) rather than any security vulnerability or exploit.
  5. **Similar commits show this pattern**: Looking at the similar commits provided, they all have "CVE Status: NO" and deal with hardware quirks, workarounds, and functionality fixes rather than security vulnerabilities:
     - Adding XHCI_RESET_ON_RESUME quirks
     - Fixing resume operations
     - Hardware-specific workarounds
  The key distinction is that while improper reset handling *could* theoretically lead to security issues, this specific commit addresses a functional regression where hardware doesn't work correctly, rather than fixing an actual exploitable security vulnerability.
3eff494f6e17a usb: xhci: Skip xhci_reset in xhci_resume if xhci is being removed
- [sasha] Now let me analyze the security implications. Based on the commit message and code changes:
  **NO**
  This commit does not warrant a CVE assignment. Here's why:
  1. **Nature of the fix**: This is a race condition fix that prevents xhci_reset() from being called during controller removal. The issue causes functional problems (register access issues) rather than security vulnerabilities.
  2. **Impact analysis**: 
     - The commit message describes the issue as causing "critical register access issues" where "all register reads return zero"
     - This is a hardware state/initialization problem, not a security vulnerability
     - No memory corruption, privilege escalation, or data exposure is involved
  3. **Code changes**: The fix simply adds a check for `XHCI_STATE_REMOVING` before calling `xhci_reset()` to avoid the race condition:
     ```c
     if (xhci->xhc_state & XHCI_STATE_REMOVING)
         retval = -ENODEV;
     else
         retval = xhci_reset(xhci, XHCI_RESET_LONG_USEC);
     ```
  4. **Comparison with similar commits**: The analyzed similar commits (1-5) all deal with hardware quirks, suspend/resume issues, and functional problems - none were assigned CVEs because they don't represent security vulnerabilities.
  5. **Root cause**: The issue stems from a timing/ordering problem during dual-role mode switching in DWC3 controllers - this is a functional/reliability issue rather than a security issue.
  The commit fixes a regression that affects device functionality and reliability but does not introduce or fix any security vulnerabilities that could be exploited by an attacker.
33b6a1f155d62 rcu: Return early if callback is not specified
- [sasha] Based on my analysis, I can now provide my assessment:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **No Direct Exploitability**: There is no evidence in the kernel codebase of any existing code path that passes NULL callbacks to call_rcu(). The grep results show no instances of `call_rcu(..., NULL)` being used.
  2. **Defensive Programming**: This is a hardening/defensive programming measure that adds robustness checks to prevent potential future bugs, similar to the first reference commit about RCU callback debugging. It's preventing a theoretical issue rather than fixing an actual vulnerability.
  3. **No Security Boundary Crossing**: Unlike the MSM/DPU commits (which had CVEs assigned), this doesn't fix a case where untrusted input could directly trigger the NULL dereference. The call_rcu() API is internal to the kernel and not directly accessible from userspace.
  4. **Similar Pattern to Non-CVE Commits**: This follows the same pattern as the first reference commit ("rcu: Dump memory object info if callback function is invalid") which added debugging for invalid callbacks but was marked as NO CVE. Both are adding defensive checks for programming errors.
  5. **API Misuse Prevention**: This prevents API misuse by kernel developers rather than fixing an exploitable security vulnerability. It's akin to adding parameter validation to catch programming errors early.
  The commit improves kernel robustness and debuggability but doesn't address an actual exploitable security vulnerability that exists in the current codebase.
6463cbe08b0cb mtd: spinand: fix memory leak of ECC engine conf
- [sasha] **CVE Decision: YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Memory Leak Vulnerability**: The commit fixes a memory leak where 8 bytes of memory allocated via `kzalloc()` in `spinand_ondie_ecc_init_ctx()` is never freed during device cleanup. This memory is allocated during probe but not freed during removal.
  2. **Attack Vector**: This leak occurs every time a SPI NAND device is probed and removed. In systems with dynamic device attachment/detachment (hot-pluggable SPI devices, module loading/unloading), an attacker with physical access or ability to trigger device re-probing could exhaust system memory.
  3. **Persistent Resource Consumption**: The kmemleak trace shows this is a real memory leak that persists - the memory becomes unreferenced and cannot be reclaimed until system reboot.
  4. **Similar CVE Precedent**: The provided similar commits show that memory leaks in driver probe/remove paths have consistently been assigned CVEs (all 5 similar commits have CVE Status: YES).
  5. **Security Impact**: While the leak is small (8 bytes per occurrence), repeated triggering could lead to:
     - Memory exhaustion 
     - System instability
     - Potential denial of service
  The fix correctly adds the missing `nanddev_ecc_engine_cleanup()` call in `spinand_cleanup()` to match the `nanddev_ecc_engine_init()` call in `spinand_init()`, properly freeing the allocated memory through the cleanup callback chain.
6fcab27915439 ACPICA: Refuse to evaluate a method if arguments are missing
- [sasha] Based on my analysis, here's my determination:
  **YES**, this commit should be assigned a CVE.
  **Explanation:**
  1. **Use-After-Free Vulnerability**: The commit message explicitly states that the issue causes "ACPICA to crash due to use-after-free". This is a serious memory safety vulnerability.
  2. **Security Impact**: The vulnerability occurs when:
     - A method expects more parameters than are provided by the caller
     - The code at line 549 loops through `obj_desc->method.param_count` parameters
     - But only `this_walk_state->num_operands` operands exist in the array
     - This causes the loop to access beyond the valid operands, potentially accessing freed memory
  3. **Attack Vector**: While triggered by firmware bugs, this could be exploited by:
     - Malicious firmware updates
     - ACPI table modifications
     - Potentially through ACPI method overrides
  4. **Critical Code Path**: The vulnerable code is in `acpi_ds_call_control_method()`, which is a core function for ACPI method execution. The loop at line 549-552:
     ```c
     for (i = 0; i < obj_desc->method.param_count; i++) {
         acpi_ut_remove_reference(this_walk_state->operands[i]);
         this_walk_state->operands[i] = NULL;
     }
     ```
     accesses `this_walk_state->operands[i]` based on `param_count` without verifying that `num_operands >= param_count`.
  5. **Real-World Impact**: The commit references an actual bug report with a crashed system, demonstrating this is exploitable in practice.
  The fix adds a critical bounds check that prevents accessing beyond the valid operands array, eliminating the use-after-free condition. This is a clear security vulnerability that warrants CVE assignment.
e7417421d8935 wifi: ath6kl: remove WARN on bad firmware input
- [sasha] **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **No security vulnerability fixed**: The commit simply replaces a `WARN_ON(1)` with an error message (`ath6kl_err()`). The underlying validation check (`if (le32_to_cpu(targ_info->byte_count) != sizeof(*targ_info))`) already existed and returns `-EINVAL` to reject bad firmware input.
  2. **Only removes diagnostic output**: The `WARN_ON()` macro generates a kernel warning with stack trace but doesn't affect the security posture. The validation and error handling remain unchanged - bad firmware input is still rejected with the same `-EINVAL` return.
  3. **Syzbot noise reduction**: As stated in the commit message, this is primarily to reduce syzbot reports. The WARN_ON was triggering frequently during fuzzing but wasn't indicating an actual security issue - just bad input being properly rejected.
  4. **Compare to similar commits**: Unlike the CVE-assigned commits in the examples which fixed actual vulnerabilities (double-free, missing endpoint validation, use-after-free), this commit only changes how an existing validation failure is reported.
  The security boundary (rejecting malformed firmware data) was already properly enforced before this change.
d1b1a5eb27c49 wifi: mac80211: drop invalid source address OCB frames
- [sasha] Based on my analysis, here's my determination:
  **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Input validation fix, not vulnerability fix**: The commit adds missing input validation to reject frames with invalid source MAC addresses (all zeros, multicast, or the device's own address) in OCB mode. This is a hardening measure that prevents creation of malformed station entries.
  2. **No security impact demonstrated**: Unlike security vulnerabilities that could lead to crashes, information disclosure, or privilege escalation, this fix prevents the system from accepting malformed data. The commit message indicates it was found by syzbot (a fuzzer), but doesn't describe any actual security impact.
  3. **Similar to existing validation**: The ADHOC interface type already has similar validation (`!is_valid_ether_addr(hdr->addr2)`), showing this is standard input validation that was missing from OCB mode.
  4. **No exploitable condition**: The code would create station entries with invalid addresses, but there's no indication this leads to memory corruption, crashes, or other exploitable conditions. It's simply incorrect behavior that accepts invalid input.
  5. **Compared to similar commits**: The provided similar commits (all marked "CVE Status: NO") fix functional issues like packet forwarding, flow dissection, and monitoring - none were assigned CVEs despite being more complex fixes.
  This is a quality/correctness fix that adds proper input validation, not a security vulnerability fix.
cffc873d68ab0 aoe: defer rexmit timer downdev work to workqueue
- [sasha] Based on my analysis, I can now provide my assessment:
  **NO**, this commit should not be assigned a CVE.
  Here's my explanation:
  1. **Nature of the issue**: This is a **kernel programming error** (calling a sleeping function from atomic/timer context), not a security vulnerability. The commit fixes calling `blk_mq_freeze_queue()` which contains `wait_event()` (a sleeping function) from within `rexmit_timer()` timer context.
  2. **No security boundary violation**: The issue doesn't involve:
     - Privilege escalation
     - Information disclosure
     - Memory corruption that could be exploited
     - Access control bypass
     - Data integrity issues
  3. **Impact is functional, not security-related**: 
     - The bug causes incorrect context usage (sleeping in atomic context)
     - This would likely trigger kernel warnings/splats but not create exploitable conditions
     - The fix properly defers the work to a workqueue where sleeping is allowed
  4. **Similar pattern to non-CVE commits**: Looking at the similar commits provided:
     - Commit 2 (LoongArch idle timer) - NO CVE: Also fixes a context/timing issue
     - This commit follows the same pattern of fixing improper context usage
  5. **Code changes show benign refactoring**:
     - Adds `DEVFL_DEAD` flag to defer work
     - Changes direct `aoedev_downdev()` call to `queue_work()`
     - Adds proper locking in `aoedev_downdev()`
     - These are standard kernel programming corrections, not security fixes
  The commit is a proper fix for a kernel programming error but does not address any security vulnerability that would warrant a CVE assignment.
d8ab68bdb294b scsi: target: Fix NULL pointer dereference in core_scsi3_decode_spec_i_port()
- [sasha] Based on my analysis, this is a clear NULL pointer dereference vulnerability that can be triggered. The commit message shows a kernel crash backtrace, and the code analysis confirms:
  1. **Security vulnerability**: NULL pointer dereference leading to kernel crash
  2. **Trigger condition**: Can be triggered by specific SCSI PR (Persistent Reservation) commands when the target portal group (TPG) cannot be located
  3. **Impact**: Denial of Service - kernel crash/panic
  4. **Attack vector**: Through SCSI target interface, potentially exploitable by unprivileged users who have access to send SCSI commands
  5. **Fix**: Simple NULL check before dereferencing
  **YES**
  This commit fixes a NULL pointer dereference vulnerability in the SCSI target subsystem. The bug occurs when `core_scsi3_decode_spec_i_port()` processes a SPEC_I_PT command and encounters an error (like being unable to locate the destination TPG). In the error cleanup path at the `out_unmap` label, the code unconditionally calls `core_scsi3_lunacl_undepend_item(dest_se_deve)` for each entry in the `tid_dest_list`. However, the first entry (for local registration) has `dest_se_deve` set to NULL, causing a kernel crash when dereferenced. This can be triggered through SCSI commands and results in a denial of service.
8acfb165a4922 regulator: fan53555: add enable_time support and soft-start times
- [sasha] Now I'll make my assessment:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **Not a security vulnerability**: The issue being fixed is a timing/reliability problem, not a security vulnerability. The commit adds proper enable_time delays to prevent system hangs when re-enabling regulators under load.
  2. **Hardware timing requirement**: The change implements manufacturer-specified soft-start timing requirements from datasheets. The missing delays were causing power instability issues when rapidly disabling/re-enabling regulators, particularly with the Rockchip NPU (rk8602).
  3. **No security boundary crossed**: The "fatal hangs" mentioned in the commit message are hardware-level power domain failures due to insufficient stabilization time, not exploitable software vulnerabilities. There's no:
     - Privilege escalation
     - Information disclosure
     - Remote code execution
     - Memory corruption
     - Access control bypass
  4. **Configuration/reliability issue**: This is a power management reliability fix that ensures proper hardware initialization timing. The code simply adds delays (fsleep) after enabling the regulator to allow voltage to stabilize before use.
  5. **Similar to other non-CVE commits**: The pattern matches other timing/delay fixes in the historical examples that were marked as NO CVE, such as the ov5675 camera sensor timing fix and the phy-fsl-imx8m-pcie initialization sequence fix.
  The commit improves system stability by implementing proper hardware timing specifications but does not address any security vulnerability.
13b86ea92ebf0 ASoC: amd: yc: update quirk data for HP Victus
- [sasha] Based on my analysis of this commit and the context from the kernel tree:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **No security vulnerability fixed**: The commit adds a DMI quirk entry to enable the internal microphone on HP Victus laptops. This is a hardware enablement patch, not a security fix.
  2. **Nature of the change**: The change simply adds another entry to the `yc_acp_quirk_table[]` DMI matching table:
     ```c
     +	{
     +		.driver_data = &acp6x_card,
     +		.matches = {
     +			DMI_MATCH(DMI_BOARD_VENDOR, "HP"),
     +			DMI_MATCH(DMI_PRODUCT_NAME, "Victus by HP Gaming Laptop 15-fb2xxx"),
     +		}
     +	},
     ```
  3. **Functionality impact only**: The quirk enables audio hardware (internal microphone) that wasn't working properly on this specific laptop model. This is about hardware compatibility, not security.
  4. **Pattern consistency**: This follows the exact same pattern as the 5 similar commits provided as reference, all of which have "CVE Status: NO". They all add DMI quirk entries to enable microphones on various laptop models.
  5. **No security-sensitive code paths**: The code doesn't touch any security boundaries, access controls, memory management issues, or input validation. It's purely a hardware enablement quirk.
  This is a typical hardware enablement patch that improves functionality but has no security implications whatsoever.
ab107276607af powerpc: Fix struct termio related ioctl macros
- [sasha] Let me analyze based on what I have:
  Based on my analysis, here's my assessment:
  **NO** - This commit should not be assigned a CVE.
  **Explanation:**
  1. **Not a security vulnerability**: This is a build/compilation fix, not a security issue. The commit fixes a userspace build failure where the `_IOR`/`_IOW` macros couldn't expand properly because they referenced `struct termio` which wasn't visible in the compilation context.
  2. **Nature of the change**: The fix replaces macro calls like `_IOR('t', 23, struct termio)` with hardcoded hexadecimal values (e.g., `0x40147417`). These values are the pre-calculated results of what the macros would have expanded to. This is purely a compile-time issue.
  3. **No runtime impact**: The actual ioctl values remain exactly the same - the hardcoded values are identical to what the macros would have produced. This means there's no change in kernel behavior, no access control bypass, no memory corruption, and no privilege escalation.
  4. **Similar to commit #1**: This is very similar to the sparc termio commit (c32d18e7942d7589b62e301eb426b32623366565) which was marked as "CVE Status: NO". Both commits deal with build issues related to obsolete `struct termio` definitions.
  5. **Build infrastructure issue**: The problem was that userspace programs trying to include the header files would get compilation errors because `struct termio` wasn't properly defined in their build context. This is a compatibility/portability issue, not a security vulnerability.
  The commit simply ensures that PowerPC userspace programs can compile successfully when using these ioctl definitions, without any security implications.
8a2277a3c9e4c genirq/irq_sim: Initialize work context pointers properly
- [sasha] Based on my analysis, I can now provide a determination:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Security Vulnerability**: The commit fixes an uninitialized memory vulnerability where function pointers in the `ops` member of `irq_sim_work_ctx` structure contain random values when allocated with `kmalloc()`. These uninitialized pointers can lead to arbitrary code execution when dereferenced.
  2. **Clear Security Impact**: The code in `irq_request()` (line 98-99) and `irq_released()` (line 112-113) checks if these function pointers are non-NULL before calling them:
     ```c
     if (work_ctx->ops.irq_sim_irq_requested)
         return work_ctx->ops.irq_sim_irq_requested(...);
     ```
     With uninitialized memory, these pointers could contain random non-zero values, causing the kernel to jump to arbitrary memory addresses.
  3. **Real-world Usage**: The gpio-sim driver actively uses this functionality with callbacks (`gpio_sim_irq_sim_ops`), making this a practical vulnerability in production systems.
  4. **Recent Introduction**: The vulnerable code was introduced in June 2024 (commit 011f583781fa), meaning systems running recent kernels could be affected.
  5. **Kernel Privilege Level**: This occurs in kernel space interrupt handling code, where arbitrary code execution would have severe security implications.
  The fix properly initializes the memory to zero using `kzalloc()` instead of `kmalloc()`, ensuring that unset function pointers are NULL rather than containing random values that could be misinterpreted as valid function addresses.
9ba75ccad8570 platform/x86/amd/pmc: Add PCSpecialist Lafite Pro V 14M to 8042 quirks list
- [sasha] Now I understand the complete picture. Let me analyze this commit:
  **NO**
  This commit does not fix a security vulnerability. It adds a hardware-specific workaround for a laptop model (PCSpecialist Lafite Pro V 14M) that has a firmware bug causing it to fail reaching hardware sleep during s2idle cycles when keyboard wakeup is enabled.
  Key reasons why this is NOT a CVE:
  1. **No security impact**: This is a power management/suspend issue that affects system functionality but has no security implications
  2. **Hardware-specific workaround**: The change simply adds another laptop model to an existing list of devices that need the keyboard wakeup disabled due to firmware bugs
  3. **Similar to existing quirks**: The pattern matches similar commits (Commit 1 and 2) which were marked as "CVE Status: NO"
  4. **Code changes**: The modification only adds a DMI match entry to `fwbug_list[]` to identify the affected hardware model and apply the existing `quirk_spurious_8042` workaround
  The `amd_pmc_wa_irq1()` function simply disables IRQ1 (keyboard) wakeup to work around firmware issues that cause spurious wakeups. This is a functional workaround for broken firmware, not a security fix.
ba06528ad5a31 ASoC: amd: yc: Add quirk for MSI Bravo 17 D7VF internal mic
- [sasha] **NO**
  This commit should not be assigned a CVE. The commit is adding a DMI quirk entry for the MSI Bravo 17 D7VF laptop to enable its internal microphone functionality. This is a hardware enablement change, not a security vulnerability fix.
  Key observations:
  1. The change adds a new DMI (Desktop Management Interface) table entry to match a specific laptop model
  2. It's a workaround for broken ACPI tables on this laptop model that prevent the internal microphone from working
  3. The pattern is identical to the 5 similar commits shown, all of which have "CVE Status: NO"
  4. There's no security vulnerability being fixed - it's simply enabling hardware functionality that wasn't working due to incorrect firmware/ACPI information
  5. The code changes are purely additive (7 lines added) and follow the exact same pattern as other laptop quirks in the same file
  This is a typical hardware enablement/quirk patch commonly seen in Linux kernel development for dealing with non-standard or broken firmware implementations on specific hardware models.
fe5b391fc56f7 ata: pata_cs5536: fix build on 32-bit UML
- [sasha] Based on my analysis, this commit should be assigned **NO** CVE. Here's my reasoning:
  1. **Build fix only**: This is purely a build configuration fix for User Mode Linux (UML), not a security vulnerability. The commit message clearly states "fix build on 32-bit UML".
  2. **No security impact**: The change only adds an additional check for `CONFIG_X86` to the existing `CONFIG_X86_32` check. This ensures that MSR (Machine Specific Register) functions are only included when building for real x86 hardware, not for UML which doesn't have MSR support.
  3. **Compilation issue**: The problem was that on 32-bit UML, `CONFIG_X86_32` is still defined, but UML doesn't provide MSR functionality. This caused build failures, not runtime security issues.
  4. **Similar to reference commits**: Looking at the similar commits provided:
     - Similar Commit 2 (x86/platform EISA config) - NO CVE - configuration fix
     - Similar Commit 4 (x86/microcode config) - NO CVE - configuration addition
     - Similar cs5535 commit shows this is addressing undefined MSR references in UML builds
  5. **No exploitable condition**: There's no vulnerability being fixed here - just ensuring the driver doesn't try to use MSR functions that don't exist in the UML environment. The worst case was a build failure, not a security issue.
  The change from `#ifdef CONFIG_X86_32` to `#if defined(CONFIG_X86) && defined(CONFIG_X86_32)` is a proper build configuration fix that prevents compilation errors in UML environments while maintaining the same functionality on real x86 hardware.
33877220b8641 ata: libata-acpi: Do not assume 40 wire cable if no devices are enabled
- [sasha] Based on my analysis of this commit, here is my determination:
  **NO** - This commit should not be assigned a CVE.
  **Explanation:**
  This commit fixes a functional bug, not a security vulnerability. Here's why:
  1. **Nature of the Issue**: The problem is that the `ata_acpi_cbl_80wire()` function was incorrectly assuming a 40-wire cable when devices hadn't been enabled yet. This led to the controller being limited to UDMA/33 (33 MB/s) instead of higher speeds that the hardware actually supported.
  2. **Impact Analysis**: 
     - The bug causes **performance degradation** (limiting to UDMA/33 instead of faster modes)
     - It does **not** create any security vulnerabilities like:
       - Buffer overflows
       - Memory corruption
       - Privilege escalation
       - Data exposure
       - Access control bypass
  3. **Code Changes**: The fix changes the return value from a binary (0/1) to a tri-state (ATA_CBL_PATA40/ATA_CBL_PATA80/ATA_CBL_PATA_UNK), with the key improvement being that it returns ATA_CBL_PATA_UNK initially instead of assuming 40-wire cable. This preserves the firmware-configured mode until devices are properly detected.
  4. **Comparison with Similar Commits**: Looking at the similar commits provided:
     - None of the "CVE Status: NO" commits involve security issues - they're all functional fixes for hardware compatibility
     - The one "CVE Status: YES" commit (pata_via.c forcing PIO for ATAPI) fixes a **hard system hang**, which is a denial-of-service security issue
  This commit merely fixes incorrect cable detection that resulted in suboptimal performance - it doesn't fix any security vulnerability.
4c267ae2ef349 ALSA: sb: Force to disable DMAs once when DMA mode is changed
- [sasha] Based on my analysis, here's my determination:
  **NO**
  This commit should NOT be assigned a CVE because:
  1. **Hardware-specific quirk, not a security vulnerability**: The commit addresses "unexpected noises" when changing DMA modes on legacy SB AWE32 hardware. This is a hardware quirk/bug workaround rather than a security issue.
  2. **No security impact**: The code change adds `snd_dma_disable()` calls to properly reset DMA channels when the DMA mode is changed via kcontrol. This prevents audio artifacts (noise) but doesn't fix any security vulnerability like:
     - No memory corruption
     - No privilege escalation
     - No information disclosure
     - No denial of service beyond audio quality issues
  3. **Legacy hardware**: This affects Sound Blaster 16/AWE32 cards, which are ISA-based legacy hardware from the 1990s. The driver requires ISA bus support and ISA DMA API.
  4. **User-controllable but benign**: While the DMA mode can be changed by users through ALSA controls, the worst outcome is audio noise, not a security compromise.
  5. **Similar to non-CVE commits**: Looking at the similar commits provided, the ones marked as "CVE Status: NO" deal with DMA synchronization and state management issues that don't have security implications. This commit is similar in nature.
  The commit is a quality-of-life fix for ancient hardware to prevent audio artifacts when switching DMA modes, not a security vulnerability fix.
ed29e073ba93f ALSA: sb: Don't allow changing the DMA mode during operations
- [sasha] **NO**
  This commit should not be assigned a CVE. Here's my analysis:
  1. **Nature of the fix**: The commit adds a simple check to prevent changing DMA mode while PCM operations are running (`if (chip->mode & (SB_MODE_PLAYBACK | SB_MODE_CAPTURE)) return -EBUSY;`). This is a quality/stability improvement rather than a security vulnerability fix.
  2. **Impact analysis**: 
     - The issue can potentially "screw up the hardware" according to the commit message, but this appears to be about audio quality/hardware stability rather than a security compromise
     - No memory corruption, privilege escalation, or information disclosure is indicated
     - The hardware affected (Sound Blaster AWE32) is legacy ISA sound hardware from the 1990s
  3. **Attack vector**: There is no realistic attack vector here. An attacker would need:
     - Local access to the system
     - Permission to access the sound card control interface
     - The presence of this very old ISA sound hardware
     - The ability to change DMA mode would at worst cause audio issues, not compromise system security
  4. **Comparison to similar commits**: Looking at the similar commits provided:
     - Commits marked "CVE Status: YES" involved actual security issues like UAF (use-after-free) and race conditions that could lead to memory corruption
     - Commits marked "CVE Status: NO" were typically functional fixes without security implications
     - This commit is clearly in the latter category - it's preventing a configuration error that affects audio functionality
  5. **Related commit context**: The follow-up commit (4c267ae2ef34) adds DMA disabling when the mode changes, further confirming this is about proper hardware state management rather than security.
  This is a functional bug fix for legacy hardware that prevents incorrect hardware state transitions, not a security vulnerability.
f681c2aa8676a drm/msm: Fix another leak in the submit error path
- [sasha] Based on my analysis:
  **YES**
  This commit fixes a file descriptor leak that occurs in the error path of the MSM GPU driver's gem submit ioctl. Here's why this is a security issue:
  1. **Resource Leak**: When `sync_file_create()` is called at line 871, it allocates a sync_file structure and creates an associated file object via `anon_inode_getfile()`. This file object holds kernel resources.
  2. **The Bug**: When `fd_install()` is called at line 875, it makes the file descriptor visible to userspace. If an error occurs after this point (line 880 `goto out`), the original code only called `put_unused_fd()` which releases the file descriptor number but NOT the file object itself.
  3. **Security Impact**: This creates a file descriptor leak where:
     - The file object (sync_file->file) remains allocated in kernel memory
     - Each failed ioctl call with MSM_SUBMIT_FENCE_FD_OUT flag after fd_install() leaks kernel memory
     - An attacker could repeatedly trigger this error path to exhaust kernel memory, leading to a denial of service
  4. **The Fix**: The patch adds `fput(sync_file->file)` at line 908 to properly release the file object reference in the error path after fd_install().
  This follows the same pattern as similar CVE-assigned commits in the historical examples (e.g., "drm/msm: Fix wait_fence submitqueue leak", "drm/msm/dpu: Fix memory leak in msm_mdss_parse_data_bus_icc_path"). The vulnerability allows local unprivileged users to cause kernel memory exhaustion through repeated failed ioctl calls, which is a classic DoS vector worthy of CVE assignment.
5d319f75ccf7f drm/msm: Fix a fence leak in submit error path
- [sasha] Based on my analysis, I can now provide a definitive answer:
  **YES**, this commit should be assigned a CVE.
  Here's my analysis:
  1. **The commit fixes a security vulnerability** - specifically a **memory/resource leak** of fence objects in error paths.
  2. **Technical details of the vulnerability:**
     - When `drm_sched_job_init()` is called, it allocates an `s_fence` via `drm_sched_fence_alloc()` (line 813 in sched_main.c)
     - In the normal path, when `drm_sched_entity_push_job()` is called, the job ownership transfers to the scheduler, and eventually `msm_job_free()` is called which properly cleans up via `drm_sched_job_cleanup()`
     - However, in error paths where the submit is freed before `drm_sched_entity_push_job()` is called, `msm_job_free()` never executes
     - This means `drm_sched_job_cleanup()` was never called, leaving the allocated `s_fence` and its associated resources leaked
  3. **Security impact:**
     - This is a **resource leak vulnerability** that can lead to memory exhaustion
     - An attacker could potentially trigger the error path repeatedly to exhaust system memory
     - The leak involves DMA fence objects which are kernel resources
  4. **Similar to CVE-assigned commits:**
     - This follows the same pattern as the similar commits marked "CVE Status: YES"
     - Like the first similar commit (drm/msm: Fix wait_fence submitqueue leak), this fixes a resource leak in error handling
     - Like the second similar commit (drm/amdgpu: fix use-after-free), this addresses improper cleanup of fence resources
     - Like the third similar commit (drm/scheduler: fix fence ref counting), this fixes fence reference counting issues
  5. **The fix:** The patch adds a check in `__msm_gem_submit_destroy()` to detect if `s_fence` exists (indicating the job wasn't pushed to the scheduler) and calls `drm_sched_job_cleanup()` to properly free the allocated resources.
  This is a clear case of a memory leak vulnerability in error handling paths that could be exploited to cause resource exhaustion, making it worthy of a CVE assignment.
f8afb12a2d750 x86/platform/amd: move final timeout check to after final sleep
- [sasha] Now let me analyze this commit based on the information gathered:
  **CVE Status: NO**
  This commit should not be assigned a CVE. Here's why:
  1. **No Security Vulnerability**: The code change refactors a polling loop to ensure at least one register read occurs after the final sleep. This is a timing/reliability improvement, not a security fix.
  2. **Nature of the Change**: The modification moves the timeout check from the `while` condition to inside the loop body, after reading the register status. This ensures that even if a sleep takes longer than expected due to scheduling delays, the code still checks the register one more time before declaring a timeout.
  3. **Impact Analysis**: 
     - The original code could incorrectly return ETIMEDOUT even when the operation succeeded during the final sleep
     - This is a functional bug, not a security vulnerability
     - It only affects reliability under extreme load conditions
     - There's no privilege escalation, memory corruption, information disclosure, or other security impact
  4. **Similar to Non-CVE Commits**: This commit is similar to the reference commits that were marked as "CVE Status: NO":
     - Like commit 3 (TPM timeout handling), it fixes a timing issue in polling logic
     - Like commit 4 (KIQ timeout increase), it addresses timeout handling under load
     - Like commit 5 (pcode timeout adjustment), it modifies timeout behavior for reliability
  The change improves system reliability under extreme load but does not address any security vulnerability. It's a quality-of-service improvement that prevents false timeout errors.
aa18d5769fcaf drm/xe: Allow dropping kunit dependency as built-in
- [sasha] **NO**
  This commit is a build configuration fix that corrects a Kconfig dependency issue. The changes:
  1. **Not a security vulnerability**: The commit only modifies Kconfig dependencies from `depends on DRM && PCI && (m || (y && KUNIT=y))` to `depends on DRM && PCI` plus `depends on KUNIT || !KUNIT`. This is purely a build system configuration change.
  2. **Fixes a build constraint**: The original commit (08987a8b6820) was overly restrictive, requiring KUNIT to be built-in when XE is built-in, even though KUNIT is only needed for optional unit tests.
  3. **No runtime impact**: This change only affects which kernel configurations are valid at build time. It doesn't change any runtime behavior, memory handling, access controls, or security boundaries.
  4. **Similar to reference commits**: Like the reference commits marked as "CVE Status: NO", this is a build system/configuration fix rather than a security vulnerability fix.
  The commit simply relaxes an overly restrictive build dependency, allowing XE to be built-in without KUNIT, while still ensuring that if KUNIT is enabled with XE, they must have compatible build configurations (both modules or both built-in).
9df7b5ebead64 netfs: Fix double put of request
- [sasha] **YES**
  This commit fixes a critical use-after-free vulnerability caused by a double put of a reference count in the netfs subsystem. The bug occurs when:
  1. A netfs request completes during collection, clearing the `NETFS_RREQ_IN_PROGRESS` flag and dropping its associated reference
  2. The wait function (`netfs_wait_for_request()`) incorrectly assumes it needs to drop the reference again when it sees the flag is already clear
  The code change in `netfs_collect_in_app()` adds a critical check:
  ```c
  +	if (!test_bit(NETFS_RREQ_IN_PROGRESS, &rreq->flags)) {
  +		trace_netfs_rreq(rreq, netfs_rreq_trace_recollect);
  +		return 1; /* Done */
  +	}
  ```
  This prevents the double reference drop that leads to:
  - **Use-after-free vulnerability** - The request structure can be freed while still being accessed
  - **Memory corruption** - Freed memory can be reallocated and corrupted
  - **Potential privilege escalation** - Kernel UAF bugs are often exploitable
  - **Remote trigger potential** - Since netfs is used by network filesystems like CIFS/SMB
  This is a classic kernel use-after-free vulnerability with serious security implications, warranting CVE assignment.
3363da82e02f1 smb: client: fix native SMB symlink traversal
- [sasha] Let me analyze the key changes in the commit. Looking at the commit message and code changes:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Not a Security Vulnerability**: This is a functionality/compatibility fix, not a security vulnerability. The commit restores the previous behavior where absolute symlinks were not automatically converted to /mnt/... paths unless explicitly requested via the symlinkroot= mount option.
  2. **User-Controlled Behavior**: The issue requires users to explicitly create specific directory structures (like /??/C:/) to make symlinks work. This is intentional user configuration, not an exploit.
  3. **No Security Boundary Crossing**: The change doesn't allow:
     - Privilege escalation
     - Unauthorized access to files
     - Breaking out of security boundaries
     - Remote code execution
  4. **Regression Fix**: The commit fixes a regression introduced by commit 12b466eb52d9 where absolute symlinks were being automatically converted to /mnt/... paths by default. The fix changes the behavior to only do this conversion when symlinkroot= is explicitly set.
  5. **Similar to Reference Commits**: Looking at the similar commits provided, they all have "CVE Status: NO" and deal with symlink handling improvements/fixes that don't introduce security vulnerabilities.
  The key change is:
  - Before fix: `symlinkroot` was automatically set to "/mnt/" if not specified
  - After fix: `symlinkroot` remains NULL unless explicitly set by the user
  This simply changes the default behavior for symlink path conversion but doesn't introduce any security vulnerability.
266b5d02e14f3 smb: client: fix race condition in negotiate timeout by using more precise timing
- [sasha] Based on my analysis of the commit and the code changes, here is my assessment:
  **NO** - This commit should NOT be assigned a CVE.
  Here's my reasoning:
  1. **Nature of the Issue**: This is a timing/race condition bug that causes functional problems (mount operations failing with "Host is down" error) rather than a security vulnerability. The issue is purely about incorrect timeout calculation leading to premature failure of legitimate operations.
  2. **No Security Impact**: The commit message and code changes show:
     - The bug causes legitimate mount operations to fail incorrectly
     - There's no memory corruption, privilege escalation, or information disclosure
     - No unauthorized access is gained
     - The system fails safely with an error rather than exposing any vulnerability
  3. **The Fix**: The change introduces a dedicated `neg_start` timestamp field to track when negotiation actually begins, replacing the use of `lstrp` (last response time) which could be set at various points causing incorrect timeout calculations. This is a timing precision fix, not a security fix.
  4. **Comparison with Similar Commits**: Looking at the reference commits:
     - Commits marked "CVE Status: NO" were functional fixes for reconnection/negotiation issues
     - The one marked "CVE Status: YES" (commit e0e50401cc39) was a use-after-free (UAF) vulnerability that could lead to memory corruption
     - This commit is clearly more similar to the functional fixes than the UAF vulnerability
  5. **Impact Analysis**: The worst outcome is that legitimate users experience failed mount operations when the server reboots. This is a denial of service in the sense that the service becomes unavailable, but it's due to a bug rather than an exploitable vulnerability. The system fails closed (denies access) rather than failing open.
  The commit fixes a race condition between the negotiate timeout mechanism and the reconnect process, but this race only affects the reliability of the mount operation, not the security of the system.
c2a2ff6b4db55 net: ipv4: fix stat increase when udp early demux drops the packet
- [sasha] Let me understand the issue by examining the change. Based on the commit message and the code changes provided:
  The commit changes:
  1. Changed `err` to `drop_reason` in the UDP early demux handling
  2. Changed from `err = udp_v4_early_demux(skb);` to `drop_reason = udp_v4_early_demux(skb);`
  3. Added `drop_reason = SKB_DROP_REASON_NOT_SPECIFIED;` after the check
  The issue is that `udp_v4_early_demux()` now returns a drop reason (not just 0 or error), but the code was still treating it as a simple error code. This means that when `udp_v4_early_demux()` returns `SKB_DROP_REASON_IP_RPFILTER`, the statistics counter `LINUX_MIB_IPRPFILTER` would not be incremented because the drop reason was being ignored.
  **CVE Analysis:**
  NO
  **Explanation:**
  This commit fixes a statistics accounting bug, not a security vulnerability. The issue is that when UDP early demux drops a packet due to reverse path filtering (rpfilter), the corresponding MIB counter (`LINUX_MIB_IPRPFILTER`) was not being incremented properly. This is purely a monitoring/statistics issue that affects network observability but does not create any security vulnerability.
  The bug only impacts:
  1. Network statistics accuracy - administrators would see incorrect rpfilter drop counts
  2. Debugging/monitoring capabilities - making it harder to diagnose rpfilter-related packet drops
  There is no:
  - Memory corruption or overflow
  - Privilege escalation
  - Information disclosure
  - Denial of service
  - Authentication bypass
  - Access control violation
  This is similar to the reference commits with "CVE Status: NO" that also fixed statistics/accounting issues without security implications.
16ceda2ef683a amd-xgbe: do not double read link status
- [sasha] Based on my analysis of the commit, here is my determination:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **No security vulnerability**: The change fixes a functional bug where the driver was unnecessarily double-reading the link status register, which defeated the hardware's design feature of latching link drops. This is a performance/functionality issue, not a security vulnerability.
  2. **No exploitable condition**: The code changes show:
     - Adding error handling for negative return values from `XMDIO_READ()`
     - Optimizing the link status reading logic to only double-read when the link was already down
     - No memory corruption, buffer overflows, or privilege escalation opportunities
  3. **Limited impact**: The issue only affects:
     - Link status detection efficiency 
     - Ability to detect momentary link drops
     - No data corruption or system instability
     - No unauthorized access or information disclosure
  4. **Driver behavior fix**: The commit message clearly states this is fixing an unintended behavior where "Always double-reading the status defeats this design feature." This is a correctness fix to properly utilize the hardware's link drop detection capability.
  5. **Similar to Commit 1**: This is similar to the first reference commit about toggling RX checksum offload features, which was also marked as NO CVE - both are fixing driver behavior to match hardware specifications without any security implications.
  The change is purely a functional improvement to ensure the driver properly detects link drops as designed by the hardware, with no security impact that would warrant a CVE assignment.
103406b38c600 net/sched: Always pass notifications when child class becomes empty
- [sasha] **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Explicit Use-After-Free vulnerability**: The commit message clearly states "This may unexpectedly empty the child qdisc and thus make an in-flight class passive via qlen_notify()... which will lead to a use-after-free."
  2. **Proof of concept included**: The commit provides a concrete reproducer script that demonstrates the vulnerability, showing it can be triggered with specific tc (traffic control) commands.
  3. **Security impact pattern**: This follows the same pattern as several previous CVE-assigned commits in the net/sched subsystem, particularly:
     - The similar commits shown (CVE Status: YES) all involve UAF vulnerabilities in traffic control schedulers
     - The vulnerability involves improper handling of qdisc state leading to stale pointers
  4. **Root cause analysis**: The code change shows the vulnerability exists because `qdisc_tree_reduce_backlog()` was checking conditions that could prevent proper notification when a child qdisc becomes empty, allowing parent qdiscs to maintain references to freed memory.
  5. **Systemic issue**: The commit acknowledges this is a "recurring pattern" of UAF vulnerabilities in the traffic control subsystem, indicating a class of security issues that warrant CVE assignment.
  The fix ensures that `qlen_notify` is always called when the child qdisc is empty (removing the complex conditional logic), preventing the use-after-free condition that occurs when qdiscs are deleted but parent classes still hold stale references.
561aa0e22b70a nui: Fix dma_mapping_error() check
- [sasha] Now let me analyze the security impact. Based on my analysis:
  **NO**
  This commit does not warrant a CVE assignment for the following reasons:
  1. **Bug class**: This is a proper error handling fix for DMA mapping failures, but the original bug was an incorrect error check rather than a security vulnerability. The original commit checked `if (!addr)` which is incorrect - DMA addresses can be 0 and still be valid. The proper check is `dma_mapping_error()`.
  2. **No memory corruption or data leakage**: The bug results in:
     - In `niu_rbr_add_page()`: Returns error correctly (though with wrong check)
     - In `niu_start_xmit()`: Would use potentially invalid DMA addresses, but this would likely cause driver/hardware errors rather than exploitable conditions
  3. **Limited impact**: The issue only occurs when DMA mapping fails (e.g., under memory pressure). When it does occur:
     - The RX path already had error handling (albeit incorrect)
     - The TX path was missing checks but would fail at hardware level
     - No privilege escalation or information disclosure paths
  4. **Comparison with similar commits**: Looking at the provided examples:
     - Similar Commit 1 & 3 (CVE: YES) involved removing erroneous unmapping of unrelated DMA mappings, which could corrupt memory state
     - Similar Commit 2 (CVE: NO) added proper DMA error checking, similar to this commit
     - This commit follows the same pattern as Commit 2 - adding missing error checks
  The commit is a quality/reliability fix that prevents the driver from using invalid DMA mappings, but does not fix an exploitable security vulnerability.
34a500caf48c4 rose: fix dangling neighbour pointers in rose_rt_device_down()
- [sasha] Now I have a clear understanding of the vulnerability. Let me analyze the impact and security implications:
  **YES**
  This commit fixes a critical use-after-free vulnerability in the ROSE protocol's routing code. Here's why this deserves a CVE:
  1. **Memory Safety Violation**: The bug causes use-after-free by leaving dangling pointers in the `rose_node->neighbour[]` array after the corresponding `rose_neigh` structures have been freed:
     - In line 522 of the original code, `rose_remove_neigh(s)` frees the `rose_neigh` structure
     - However, due to the loop bugs, some pointers to this freed structure remain in various `rose_node->neighbour[]` arrays
  2. **Exploitable Condition**: The vulnerability is triggered when:
     - A node has multiple references to the same neighbour (e.g., neighbours A, A, B)
     - The loop skips entries due to incrementing `i` after compacting the array
     - This leaves dangling pointers that are later dereferenced in functions like lines 692-704 where `node->neighbour[i]` is accessed
  3. **Attack Vector**: The vulnerability can be triggered through network device removal operations, which could potentially be influenced by:
     - Network configuration changes
     - Device hot-unplug events
     - Potentially crafted network packets that cause device state changes
  4. **Security Impact**: 
     - **Use-after-free**: Can lead to arbitrary memory read/write
     - **Potential for code execution**: Classic use-after-free vulnerabilities can be exploited for privilege escalation
     - **Remote triggerable**: ROSE is a network protocol, making this potentially exploitable remotely
  5. **Similar to CVE-assigned commits**: This fix is similar to "Similar Commit 2" which fixed a NULL pointer dereference in ROSE and was assigned a CVE. This vulnerability is actually more severe as use-after-free typically has greater exploitability than NULL dereference.
  The fix correctly addresses both issues by:
  - Using a fixed loop bound to ensure all entries are examined
  - Iterating in reverse order to prevent skipping entries after compaction
  - Using `memmove` to properly shift array elements
aaf2b24803750 enic: fix incorrect MTU comparison in enic_change_mtu()
- [sasha] **NO**
  This commit fixes a simple logging bug where the warning message was checking `netdev->mtu` (the current MTU) instead of `new_mtu` (the requested MTU) when comparing against `port_mtu`. This is purely a cosmetic issue that could result in:
  1. **Incorrect warnings**: The warning would trigger based on the current MTU rather than the new MTU being set
  2. **Misleading log messages**: The log would show the wrong MTU value in the warning
  The bug has no security implications because:
  - The actual MTU change logic is correct (uses `new_mtu` properly)
  - No buffer overflows or memory safety issues
  - No privilege escalation or access control bypass
  - No data corruption or system instability
  - The MTU is still properly set regardless of the incorrect warning
  This is similar to the "net: hibmcge: fix wrong mtu log issue" commit (Similar Commit 2) which was marked as NO CVE - both are simple logging fixes with no security impact.
42fd432fe6d32 amd-xgbe: align CL37 AN sequence as per databook
- [sasha] Based on my analysis of this commit and the additional context, here is my assessment:
  **NO** - This commit should NOT be assigned a CVE.
  **Explanation:**
  1. **Nature of the fix**: This commit fixes incorrect bit settings in the Clause 37 auto-negotiation implementation. Specifically:
     - It swaps the bit definitions for `XGBE_SGMII_AN_LINK_STATUS` (from BIT(1) to BIT(4)) and `XGBE_SGMII_AN_LINK_DUPLEX` (from BIT(4) to BIT(1))
     - It adds missing sequence steps in the auto-negotiation protocol
  2. **No security vulnerability**: The changes fix protocol compliance issues but do not address any security vulnerability:
     - The incorrect bit mappings would cause auto-negotiation to misinterpret link status and duplex settings
     - This could lead to link establishment failures or incorrect link parameters
     - However, this is a functional bug, not a security vulnerability
  3. **Impact analysis**:
     - The bug would primarily cause connectivity issues or suboptimal link configurations
     - There's no evidence of memory corruption, privilege escalation, information disclosure, or other security impacts
     - The fix ensures the driver properly follows the hardware databook specifications
  4. **Similar commits**: The referenced similar commits (dp83869, vitesse PHY drivers, i40e ST code, etc.) all fix auto-negotiation or register definition issues and were marked "CVE Status: NO"
  5. **Code changes are benign**: The changes are straightforward bit definition corrections and addition of proper register writes to follow the hardware specification. There's no fixing of buffer overflows, race conditions, or other typical security vulnerabilities.
  This is a classic example of a functional bug fix that improves hardware compliance and reliability but does not have security implications warranting a CVE assignment.
e6ed134a4ef59 lib: test_objagg: Set error message in check_expect_hints_stats()
- [sasha] **NO**
  This commit should not be assigned a CVE for the following reasons:
  1. **Test code only**: This is in `lib/test_objagg.c`, which is a test module (`CONFIG_TEST_OBJAGG`) that is only used for self-testing the object aggregation manager. It's not production code.
  2. **No security impact**: The bug is an uninitialized pointer dereference in error handling of test code. While this could cause a kernel crash if the test module is loaded and the specific error condition occurs, this is:
     - Only in a debugging/testing module that is not enabled by default (`default n` in Kconfig)
     - Only triggers during module initialization when running self-tests
     - Not remotely exploitable
     - Not part of any attack surface
  3. **Limited scope**: The commit message itself states "This likely doesn't affect anything in real life." The bug only manifests when:
     - The TEST_OBJAGG module is explicitly enabled and loaded
     - The `objagg_hints_stats_get()` function fails (returns an error)
     - The error path is taken in test code
  4. **Static checker finding**: This was found by static analysis (Smatch), not through any actual security impact or exploitation.
  The fix simply adds `*errmsg = "objagg_hints_stats_get() failed.";` to properly initialize the error message pointer before returning, preventing a potential use of uninitialized memory in test code error handling.
84c0b4a00610a drm/xe/bmg: Update Wa_22019338487
- [sasha] Let me analyze the code changes to understand what the issue is:
  **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Hardware Workaround Implementation**: This is updating the implementation of Wa_22019338487, which is a hardware workaround for specific Intel graphics hardware (BMG platform). The commit is improving the workaround implementation by:
     - Limiting GT frequency to 2600MHz during transient cache flushes
     - Adding synchronization to ensure frequency reduction happens before the flush
     - Preventing race conditions between user frequency requests and flush operations
  2. **Performance/Reliability Issue, Not Security**: The changes address:
     - Timing and synchronization issues during cache flush operations
     - Ensuring the GPU frequency is properly limited during specific hardware operations
     - Preventing potential hardware timing violations
  3. **No Security Boundary Violation**: The code changes show:
     - No privilege escalation paths
     - No memory corruption vulnerabilities
     - No information disclosure issues
     - No denial of service beyond potential hardware instability
  4. **Similar Commits Pattern**: Looking at the similar commits provided as reference (all marked "CVE Status: NO"), they all involve:
     - Hardware workaround implementations
     - Frequency management adjustments
     - Cache flushing improvements
     - Driver reliability enhancements
  5. **Nature of Fix**: The commit adds proper synchronization (`wait_for_flush_complete()`, `wait_for_act_freq_limit()`) and frequency management during transient display flushes. This is a reliability improvement to ensure hardware operates within its specifications during cache flush operations.
  The issue being fixed appears to be a potential hardware timing violation or cache coherency issue that could cause display corruption or system instability, but not a security vulnerability that would warrant a CVE assignment.
a5c7dcdd969f2 drm/xe/bmg: Update Wa_14022085890
- [sasha] Based on my analysis of this commit, here is my determination:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **Not a security fix**: The commit is implementing a hardware workaround (Wa_14022085890) for BMG (Battlemage) GPUs to set a minimum GT frequency to 1200MHz. This is a performance/stability tuning change, not a security vulnerability fix.
  2. **No security impact**: The code changes only adjust frequency bounds by setting a minimum frequency limit. This doesn't fix any:
     - Buffer overflows
     - Memory corruption issues
     - Access control vulnerabilities
     - Privilege escalation issues
     - Information disclosure vulnerabilities
  3. **Hardware workaround pattern**: The commit follows the standard pattern for GPU driver workarounds, which are typically required to work around hardware quirks or ensure proper functionality on specific hardware. The comment in the xe_wa_oob.rules file indicates this is a "SoC workaround" that applies to specific graphics versions.
  4. **Limited scope**: The change only affects frequency management for specific BMG hardware (GRAPHICS_VERSION(2001)) and simply ensures the minimum frequency doesn't drop below 1200MHz after driver load completion.
  5. **Similar commits pattern**: Looking at the provided similar commits with CVE Status: NO, they all share characteristics of being performance tuning changes, hardware workarounds, or documentation fixes - none of which constitute security vulnerabilities.
  The commit is a legitimate hardware workaround for ensuring proper GPU frequency behavior on specific hardware, with no security implications.
a1eec6cae95a1 drm/xe: Split xe_device_td_flush()
- [sasha] Based on my analysis of this commit, here is my assessment:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Pure refactoring**: The commit is splitting the `xe_device_td_flush()` function into two implementations (`tdf_request_sync()` and the existing `xe_device_l2_flush()`) without changing the actual functionality. The logic remains the same - it's just reorganized for clarity.
  2. **No security vulnerability fixed**: The commit message explicitly states it's making the code "clear by splitting the function". There's no mention of fixing any security issue, vulnerability, or bug that could be exploited.
  3. **No behavioral changes**: Looking at the code changes:
     - The original function had two paths: one for WA 16023588340 (L2 flush) and another for transient flush
     - The new code maintains the exact same logic, just moves the transient flush code into a separate `tdf_request_sync()` function
     - All the timeout values, register writes, and control flow remain identical
  4. **Display correctness, not security**: The flush operations are related to ensuring display coherency (preventing visual corruption when displaying from GPU memory), not fixing any security vulnerability like privilege escalation, information disclosure, or denial of service.
  5. **Similar commits pattern**: The similar commits provided (commits 1-5) are all marked as "CVE Status: NO" and involve similar display/GPU driver improvements, workarounds, or refactoring without security implications.
  This is a code quality improvement to make the workaround implementation clearer, not a security fix.
d8390768dcf6f drm/xe/guc_pc: Add _locked variant for min/max freq
- [sasha] Now, let me analyze the commit in detail:
  **NO**
  This commit does not warrant a CVE assignment. This is a code refactoring that introduces internal helper functions (`_locked` variants) to improve code organization and prevent potential deadlocks. Here's why:
  1. **No security vulnerability fixed**: The commit is purely a refactoring that adds `_locked` variants of existing functions. It doesn't fix any existing security vulnerability.
  2. **Code pattern improvement**: The change converts direct mutex operations to use the `guard(mutex)` pattern with C++ RAII-style automatic cleanup, and adds internal `_locked` helper functions that assume the lock is already held.
  3. **Prevention of future issues**: While the commit message mentions "there's a race possibility as calls are added outside of the early init," this is describing a potential future issue that could arise, not an existing vulnerability being fixed.
  4. **No exploitable condition**: The existing code already has proper locking - the issue mentioned is about multiple sequential lock/unlock operations from the same thread, which is inefficient but not a security vulnerability.
  5. **Similar to reference commits**: Looking at the similar commits provided:
     - Commit 1 (xe mem_access removal) - Not a CVE, just removing unnecessary protections
     - Commit 2 (xe gtidle locks) - Not a CVE, adding locks for proper synchronization
     - Commit 3 (xe documentation) - Not a CVE, just documentation
     - Commit 4 (xe rawclk_freq removal) - Not a CVE, removing unused code
     - Commit 5 (xe debug messages) - Not a CVE, adding debug logging
  This commit follows the same pattern as the reference commits - it's improving internal code structure and robustness but not fixing an actual security vulnerability.
d3e8349edf7ed drm/xe/guc: Enable w/a 16026508708
- [sasha] Based on my analysis of the commit, I can now provide my assessment:
  **NO**
  This commit should not be assigned a CVE. Here's my analysis:
  1. **Nature of the change**: This is a hardware workaround (w/a 16026508708) that resets the batch buffer (BB) stack pointer during Virtual Function (VF) switching in SRIOV environments. The commit message explicitly states it's a workaround, not a security fix.
  2. **Code analysis**: 
     - The change adds a new workaround ID `GUC_WA_KLV_RESET_BB_STACK_PTR_ON_VF_SWITCH` to the GuC firmware interface
     - It's conditionally enabled based on GuC firmware version (>= 70.44.0) and the workaround being applicable to the platform
     - The implementation uses `guc_waklv_enable_simple()` which just enables a flag without fixing any vulnerability
  3. **Similar to other workarounds**: The pattern matches other hardware workarounds in the same file (like `GUC_WORKAROUND_KLV_ID_BACK_TO_BACK_RCS_ENGINE_RESET`, `GUC_WA_KLV_WAKE_POWER_DOMAINS_FOR_OUTBOUND_MMIO`) which are functional/correctness fixes rather than security fixes.
  4. **Scope**: While it affects SRIOV (virtualization), the commit message indicates this is a general workaround that "does affect all platforms" - it's not fixing a security isolation issue between VFs but rather ensuring proper hardware state reset during VF switching for functional correctness.
  5. **No security context**: There's no indication in the commit message or code that this addresses any security vulnerability such as:
     - Information leakage between VFs
     - Privilege escalation
     - Memory corruption
     - Access control bypass
  This appears to be a standard hardware workaround to ensure proper GPU state management during virtualization context switches, similar to the other non-CVE workarounds shown in the similar commits.
2e0658940d90a netfs: Fix i_size updating
- [sasha] Based on my detailed analysis, I can now provide a definitive answer.
  **YES**, this commit should be assigned a CVE.
  The commit fixes a race condition in i_size updating that occurs when multiple threads perform DIO writes without proper locking. This is a security vulnerability because:
  1. **Data Corruption Risk**: The race condition can cause incorrect file size updates, potentially leading to data corruption or loss when files are truncated at wrong boundaries.
  2. **Information Disclosure**: If i_size is incorrectly set larger than the actual data, it could expose uninitialized memory or remnants of previous file content, creating an information leak vulnerability.
  3. **Critical Metadata**: File size (i_size) is critical metadata that affects security boundaries, access controls, and data integrity.
  4. **Network Attack Surface**: The bug particularly affects CIFS/SMB network filesystems, expanding the potential attack surface beyond local access.
  5. **Reproducible**: The xfstest generic/207 can trigger this bug, demonstrating it's not just theoretical but practically exploitable under the right conditions.
  The fix adds proper spin_lock protection around i_size updates in both `netfs_update_i_size()` and `netfs_cleanup_dio_write()`, preventing the race condition. This is a classic TOCTOU (Time-of-Check-Time-of-Use) vulnerability pattern that warrants CVE assignment.
74ee76bea4b44 smb: client: set missing retry flag in cifs_writev_callback()
- [sasha] Looking at this commit, I need to analyze whether it represents a security vulnerability fix.
  Let me examine the code changes:
  ```c
  case MID_REQUEST_SUBMITTED:
  case MID_RETRY_NEEDED:
  +	__set_bit(NETFS_SREQ_NEED_RETRY, &wdata->subreq.flags);
  	result = -EAGAIN;
  	break;
  ```
  The commit adds a single line that sets the `NETFS_SREQ_NEED_RETRY` flag when a write operation needs to be retried (when the mid state is `MID_REQUEST_SUBMITTED` or `MID_RETRY_NEEDED`).
  Key observations:
  1. **Nature of the fix**: This is fixing a missing retry flag that should have been set to properly inform netfslib that a subrequest needs to be retried. Without this flag, the retry mechanism wouldn't work correctly.
  2. **Security implications**: The absence of this flag could potentially lead to:
     - Write operations failing silently without proper retry
     - Data not being written to the server when it should be retried
     - Potential data loss or corruption scenarios
  3. **Comparison with similar commits**: Looking at the reference commits:
     - Similar Commit 3 (CVE: YES) fixed a server re-repick issue that caused misaccounting
     - Similar Commit 4 (CVE: YES) was the same fix as commit 3
     - Other commits without CVEs were generally adding features or improving retry logic
  4. **Impact assessment**: This fix addresses a functional correctness issue in the write path where operations that should be retried might not be, potentially leading to data integrity issues.
  **Decision: YES**
  This commit should be assigned a CVE because:
  1. It fixes a bug where write operations that need to be retried may not be properly flagged for retry
  2. This could lead to data integrity issues where writes fail silently without proper retry attempts
  3. The bug was introduced by a previous commit (ee4cdf7ba857) and represents a regression in functionality
  4. Data integrity issues in filesystem operations are typically considered security-relevant, especially in network filesystems where reliability is crucial
0e60bae24ad28 smb: client: set missing retry flag in cifs_readv_callback()
- [sasha] NO
  This commit should not be assigned a CVE. Here's why:
  1. **Nature of the fix**: The commit adds a missing flag (`NETFS_SREQ_NEED_RETRY`) in an error handling path for read operations. This is setting a retry flag when the mid state is `MID_REQUEST_SUBMITTED` or `MID_RETRY_NEEDED`.
  2. **No security boundary crossed**: The code change is in the error handling callback for CIFS read operations. It simply ensures that when certain error conditions occur (request submitted or retry needed), the netfs subsystem is properly notified to retry the operation.
  3. **Functional fix, not security fix**: This appears to be fixing a functional issue where read operations might not be properly retried when they should be. The commit message indicates this is fixing missing functionality introduced by a performance optimization ("netfs: Speed up buffered reading").
  4. **Similar to reference commits**: Looking at the similar commits provided:
     - Similar Commit 1 (CVE Status: NO) - Fixed callback handling for SMB1 readv/writev
     - Similar Commit 2 (CVE Status: NO) - Added replay flags for write command retries
     - Similar Commit 3 (CVE Status: YES) - Fixed server re-repick issue causing misaccounting
     - Similar Commit 4 (CVE Status: NO) - Added replay operation flags for retried commands
  The current commit is most similar to commits 1, 2, and 4, which were all marked as NO CVE. It's simply ensuring proper retry handling, not fixing a security vulnerability like misaccounting or resource management issues.
  5. **Code change analysis**: The single line added (`__set_bit(NETFS_SREQ_NEED_RETRY, &rdata->subreq.flags);`) is a straightforward flag setting operation that doesn't introduce or fix any security-relevant behavior like memory corruption, privilege escalation, or information disclosure.
e67e75edeb880 smb: client: set missing retry flag in smb2_writev_callback()
- [sasha] Based on my analysis of the code changes and context:
  **NO**
  This commit does not represent a security vulnerability. The change is a bug fix that adds a missing retry flag (`NETFS_SREQ_NEED_RETRY`) in the SMB write callback function when a retry is needed (cases `MID_REQUEST_SUBMITTED` or `MID_RETRY_NEEDED`).
  The issue is:
  1. **Functional bug, not security**: Without setting this flag, the netfs layer won't properly retry failed write operations that should be retried. This can lead to write operations failing when they should have been retried, but doesn't create a security vulnerability.
  2. **Consistency fix**: The read callback (`smb2_readv_callback`) already correctly sets this flag in the same cases, so this is fixing an inconsistency between read and write paths.
  3. **No privilege escalation or data exposure**: The missing flag simply means retryable write failures won't be retried. This could cause legitimate writes to fail, but doesn't allow unauthorized access, data corruption, or privilege escalation.
  4. **Error handling path**: This is in an error handling path where the operation already failed with `-EAGAIN`. The fix just ensures proper retry behavior.
  This is similar to the other non-CVE commits in the reference list that fix functional issues in the netfs/SMB subsystem without security implications.
97d8e8e52cb8a netfs: Fix ref leak on inserted extra subreq in write retry
- [sasha] Now I understand the issue. Looking at the code:
  1. **netfs_alloc_subrequest()** at line 190 sets the initial refcount to 2 (`refcount_set(&subreq->ref, 2);`)
  2. In the retry code path at line 156 (before the fix), there was an additional `netfs_get_subrequest(subreq, netfs_sreq_trace_get_resubmit)` which increments the refcount by 1
  3. This results in a refcount of 3, but only 2 references are properly released, causing a memory leak
  The fix removes the extra `netfs_get_subrequest()` call and replaces it with just a trace call, which doesn't affect the reference count.
  **CVE Status: NO**
  This is a reference counting bug that causes a memory leak in the netfs write retry path. While memory leaks can be problematic, this particular issue:
  1. Only occurs in specific error/retry conditions during write operations
  2. Does not allow for privilege escalation, code execution, or information disclosure
  3. Cannot be directly exploited by an unprivileged user to cause significant harm
  4. Is a resource leak that would require specific conditions to trigger repeatedly
  The bug is in kernel filesystem infrastructure code that handles write retries when there's insufficient capacity. While it's a legitimate bug that needs fixing, it doesn't meet the threshold for a CVE as it doesn't present a significant security vulnerability that can be exploited for malicious purposes.
09623e3a14c1c netfs: Fix looping in wait functions
- [sasha] Now I understand the issue. Let me analyze this:
  **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Nature of the bug**: This is an infinite loop condition in the netfs subsystem's wait functions where `netfs_collect_in_app()` returns 2 (indicating "try again") but the code continuously loops without checking if it should actually continue. The fix adds checks for `NETFS_RREQ_IN_PROGRESS` and `NETFS_RREQ_PAUSE` flags before continuing the loop.
  2. **No security boundary violation**: The infinite loop occurs in the context of the calling process/thread and doesn't cross security boundaries. It would cause the specific operation to hang but doesn't:
     - Allow unauthorized access to data
     - Enable privilege escalation
     - Cause system-wide denial of service
     - Leak sensitive information
  3. **Limited impact**: The bug affects only the specific thread/process performing the netfs operation. Other processes and the system as a whole continue to function normally. The impact is limited to a functional bug causing a hang in specific netfs operations.
  4. **Trigger conditions**: The bug requires specific timing conditions where:
     - Collection is not offloaded (`!OFFLOAD_COLLECTION`)
     - The `ALL_QUEUED` flag isn't set
     - No subrequests are left uncollected
     - The function returns 2 ("Again")
  5. **Similar commits analysis**: The similar commits shown (all marked "CVE Status: NO") are also fixes for synchronization, wait/wake consistency, and retry logic issues in the netfs subsystem - none were assigned CVEs because they represent functional bugs rather than security vulnerabilities.
  The commit is a legitimate bug fix for a potential infinite loop condition, but it doesn't meet the criteria for a security vulnerability requiring a CVE assignment.
da8cf4bd45872 netfs: Fix hang due to missing case in final DIO read result collection
- [sasha] Now let me analyze what the change actually does by looking at the modifications:
  The change adds:
  1. A new boolean variable `done = true` at line 384
  2. Additional logic in the loop to check if we're truly done:
     - If there's a subreq OR ALL_QUEUED is not set, then `done = false`
  3. Changes the sleep condition from `!need_collect && !inactive` to `!need_collect && !inactive && !done`
  This fixes a hang condition where:
  1. All subrequests have completed (empty list)
  2. ALL_QUEUED flag is set
  3. But `need_collect` is false and `inactive` is false
  4. The old code would return 0 (sleep), causing an infinite wait
  Based on my analysis:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Availability Impact Only**: This is a hang/DoS bug that affects availability but does not lead to memory corruption, privilege escalation, or information disclosure. The commit message clearly states it fixes a "hang".
  2. **No Security Boundary Crossed**: While the bug can be triggered through direct I/O reads (O_DIRECT flag) which any user can use, this appears to be a logic error in the collection state machine rather than a security vulnerability. The hang occurs in the requesting process itself.
  3. **Limited Attack Surface**: The bug requires specific timing conditions where:
     - DIO read subrequests fail and set the PAUSE flag
     - Collection completes before ALL_QUEUED is set
     - The specific missing case in `netfs_collect_in_app()` is hit
  4. **Self-DoS**: The hang appears to affect the process performing the I/O operation, not the entire system. This is more of a reliability/robustness issue than a security vulnerability.
  5. **Similar Pattern to Non-CVE Commits**: Looking at the similar commits provided (commits 1-4), none were assigned CVEs despite fixing various synchronization, collection, and wait/wake issues in the netfs subsystem. These were treated as regular bug fixes.
  The change fixes a missing case in the state machine logic where the function incorrectly decided to sleep when it should have proceeded with collection. This is a functional correctness issue rather than a security vulnerability.
2d5cff2b4bc56 drm/xe: Fix out-of-bounds field write in MI_STORE_DATA_IMM
- [sasha] Based on my analysis of this commit, I can now provide a comprehensive assessment:
  **NO**, this commit should not be assigned a CVE.
  Here's my reasoning:
  1. **Nature of the bug**: This is an off-by-one error in the maximum value calculation for the MI_STORE_DATA_IMM instruction. The code was using 0x1FF when it should use 0x1FE as the maximum number of PTEs (Page Table Entries) that can be written in a single instruction.
  2. **Hardware specification constraint**: According to the Bspec and the commit message, the MI_STORE_DATA_IMM instruction's "length" field must not exceed 0x3FE. The MI_SDI_NUM_QW(x) macro evaluates to `2 * x + 1`, so the maximum valid value for x is 0x1FE, not 0x1FF.
  3. **No security impact**: 
     - This is a hardware specification violation that would likely result in the GPU rejecting the command or behaving incorrectly, but not in a way that creates a security vulnerability
     - The batch buffer allocation is properly sized based on the `batch_size` calculation
     - There's no buffer overflow risk because the batch buffer is allocated with sufficient space (line 47-48 in xe_bb.c shows proper allocation)
     - The assertion at line 71 in xe_bb.c (`xe_gt_assert(q->gt, bb->len * 4 + bb_prefetch(q->gt) <= size)`) provides additional safety
  4. **Limited scope**: 
     - This only affects the Xe graphics driver's internal page table update mechanism
     - It's a correctness issue rather than a security vulnerability
     - The issue would manifest as potential GPU hangs or command rejection, not memory corruption or privilege escalation
  5. **Comparison with similar commits**: While the similar commits shown involve bounds checking and overflow prevention, they deal with actual memory safety issues (array bounds, integer overflows leading to incorrect memory allocations). This commit is different - it's ensuring compliance with hardware specifications rather than preventing memory safety issues.
  The fix ensures the driver complies with the GPU hardware specification, preventing potential GPU command rejection or malfunction, but does not address any security vulnerability.
0325143b59c6c igc: disable L1.2 PCI-E link substate to avoid performance issue
- [sasha] Based on my analysis of the commit, here is my assessment:
  **NO** - This commit should NOT be assigned a CVE.
  Here's my reasoning:
  1. **Nature of the issue**: This is a hardware performance limitation, not a security vulnerability. The commit message clearly states it's about preventing "packet loss and degraded performance" under high traffic conditions due to a hardware limitation with L1.2 exit latency.
  2. **Type of fix**: The fix disables a power-saving feature (PCI-E L1.2 substate) to improve performance. This is a performance optimization/workaround, not a security fix. The commit even notes that "the increased power draw between L1.1 and L1.2 is insignificant."
  3. **No security impact**: The code changes show:
     - Adding `pci_disable_link_state(pdev, PCIE_LINK_STATE_L1_2)` in three places (probe, resume, and error recovery)
     - This simply prevents the hardware from entering a specific low-power state
     - There's no fix for buffer overflows, access control, input validation, or any other security-relevant pattern
  4. **Similar commits without CVEs**: Looking at the similar commits provided as reference:
     - Similar Commit 1 (NO CVE): Fixed transmission scheduling latency - performance improvement
     - Similar Commit 2 (NO CVE): Fixed PCIe link training failures - hardware compatibility  
     - Similar Commit 3 (NO CVE): Made Intel DG2 L1 latency unlimited - performance workaround
     - Similar Commit 4 (NO CVE): Fixed L1 PM substates configuration order - hardware spec compliance
  5. **Hardware quirk**: This is a device-specific hardware limitation that requires a workaround to prevent performance degradation. It's not exploitable by an attacker and doesn't create any security risk.
  The only similar commit with a CVE (Similar Commit 5) was about an "unbalanced device enable/disable" which could potentially lead to system instability or crashes - a different class of issue entirely.
  This commit is purely a performance/reliability fix for a hardware limitation and does not address any security vulnerability.
b2beb5bb2cd90 idpf: convert control queue mutex to a spinlock
- [sasha] Looking at this commit, I need to analyze whether it fixes a security vulnerability.
  The commit fixes a "BUG: sleeping function called from invalid context" issue where `mutex_lock()` is called from an atomic context (with BH disabled and holding `dev->addr_list_lock`). The problematic call path is:
  ```
  idpf_set_rx_mode() -> # BH disabled, holding addr_list_lock
  idpf_add_del_mac_filters() ->
  idpf_send_mb_msg() ->
  idpf_mb_clean() ->
  idpf_ctlq_clean_sq() # tries to mutex_lock(cq_lock)
  ```
  The fix converts `cq_lock` from a mutex to a spinlock, which is safe to use in atomic contexts.
  Comparing with the similar commits provided:
  - All 5 similar commits that fixed "sleeping in atomic context" bugs were assigned CVE status: YES
  - They all follow the same pattern: fixing illegal sleep operations in atomic/IRQ contexts
  - The fixes typically involve converting mutexes to spinlocks or changing allocation flags
  **Answer: YES**
  This commit should be assigned a CVE because:
  1. It fixes a legitimate kernel bug that violates locking rules by attempting to sleep in an atomic context
  2. The bug can be triggered during normal network operations when VIRTCHNL2_CAP_MACFILTER is enabled
  3. This could lead to system instability, warnings, potential deadlocks, or crashes
  4. On RT kernels, the impact could be more severe as the sleeping violation would be enforced
  5. All similar commits fixing "sleeping in atomic context" issues were assigned CVEs
  6. The bug is in a network driver path that could potentially be triggered remotely through network traffic that causes MAC filter changes
  The security impact is primarily availability-related (potential DoS), which aligns with the CVE assignment pattern for similar kernel locking violations.
f77bf1ebf8ff6 idpf: return 0 size for RSS key if not supported
- [sasha] Now I understand the issue. Looking at the code:
  1. `idpf_get_rxfh_key_size()` and `idpf_get_rxfh_indir_size()` return `u32` but are returning `-EOPNOTSUPP` (negative value) when RSS is not supported
  2. In `rss_prepare_get()`, these values are assigned to `data->hkey_size` and `data->indir_size` which are `u32` (unsigned) 
  3. When `-EOPNOTSUPP` is cast to `u32`, it becomes a very large positive value (around 4 billion)
  4. This large value is then used to calculate `total_size` for memory allocation: `total_size = indir_bytes + data->hkey_size`
  5. The kernel tries to allocate this huge amount of memory, which fails and triggers the warning
  **CVE Analysis:**
  **NO** - This commit should NOT be assigned a CVE.
  **Reasoning:**
  1. **No security boundary crossed**: This is a bug that causes incorrect behavior and a kernel warning, but it does not cross any security boundaries or allow privilege escalation.
  2. **No memory corruption**: While the bug causes an attempt to allocate excessive memory, the kernel's memory allocation safeguards catch this and fail safely with a warning. There's no actual memory corruption or overflow.
  3. **No information disclosure**: The bug doesn't leak any sensitive information.
  4. **No denial of service**: While the bug produces a warning/call trace, it doesn't crash the system or make it unusable. The ethtool command simply fails gracefully.
  5. **Limited impact**: The issue only affects the ethtool interface for querying RSS configuration on devices that don't support RSS. It's a functional bug rather than a security vulnerability.
  The fix correctly changes the return value from `-EOPNOTSUPP` to `0` for these functions when RSS is not supported, which is the proper way to indicate "no RSS key/table" rather than an error condition. This prevents the type confusion between signed error codes and unsigned size values.
d6811074203b1 nvme-multipath: fix suspicious RCU usage warning
- [sasha] Based on my analysis, I can now provide a determination.
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Not a security vulnerability**: This is a lockdep warning fix for incorrect RCU usage. The issue is that `list_for_each_entry_rcu()` was used while holding an SRCU lock instead of a regular RCU lock.
  2. **Only affects debugging/validation**: The warning only appears with `CONFIG_PROVE_RCU=y` enabled, which is a debugging feature. The actual runtime behavior is correct because:
     - The list is properly protected by SRCU lock (srcu_read_lock(&head->srcu))
     - The code was using the wrong traversal primitive but the protection was still valid
  3. **No security impact**: The fix changes from `list_for_each_entry_rcu()` to `list_for_each_entry_srcu()` with the proper condition check. This is purely a correctness fix to use the appropriate RCU primitive that matches the lock type being held.
  4. **Similar to other non-CVE commits**: Looking at Similar Commits 2 and 3 which have similar patterns (fixing RCU list traversal warnings in NVMe code), both were marked as "CVE Status: NO". They follow the same pattern of fixing lockdep warnings by using the correct SRCU primitive.
  The commit simply corrects the RCU annotation to match the actual locking mechanism being used (SRCU vs regular RCU), eliminating a false positive warning without any security implications.
8cadce97bf264 drm/i915/gsc: mei interrupt top half should be in irq disabled context
- [sasha] Now I have enough context to make a decision. Let me analyze the key aspects:
  **NO**
  This commit should not be assigned a CVE because:
  1. **Not a security vulnerability**: The issue is a functional bug that causes GPU boot hangs specifically with RT (Real-Time) kernels. It's not exploitable for malicious purposes and doesn't compromise security boundaries.
  2. **RT kernel-specific issue**: The problem only manifests when using PREEMPT_RT kernels where interrupt handlers run in threaded context. Standard kernels are not affected.
  3. **Interrupt context handling issue**: The fix changes `generic_handle_irq()` to `generic_handle_irq_safe()` to ensure proper interrupt context handling. The `_safe` variant adds `local_irq_save/restore` to disable interrupts, which is needed when the handler might run in process context (as happens with RT kernels).
  4. **Similar non-CVE fixes**: The similar commits shown in the history (e.g., commit c6a91405ac5c for intel_int0002_vgpio, commit 94ec234a16cf for bcma gpio) that made the same type of fix were not assigned CVEs, as they are correctness fixes for RT kernel compatibility rather than security issues.
  5. **No security impact**: The bug causes a boot hang/denial of service only for the system owner trying to use an RT kernel with specific Intel GPUs (A380/A770). There's no privilege escalation, information disclosure, or ability for an attacker to exploit this issue.
  This is a correctness fix for RT kernel compatibility, not a security vulnerability fix.
a5aa7bc1fca78 drm/i915/gt: Fix timeline left held on VMA alloc error
- [sasha] Looking at this commit, I need to analyze whether it fixes a security vulnerability that warrants a CVE assignment.
  Let me examine the commit details:
  **What the commit fixes:**
  - A memory leak where a timeline reference is held incorrectly when VMA allocation fails
  - This causes objects to remain allocated when the driver is unbound
  - The issue is triggered by signal interruption during `DRM_IOCTL_I915_GEM_EXECBUFFER2`
  **Root cause:**
  In `ring_context_alloc()`, the code was getting a reference to the timeline before allocating the VMA:
  ```c
  ce->timeline = intel_timeline_get(engine->legacy.timeline);
  // ... then VMA allocation
  ```
  If VMA allocation failed (e.g., interrupted by signal), the timeline reference was leaked.
  **The fix:**
  Simply reorders the operations to get the timeline reference only after successful VMA allocation:
  ```c
  // First allocate VMA
  if (engine->context_size) {
      vma = alloc_context_vma(engine);
      if (IS_ERR(vma))
          return PTR_ERR(vma);
      ce->state = vma;
  }
  // Then get timeline reference
  ce->timeline = intel_timeline_get(engine->legacy.timeline);
  ```
  **Security implications:**
  This is a memory/resource leak that occurs when:
  1. A userspace process makes an ioctl call
  2. The operation is interrupted by a signal
  3. Internal allocation fails
  The leak persists until driver unbind/module unload. While this could theoretically be exploited to exhaust kernel memory through repeated failed operations, it requires:
  - Local access to make ioctl calls
  - Ability to send signals at precise timing
  - The leak is relatively small (timeline objects)
  - The impact is limited to resource exhaustion
  **Comparison with similar commits:**
  Looking at the provided similar commits with "CVE Status: NO", they involve:
  - Code refactoring and cleanup (commits 1, 2, 3)
  - Buffer overflow fixes in controlled environments (commit 4)
  - Logic fixes for internal operations (commit 5)
  None of these were assigned CVEs despite some fixing actual bugs.
  **Conclusion:**
  **NO**
  This commit fixes a memory leak bug that requires local access and specific timing conditions to trigger. While it's a legitimate bug fix, it doesn't meet the threshold for a CVE assignment because:
  1. It requires local access to the GPU device to trigger
  2. The leak is relatively small and would require many iterations to have significant impact
  3. It's more of a quality/stability issue than a security vulnerability
  4. The impact is limited to potential resource exhaustion, not privilege escalation, information disclosure, or code execution
  5. Similar memory leak fixes in the kernel are typically not assigned CVEs unless they have more severe security implications
  The fix is important for driver stability and preventing resource leaks, but doesn't represent a significant security vulnerability warranting a CVE.
7dfede7d7edd1 drm/vmwgfx: Fix guests running with TDX/SEV
- [sasha] Based on my analysis, I'll now provide my CVE assessment:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **No security vulnerability introduced**: The code change fixes a functional breakage, not a security vulnerability. The issue is that after commit 81256a50aa0f changed the default behavior of `memremap(MEMREMAP_WB)` to map memory as encrypted, the vmwgfx driver broke because it needs FIFO memory to be decrypted for communication with the VMware hypervisor.
  2. **Guest-host communication requirement**: The FIFO memory region at line 752 is used for legitimate guest-to-host communication in virtualized environments. The driver explicitly needs this memory to be decrypted (shared with the hypervisor) to function properly - this is not a security flaw but an architectural requirement.
  3. **Explicit declaration of intent**: The fix adds `MEMREMAP_DEC` flag to explicitly declare that this memory region should be decrypted/shared. This is the correct and intended usage of the API - making explicit what was previously implicit behavior.
  4. **No information disclosure**: While the referenced commit mentions that "Creating a decrypted mapping without explicit request from the caller is risky", in this case the vmwgfx driver legitimately requires decrypted mapping for its FIFO communication channel with the hypervisor. This is not exposing sensitive guest data but rather establishing a necessary communication channel.
  5. **Functional fix, not security fix**: The commit message clearly indicates this fixes guests "running with TDX/SEV" - it's restoring functionality that was broken by an API behavior change, not fixing a security vulnerability.
  The similar commits provided as reference (all marked CVE Status: NO) also deal with encryption/decryption settings and driver functionality without introducing security vulnerabilities.
6c7ffc9af7186 net: usb: lan78xx: fix WARN in __netif_napi_del_locked on disconnect
- [sasha] **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Nature of the bug**: This is a programming error that causes a WARN() to trigger during driver unload, not a security vulnerability. The WARN occurs because `netif_napi_del()` is called on a NAPI instance that is still enabled (line 7378 in net/core/dev.c checks that NAPI_STATE_SCHED is NOT set).
  2. **No security impact**: The issue only manifests as a kernel warning during USB device disconnection. There's no:
     - Memory corruption
     - Information disclosure
     - Privilege escalation
     - Denial of service (beyond the warning message)
     - Remote exploitation possibility
  3. **Root cause**: The problem is a redundant call to `netif_napi_del()` in the disconnect path (line 4570). The NAPI instance gets properly cleaned up by `unregister_netdev()` at line 4575, which internally handles NAPI teardown. The driver was incorrectly trying to delete NAPI before it was disabled, causing the warning.
  4. **Similar to non-CVE commits**: This follows the pattern of commit 5 in the reference list (mcp251xfd driver) which was marked "CVE Status: NO" - it also fixed ordering issues in the cleanup path without security implications.
  The fix simply removes the redundant `netif_napi_del()` call, allowing the proper cleanup sequence through `unregister_netdev()`. This is a code correctness fix, not a security fix.
3bbe46716092d smb: client: fix warning when reconnecting channel
- [sasha] I can see that the dummy tcon is created with `tcon_info_alloc()` but it doesn't go through the normal initialization path where `INIT_DELAYED_WORK(&tcon->query_interfaces, smb2_query_server_interfaces)` is called. This means the `query_interfaces` delayed work is uninitialized.
  Now let me analyze the fix in the current commit:
  Based on my analysis, I can now provide my assessment:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Nature of the Issue**: This is a kernel warning (WARN_ON_ONCE) caused by calling `queue_delayed_work()` on an uninitialized delayed work structure. The warning occurs at kernel/workqueue.c:2498 where it checks `WARN_ON_ONCE(timer->function != delayed_work_timer_fn)`.
  2. **Root Cause**: When reconnecting channels, a dummy tcon structure is allocated via `tcon_info_alloc()` but the `query_interfaces` delayed work is never initialized with `INIT_DELAYED_WORK()`. This dummy tcon is then passed to `smb2_reconnect()` which tries to queue the uninitialized delayed work after commit 42ca547b13a2 added unconditional queuing.
  3. **Security Impact**: This is a functional bug that causes a warning, not a security vulnerability. There is:
     - No memory corruption
     - No privilege escalation
     - No information disclosure
     - No denial of service beyond the warning message
     - No way for an attacker to exploit this
  4. **The Fix**: The fix simply adds a check `if (!tcon->ipc && !tcon->dummy)` before calling `queue_delayed_work()` to avoid queuing work on dummy tcons that don't have properly initialized delayed work structures.
  5. **Similar Commits Analysis**: Looking at the similar commits provided:
     - The commits marked as "CVE Status: YES" involved actual UAF (Use-After-Free) vulnerabilities where memory could be accessed after being freed
     - This commit only prevents a warning from triggering on uninitialized data, which is fundamentally different
  This is a quality/stability fix for a warning condition, not a security vulnerability fix.
e8537cad82406 drm/bridge: aux-hpd-bridge: fix assignment of the of_node
- [sasha] Based on my analysis, here's my assessment:
  **NO**
  This commit should NOT be assigned a CVE. While it fixes a functional issue that can cause probe failures, it does not represent a security vulnerability. Here's why:
  1. **No Security Impact**: The issue is purely a functional bug where pinctrl resources fail to be properly claimed due to missing the `of_node_reused` flag. This causes device probe failures with error messages like "pin already requested", but does not create any security vulnerabilities.
  2. **Resource Management Issue**: The bug prevents proper device initialization when an aux-hpd-bridge shares its parent's device tree node. Without setting `of_node_reused = true`, the pinctrl subsystem attempts to claim pins that are already owned by the parent device, resulting in -EBUSY errors.
  3. **Similar to Reference Commits**: Looking at the similar commits marked "CVE Status: NO" (commits 85e444a68126 and 51474ab44abf907023a8a875e799b07de461e466), they fix the exact same type of issue - missing `of_node_reused` flag causing resource conflicts. These were correctly not assigned CVEs.
  4. **No Exploitable Condition**: The issue manifests as probe failures during device initialization. There's no memory corruption, privilege escalation, information disclosure, or any other security-relevant impact. The worst outcome is that a display bridge fails to initialize properly.
  5. **Defensive Check**: The pinctrl subsystem's check (line 25-26 in pinctrl.c) that skips binding when `of_node_reused` is set is a defensive mechanism to prevent resource conflicts in legitimate device tree sharing scenarios, not a security boundary.
  The commit is a proper bug fix for device initialization issues but lacks any security implications that would warrant CVE assignment.
eb028cd884e1b drm/bridge: panel: move prepare_prev_first handling to drm_panel_bridge_add_typed
- [sasha] Let me look at the commit message more carefully to understand the actual impact:
  Based on my analysis of the commit message and code changes, here's my assessment:
  **NO**
  This commit should NOT be assigned a CVE because:
  1. **No Security Impact**: The bug is a functional issue where the `prepare_prev_first` flag is not properly propagated when drivers call `drm_panel_bridge_add_typed()` directly. This affects the initialization order of DSI (Display Serial Interface) bridges and panels, but does not introduce any security vulnerabilities.
  2. **Functional Bug Only**: The `prepare_prev_first` flag controls the initialization order between DSI host controllers and panels. When not set correctly, it may cause display initialization failures on certain hardware (particularly DSI panels that require the host to be in LP-11 state before panel power-up), but this is a display functionality issue, not a security issue.
  3. **No Memory Safety Issues**: The code changes simply move the line `panel_bridge->bridge.pre_enable_prev_first = panel->prepare_prev_first;` from two specific functions (`devm_drm_panel_bridge_add_typed` and `drmm_panel_bridge_add`) to the common function `drm_panel_bridge_add_typed()`. This ensures consistent behavior regardless of which API is used, but doesn't fix any memory corruption, privilege escalation, or other security-relevant issues.
  4. **Limited Impact**: The bug only affects drivers that:
     - Use panels with `prepare_prev_first` set to true
     - Call `drm_panel_bridge_add_typed()` directly instead of using the devm_ or drmm_ variants
     - This is a relatively small subset of drivers (found 13 files using this function)
  5. **Similar to Non-CVE Commits**: The similar commits shown (especially commits 1-3) all deal with similar DRM panel/bridge initialization ordering issues and were marked as "CVE Status: NO".
  The commit fixes a legitimate bug that could cause display initialization failures on affected hardware, but it's purely a functional fix without any security implications.
644bec18e705c platform/mellanox: mlxreg-lc: Fix logic error in power state check
- [sasha] Based on my analysis:
  **NO**
  This commit fixes a logic error but does not address a security vulnerability. Here's why:
  1. **Logic Error Analysis**: The bug is in the condition `if (mlxreg_lc->state & ~MLXREG_LC_POWERED)` which incorrectly evaluates to true when ANY bit is set (except MLXREG_LC_POWERED). The fix correctly changes it to `if (!(mlxreg_lc->state & MLXREG_LC_POWERED))` to properly check if the POWERED bit is NOT set.
  2. **Impact**: The bug causes `mlxreg_lc_power_on_off(mlxreg_lc, 1)` to be called even when the line card is already powered (when MLXREG_LC_POWERED is set), leading to redundant power-on operations. This is inefficient but not a security issue.
  3. **No Security Boundaries Crossed**: The code operates on hardware control registers for Mellanox line cards in a data center environment. The redundant power-on operations don't:
     - Allow privilege escalation
     - Expose sensitive data
     - Enable unauthorized access
     - Cause memory corruption or overflow
     - Create race conditions that could be exploited
  4. **Limited Attack Surface**: This is platform-specific driver code for specialized hardware (Nvidia/Mellanox MSN4800 line cards). An attacker would need physical access to the hardware or already have kernel-level privileges to interact with this driver.
  5. **Comparison to Similar Commits**: Unlike the CVE-assigned commits in the examples which fixed race conditions in locking (which could lead to use-after-free or deadlocks), this is purely a functional logic error without security implications.
  The commit is a valid bug fix that improves code correctness and efficiency, but it does not meet the criteria for CVE assignment as it doesn't fix a vulnerability that could be exploited for malicious purposes.
314e5ad4782d0 platform/x86: dell-wmi-sysman: Fix class device unregistration
- [sasha] **NO**
  While this commit fixes a real bug, it does not warrant a CVE assignment. Here's my analysis:
  1. **Nature of the bug**: The issue is that `device_destroy()` searches for devices by `dev_t` (device number), and when multiple drivers use `MKDEV(0, 0)` with the same class, it could potentially destroy the wrong device. However, this is primarily a correctness issue rather than a security vulnerability.
  2. **No security boundary crossed**: The bug affects kernel driver cleanup paths during module unload/error handling. There's no privilege escalation, information disclosure, or ability for unprivileged users to trigger the issue.
  3. **Limited impact**: The issue only manifests during driver unload or error paths, not during normal operation. Even if the wrong device is destroyed, it would likely cause a system crash or driver malfunction rather than a exploitable security condition.
  4. **Pattern comparison**: Looking at the similar commits provided:
     - The commits marked "CVE Status: YES" involved:
       - Use-after-free with clear security implications (firmware loader)
       - Oops/crashes that could be triggered by unprivileged users
     - This commit is more similar to the "CVE Status: NO" commits that fix cleanup/unregistration issues without security impact
  5. **Code analysis**: The change from `device_destroy(&firmware_attributes_class, MKDEV(0, 0))` to `device_unregister(wmi_priv.class_dev)` is a correctness fix to ensure the right device is unregistered, but doesn't fix a security vulnerability.
  This is a quality/stability fix rather than a security fix, similar to the "platform/x86: dell-sysman: add support for alienware products" and "soc: imx8m: Unregister cpufreq and soc dev in cleanup path" commits that were marked as non-CVE.
5ff1fbb305973 platform/x86: think-lmi: Fix class device unregistration
- [sasha] Based on my analysis of the commit and the kernel code, here's my assessment:
  **NO** - This commit should not be assigned a CVE.
  While this is a legitimate bug fix, it does not meet the threshold for a CVE assignment for the following reasons:
  1. **Limited Attack Surface**: The issue requires the ability to load and unload kernel modules, which typically requires root privileges. An attacker with this level of access already has full system control.
  2. **Hardware Mutual Exclusivity**: The affected drivers (think-lmi, dell-wmi-sysman, hp-bioscfg, samsung-galaxybook) are hardware-specific and naturally mutually exclusive. A system would typically only have one type of firmware interface, making concurrent loading of multiple drivers extremely unlikely in real-world scenarios.
  3. **No Direct Security Boundary Crossing**: Unlike the CVE-assigned similar commits which involved clear use-after-free conditions or system crashes, this issue would only manifest if multiple firmware attribute drivers were somehow loaded simultaneously - a scenario that doesn't occur in practice due to hardware detection checks.
  4. **Defensive Programming Fix**: The change from `device_destroy()` to `device_unregister()` is more about using the correct API for the intended purpose rather than fixing an exploitable vulnerability. The original code worked correctly in all practical scenarios.
  5. **No Privilege Escalation or Information Disclosure**: Even if the wrong device were destroyed, it would not enable privilege escalation or information disclosure - it would at worst cause system instability requiring already-elevated privileges to trigger.
  The fix is important for code correctness and preventing potential issues in hypothetical scenarios, but it doesn't represent a security vulnerability that warrants CVE assignment.
11cba4793b95d platform/x86: hp-bioscfg: Fix class device unregistration
- [sasha] Based on my analysis, I need to provide my assessment:
  **NO**
  This commit does not warrant a CVE assignment. Here's my analysis:
  1. **Nature of the fix**: The commit changes from `device_destroy()` to `device_unregister()` for proper cleanup of devices under the firmware_attributes_class. This is a correct API usage fix rather than a security vulnerability fix.
  2. **No security impact**: Looking at the code:
     - `device_destroy()` searches for a device by dev_t (MKDEV(0,0)) and then calls `device_unregister()` on it
     - Since firmware_attributes_class devices don't have unique dev_t values (all use MKDEV(0,0)), `device_destroy()` could potentially match and destroy the wrong device
     - However, this is not exploitable as a security vulnerability - it's an incorrect API usage that could cause improper cleanup
  3. **No use-after-free vulnerability**: While the commit message mentions that device_destroy() "may match any device with a given dev_t", this doesn't create a use-after-free condition. The worst case would be destroying the wrong device during module cleanup, which would be a functionality bug, not a security issue.
  4. **Limited scope**: This issue only affects the cleanup path during module exit (`hp_exit()`) and error handling during initialization. There's no path for an attacker to trigger this condition or gain any advantage from it.
  5. **Comparison with similar commits**: Unlike the CVE-assigned commits in the examples which fixed actual use-after-free vulnerabilities with security implications (accessing freed memory, race conditions), this commit merely ensures the correct device is unregistered during cleanup.
  The fix improves code correctness by using the appropriate API (`device_unregister()` which takes a device pointer directly rather than searching by dev_t), but does not address any security vulnerability.
eb617dd25ca17 platform/x86: dell-wmi-sysman: Fix WMI data block retrieval in sysfs callbacks
- [sasha] Now I understand the vulnerability. Looking at the commit being analyzed:
  **YES**
  This commit should be assigned a CVE because it fixes a security vulnerability where the driver fails to properly validate WMI data blocks retrieved from firmware before dereferencing them. Specifically:
  1. **The vulnerability**: In the original code (lines 26-30 in enum-attributes.c), the driver directly accesses `obj->package.elements[CURRENT_VAL]` without first checking if `obj` is actually a package type or if it contains enough elements. This can lead to out-of-bounds memory access if the firmware returns malformed data.
  2. **Security impact**: This is a kernel vulnerability that could potentially be exploited by:
     - Malicious firmware providing crafted WMI data blocks
     - Local attackers who can manipulate firmware responses
     - Leading to kernel crashes (DoS) or potentially information disclosure/privilege escalation
  3. **The fix adds proper validation**:
     - Checks `obj->type != ACPI_TYPE_PACKAGE` to ensure the object is a package
     - Checks `obj->package.count < MIN_ELEMENTS` to ensure the package has enough elements before accessing them
     - This prevents out-of-bounds access when dereferencing array elements
  4. **Similar to CVE-assigned commits**: This follows the same pattern as the "dell-wmi-sysman: Avoid buffer overflow in current_password_store()" commit (4e89a4077490) which was assigned a CVE for fixing a buffer overflow vulnerability in the same driver.
  The vulnerability allows untrusted input (WMI data from firmware) to cause kernel memory safety issues, which is a classic security vulnerability pattern requiring a CVE assignment.
14005c96d6649 nvme-pci: refresh visible attrs after being checked
- [sasha] Based on my analysis of the commit and the kernel code, here is my determination:
  **NO**
  This commit does not warrant a CVE assignment. Here's why:
  1. **Not a security vulnerability**: The issue is about sysfs attribute visibility - specifically, the CMB (Controller Memory Buffer) and HMB (Host Memory Buffer) attributes were being shown/hidden incorrectly in sysfs. This is a functional bug, not a security issue.
  2. **No security impact**: The commit simply moves a call to `nvme_update_attrs()` to ensure sysfs attributes are refreshed after HMB setup. The previous location only handled CMB attributes but missed HMB attributes. This visibility issue:
     - Does not allow unauthorized access
     - Does not cause memory corruption
     - Does not lead to privilege escalation
     - Does not expose sensitive information
  3. **Code changes analysis**: 
     - The commit removes `nvme_update_attrs(dev)` from `nvme_map_cmb()` function
     - It adds the same call after `nvme_setup_host_mem(dev)` in two places (probe and reset paths)
     - This ensures both CMB and HMB attributes have correct visibility in sysfs
  4. **Similar to non-CVE commits**: Looking at the similar commits provided, the non-CVE examples like "nvmem: core: only change name to fram for current attribute" also deal with sysfs attribute handling without security implications.
  The issue is purely about correct representation of device capabilities in sysfs - whether certain attributes should be visible or not based on hardware support. This is a user interface/functionality issue, not a security vulnerability.
190f4c2c863af nvmet: fix memory leak of bio integrity
- [sasha] Now I have enough information to analyze this commit. Let me summarize what I've found:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Memory Leak of Sensitive Data**: The commit fixes a continuous memory leak in the `kmalloc-128` slab, specifically leaking `bio->bi_integrity` structures. This is a resource exhaustion vulnerability that can lead to denial of service.
  2. **Security-Relevant Component**: The leak occurs in the NVMe target subsystem when handling commands with metadata/integrity information. Bio integrity payloads can contain sensitive metadata that protects data integrity.
  3. **Root Cause**: After commit bf4c89fc8797 removed the automatic `bio_uninit()` call from `bio_endio()`, users of `bio_init()` must explicitly call `bio_uninit()` to free resources. The NVMe target code was using `bio_init()` for inline bios but never calling `bio_uninit()`, causing the integrity payload to leak.
  4. **Impact**: 
     - Continuous memory leak when processing NVMe commands with metadata
     - Potential system memory exhaustion over time
     - Affects data integrity protection mechanisms
  5. **Similar to CVE-assigned commits**: This is similar to the memory leak fixed in Similar Commit 3 (nvmet: fix a memory leak) which was assigned a CVE. Both involve memory leaks in the NVMe target subsystem.
  The fix properly adds `bio_uninit(bio)` in the `nvmet_req_bio_put()` function for inline bios, ensuring that bio integrity payloads are freed when the bio is released.
2e96d2d8c2a7a nvme: Fix incorrect cdw15 value in passthru error logging
- [sasha] **NO**
  This commit should not be assigned a CVE. This is a simple typo fix in error logging output where `cdw14` was mistakenly printed twice instead of printing `cdw15`. 
  The bug only affects the diagnostic error messages shown to administrators when passthrough commands fail - it prints the wrong value for one field in the error log. This has no security implications:
  1. **No security boundary crossed**: The bug only affects logging output, not any security-critical functionality
  2. **No information disclosure**: It doesn't expose sensitive information - it just prints the wrong command field value (cdw14 instead of cdw15)
  3. **No system integrity impact**: The actual command execution and error handling are unaffected
  4. **Diagnostic only**: This only impacts troubleshooting/debugging information shown in kernel logs
  The similar commits analyzed also show a pattern - they are all bug fixes for NVMe functionality (error handling, status parsing, etc.) but none were assigned CVEs because they don't represent security vulnerabilities. This commit follows the same pattern - it's a quality/correctness fix, not a security fix.
caa7c7a76b78c drm/i915/selftests: Change mock_request() to return error pointers
- [sasha] Now I can see the issue. Looking at the code:
  1. Line 372: `rq = t->request_alloc(ce);` - This calls the function pointer which could be `__mock_request_alloc()`
  2. Line 374: `if (IS_ERR(rq))` - This checks if rq is an error pointer
  3. The old `__mock_request_alloc()` would return the result of `mock_request()`, which could return NULL on allocation failure
  4. The code only checks for `IS_ERR(rq)` but not for NULL
  5. If NULL was returned, line 380-381 would dereference NULL when accessing `rq->submit`
  **NO**
  This is a bug fix in self-test code (`selftests/` directory) that would only affect kernel developers running internal tests, not production systems. The issue is:
  1. **Location**: The bug is entirely within the i915 driver's self-test infrastructure (`drivers/gpu/drm/i915/selftests/`)
  2. **Impact**: Would only cause a NULL pointer dereference during developer testing, not in production use
  3. **Scope**: Self-tests are not part of the normal kernel execution path and are typically only run by developers or in CI environments
  While this is indeed a NULL pointer dereference bug that could crash the kernel during testing, CVEs are typically not assigned to bugs in test/debug code that don't affect production systems or end users. The `selftests/` directory contains code specifically designed for testing the driver's functionality and is not executed during normal system operation.
fa60c094c19b9 spi: spi-fsl-dspi: Clear completion counter before initiating transfer
- [sasha] Based on my analysis, I'll now provide my assessment:
  **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Not a Security Vulnerability**: This is a race condition bug that affects functionality and data integrity in SPI transfers, but it does not represent a security vulnerability. The issue causes:
     - Immediate completion of transfers without actually performing them
     - Data not being written to RX buffers
     - Functional incorrectness in SPI communications
  2. **Limited Impact Scope**: The race condition only occurs in specific circumstances:
     - SPI target (slave) mode operation
     - When extra interrupts are received between transfers
     - When the host continues sending data after a transfer completes
     - The timing window is narrow and requires specific conditions
  3. **No Security Boundaries Crossed**: The bug does not:
     - Allow privilege escalation
     - Enable unauthorized access to memory
     - Cause memory corruption that could be exploited
     - Lead to information disclosure
     - Create denial of service conditions beyond functional failure
  4. **Data Integrity vs Security**: While the bug can cause incorrect data transfers (RX buffer not being filled), this is a data integrity/functionality issue rather than a security vulnerability. The corrupted data stays within the expected SPI communication boundaries.
  5. **Similar Commits Analysis**: Looking at the similar commits:
     - Commit 2 (microchip-core FIFO clearing) was assigned a CVE likely due to potential information leakage from reading stale data
     - Commit 3 (sun6i DMA race) was assigned a CVE likely due to memory corruption concerns
     - This commit differs as it doesn't involve memory corruption or information leakage, just functional failure
  The fix simply moves the `reinit_completion()` call before the transfer starts to ensure the completion counter is cleared, preventing false signaling. This is a straightforward functional fix without security implications.
d85d0380292a7 spi: spi-qpic-snand: reallocate BAM transactions
- [sasha] Now I understand the issue. Let me analyze the security implications:
  **YES**
  This commit fixes a critical memory corruption vulnerability that can lead to:
  1. **Out-of-bounds memory access**: The driver initially allocates BAM transaction memory for only 1 codeword (`nandc->max_cwperpage = 1` at line 729 in qcom_nandc_alloc), but later when the actual NAND chip is detected, it may require more codewords based on the page size. The allocation size is calculated based on `num_cw` (number of codewords) in `qcom_alloc_bam_transaction()`.
  2. **Memory corruption symptoms described in the commit**:
     - swiotlb buffer overflow with size 4294967294 bytes (likely an integer underflow)
     - NULL pointer dereferences on reboot
     - Spinlock corruption with bad magic values
     - Virtual address access violations
  3. **Security impact**: The out-of-bounds writes can corrupt kernel memory structures, potentially leading to:
     - Kernel crashes and denial of service
     - Potential privilege escalation if attacker can control the corrupted memory
     - System instability
  The fix properly reallocates the BAM transaction buffer after determining the actual number of codewords needed:
  ```c
  +	/*
  +	 * Free the temporary BAM transaction allocated initially by
  +	 * qcom_nandc_alloc(), and allocate a new one based on the
  +	 * updated max_cwperpage value.
  +	 */
  +	qcom_free_bam_transaction(snandc);
  +
  +	snandc->max_cwperpage = cwperpage;
  +
  +	snandc->bam_txn = qcom_alloc_bam_transaction(snandc);
  ```
  This is similar to the CVE-assigned commit "spi: spi-zynqmp-gqspi: return -ENOMEM if dma_map_single fails" which also involved memory safety issues in SPI drivers that could lead to kernel crashes and memory corruption.
5d91394f23616 drm/exynos: fimd: Guard display clock control with runtime PM calls
- [sasha] Now let me analyze the security implications of this commit:
  **NO**
  This commit is a runtime PM (power management) synchronization fix that prevents a lockup when the `fimd_dp_clock_enable()` function is called before the FIMD device is runtime resumed. The issue is:
  1. **Nature of the fix**: This is a power management ordering issue, not a security vulnerability. The function was being called when the device wasn't properly resumed, causing a lockup on Samsung Chromebooks.
  2. **Impact**: The issue causes a system lockup/hang, which is a reliability/availability issue rather than a security vulnerability. There's no:
     - Memory corruption
     - Privilege escalation
     - Information disclosure
     - Buffer overflow
     - Access control bypass
  3. **Root cause**: The commit c9b1150a68d9 changed the bridge pre_enable/post_disable call sequence, causing these methods to be called when the CRTC is not yet enabled. This exposed a latent dependency issue where `fimd_dp_clock_enable()` needed the device to be runtime resumed.
  4. **Fix mechanism**: The patch adds:
     - Runtime PM get/put calls around the register write
     - A state tracking field (`dp_clk_enabled`) to avoid redundant operations
     - Proper synchronization to ensure the device is powered when accessing hardware registers
  5. **Similar commits analysis**: Looking at the provided similar commits:
     - Similar Commit 1 & 2 (CVE Status: NO) deal with runtime PM and clock management issues
     - Similar Commit 3 (CVE Status: YES) introduced a deadlock between genpd and clock frameworks, which is more complex but still primarily a reliability issue
  This is a standard device driver power management fix that ensures proper hardware state before register access. It does not involve any security-sensitive operations or expose any attack vectors.
2def09ead4ad5 dpaa2-eth: fix xdp_rxq_info leak
- [sasha] Based on my analysis of the commit and the code, I can now provide my assessment:
  **NO**
  This commit should not be assigned a CVE. Here's my reasoning:
  1. **Resource Leak, Not Security Vulnerability**: The commit fixes a resource leak where `xdp_rxq_info` structures were registered but not properly unregistered in error paths and during device removal. This is a resource management bug, not a security vulnerability.
  2. **No Security Impact**: The leaked resources are:
     - Internal kernel tracking structures (`xdp_rxq_info`)
     - No memory corruption or privilege escalation potential
     - The leak would only occur during error conditions or device removal
     - The impact is limited to a small memory leak
  3. **Similar to Non-CVE Commits**: Looking at similar commits 3 and 4 (both marked as NO for CVE), they deal with similar XDP infrastructure improvements and cleanups without security implications.
  4. **Different from CVE-worthy Commits**: The CVE-worthy similar commits (1, 2, and 5) involve:
     - Commit 1 & 2: Fix a warning that could potentially be triggered repeatedly, affecting system stability
     - Commit 5: Fixes a reference count leak that could lead to use-after-free conditions
  5. **Code Analysis**: The fix simply adds proper cleanup calls (`xdp_rxq_info_unreg`) in error paths and removal functions. The XDP infrastructure already handles the case of missing unregister gracefully (with a warning), as seen in line 182-183 of net/core/xdp.c.
  This is a quality improvement that fixes a minor resource leak, but it does not represent a security vulnerability that would warrant a CVE assignment.
d72411d209051 ethernet: atl1: Add missing DMA mapping error checks and count errors
- [sasha] Looking at this commit, I need to analyze both the security implications and the specific code changes.
  **Code Analysis:**
  1. **DMA Mapping Error Handling Added:**
     - In `atl1_alloc_rx_buffers()`: Added `dma_mapping_error()` check after `dma_map_page()` call
     - In `atl1_tx_map()`: Added multiple `dma_mapping_error()` checks after all DMA mapping operations
     - Both functions now properly handle failures by cleaning up and returning error status
  2. **Error Cleanup Logic:**
     - New `dma_err:` label in `atl1_tx_map()` that unmaps all previously mapped buffers on failure
     - Changed return type of `atl1_tx_map()` from void to bool to indicate success/failure
     - Added `drop_packet:` label in `atl1_xmit_frame()` to handle various error conditions
  3. **Statistics Updates:**
     - Increments `adapter->soft_stats.tx_errors++` when packets are dropped due to DMA mapping failures
  **Security Assessment:**
  The lack of DMA mapping error checks could lead to:
  - **Invalid DMA addresses being programmed into hardware descriptors**
  - **Potential memory corruption** if the hardware attempts DMA operations to/from invalid addresses
  - **System instability or crashes** due to invalid memory accesses
  The commit fixes a bug where the driver was not checking if DMA mapping operations succeeded before using the returned addresses. On systems with limited IOMMU resources or under memory pressure, `dma_map_page()` can fail and return an invalid address.
  **Comparison with Similar Commits:**
  - Similar Commit 2 (CVE: YES) - Fixed memory corruption in RX ring due to invalid DMA address programming
  - Similar Commit 3 (CVE: YES) - Fixed DMA mapping error handling in mlx5 driver
  - Similar Commit 1 (CVE: NO) - Also added DMA mapping error checks but in a different context
  **CVE Decision: YES**
  This commit should be assigned a CVE because:
  1. **Memory Corruption Risk**: Programming invalid DMA addresses into hardware descriptors can lead to the hardware performing DMA operations to arbitrary memory locations, potentially corrupting kernel memory.
  2. **Security Boundary Violation**: The hardware could potentially access memory regions it shouldn't, which could lead to information disclosure or system compromise.
  3. **Remote Triggering**: This vulnerability could potentially be triggered remotely by causing memory pressure or IOMMU resource exhaustion while processing network packets.
  4. **Clear Security Impact**: The commit message explicitly states this fixes missing error checks that could lead to invalid addresses being used for DMA operations, which is a security-relevant issue.
  The vulnerability is similar in nature to the CVE-assigned commits that fixed DMA mapping issues leading to memory corruption.
157501b046996 btrfs: use btrfs_record_snapshot_destroy() during rmdir
- [sasha] **NO**
  This commit fixes a race condition between rmdir and fsync operations that could lead to mount failures after a crash. While the bug has serious consequences (filesystem becomes unmountable without recovery tools), it does not represent a security vulnerability:
  1. **No security boundary violation**: The issue requires legitimate filesystem operations (creating/deleting snapshots and directories) by authorized users.
  2. **Not exploitable for malicious purposes**: The race condition occurs during normal filesystem operations and cannot be reliably triggered by an attacker to cause intentional harm.
  3. **Reliability issue, not security**: This is a data integrity/filesystem consistency bug that affects reliability after crashes, similar to commits 2-4 in the reference list which were marked as NO CVE.
  The code change shows it's fixing improper locking:
  ```c
  -    BTRFS_I(dir)->last_unlink_trans = BTRFS_I(inode)->last_unlink_trans;
  +    btrfs_record_snapshot_destroy(trans, BTRFS_I(dir));
  ```
  Where `btrfs_record_snapshot_destroy()` properly acquires `log_mutex` before updating the field, preventing the race condition. This is a correctness fix for filesystem consistency, not a security vulnerability fix.
c466e33e729a0 btrfs: propagate last_unlink_trans earlier when doing a rmdir
- [sasha] **YES**
  This commit should be assigned a CVE. The code changes fix a race condition that can lead to a denial of service vulnerability where:
  1. **The vulnerability**: There's a race window in `btrfs_rmdir()` between removing a directory entry (line where `btrfs_unlink_inode()` is called) and propagating the `last_unlink_trans` value to the parent directory. The fix moves the `last_unlink_trans` propagation to occur BEFORE the unlink operation, closing this race window.
  2. **Security impact**: If exploited (through specific timing), this race condition causes the filesystem to become unmountable after a crash or power failure. The mount will fail with errors, requiring manual intervention with the `btrfs-zero-log` tool to recover - a clear denial of service condition.
  3. **Exploitability**: While this requires local access and specific timing to trigger, it's a reproducible issue that can prevent system boot or filesystem access, which is a significant availability impact.
  The commit explicitly states this prevents "unreplayable log after snapshot delete + parent dir fsync" scenarios that cause mount failures, which aligns with denial of service vulnerabilities that have historically been assigned CVEs in filesystem code.
bf5bcf9a6fa07 btrfs: record new subvolume in parent dir earlier to avoid dir logging races
- [sasha] Based on my analysis of the commit and the code changes, I can now provide my assessment:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **Race condition, not a vulnerability**: The commit fixes a race condition where a directory can be logged with an entry pointing to a subvolume root that hasn't been committed yet. While this could lead to an "invalid entry if the log is persisted and replayed later," it's a logical inconsistency rather than a security vulnerability.
  2. **No security impact**: The commit message states this could result in an "invalid entry" during log replay, but there's no indication of:
     - Memory corruption
     - Privilege escalation
     - Data disclosure
     - System compromise
     - Denial of service beyond normal filesystem errors
  3. **Ordering issue**: The fix simply moves `btrfs_record_new_subvolume()` to be called before `btrfs_create_new_inode()` instead of after. This ensures the parent directory is marked before the subvolume entry is created, preventing the race condition.
  4. **Normal filesystem error handling**: Even if the race condition occurs, it would result in standard filesystem error handling during log replay, not a security vulnerability. The filesystem would detect the invalid entry and handle it through normal error paths.
  5. **Similar to non-CVE commits**: Looking at the similar commits provided, commit #3 and #4 which also deal with subvolume handling and potential filesystem inconsistencies were marked as "CVE Status: NO", while only commits dealing with actual corruption, crashes, or security-relevant issues received CVEs.
  The commit is a correctness fix for a filesystem consistency issue, not a security vulnerability that would warrant a CVE assignment.
5f61b961599ac btrfs: fix inode lookup error handling during log replay
- [sasha] Prompt is too long
54a7081ed168b btrfs: fix iteration of extrefs during log replay
- [sasha] Now I have all the context I need to make a decision. Let me analyze this:
  **YES**
  This commit should be assigned a CVE based on the following analysis:
  1. **Security Impact - Invalid Memory Access**: The commit explicitly fixes an "invalid memory access" issue. When `victim_name.len` is uninitialized and the code jumps to the `next` label, the line `cur_offset += victim_name.len + sizeof(*extref)` uses an undefined value, leading to invalid memory access during log replay.
  2. **Exploitable During Log Replay**: This vulnerability is triggered during btrfs log replay, which occurs during filesystem recovery operations. An attacker could potentially craft a malicious btrfs filesystem image or corrupt log entries to trigger this undefined behavior.
  3. **Similar to Other CVE-Assigned Commits**: Looking at the similar commits provided:
     - Similar Commit 1 (CVE: YES) - Fixed invalid inode pointer dereferences 
     - Similar Commit 2 (CVE: YES) - Fixed memory leak in __add_inode_ref()
     - Similar Commit 3 (CVE: YES) - Fixed uninitialized pointer free
     - Similar Commit 4 (CVE: YES) - Fixed uninitialized pointer free
     - Similar Commit 5 (CVE: YES) - Fixed uninitialized pointer free
     All these commits that fix uninitialized memory access or memory safety issues during log replay have been assigned CVEs.
  4. **Code Path Analysis**: The bug occurs in `__add_inode_ref()` when processing extended references. If `btrfs_inode_extref_parent(leaf, extref) != parent_objectid`, the code jumps to `next:` without initializing `victim_name.len`, but then uses this uninitialized value to advance `cur_offset`, potentially causing out-of-bounds memory access.
  5. **Fixes Tag Present**: The commit properly identifies it fixes commit e43eec81c516, showing this is a regression that introduced a security vulnerability.
  The uninitialized memory access during filesystem operations, especially during recovery/log replay, represents a security vulnerability that could lead to crashes, information disclosure, or potentially code execution, warranting CVE assignment.
6561a40ceced9 btrfs: fix missing error handling when searching for inode refs during log replay
- [sasha] Based on my analysis of the code changes and surrounding context, I can now provide a determination.
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **No Security Boundary Violation**: The bug is in error handling during log replay (tree-log recovery), which occurs during filesystem mount after a crash or unclean shutdown. This is not a security boundary that can be exploited by unprivileged users.
  2. **Limited Attack Surface**: Log replay only happens:
     - During mount after a crash/power failure
     - On data that was already written by the filesystem itself
     - Cannot be triggered by unprivileged users at will
  3. **Error Propagation, Not Vulnerability**: The missing error check could cause log replay to continue when `btrfs_search_slot()` fails (e.g., due to I/O errors or corruption). This might lead to metadata inconsistency, but:
     - It requires pre-existing corruption or hardware failure
     - Cannot be reliably exploited for privilege escalation
     - Results in filesystem inconsistency rather than memory corruption
  4. **Similar Historical Patterns**: Looking at the similar commits provided:
     - Commit 1 (invalid pointer dereference) got a CVE because it could cause crashes through NULL pointer access
     - Commit 4 (path ref underflow) got a CVE because it involved buffer underflow
     - This commit just misses error propagation - it doesn't create new attack vectors
  5. **Recovery Code Context**: This is filesystem recovery code that runs in a privileged context during mount. An attacker would need to:
     - Cause a system crash
     - Corrupt the log in a specific way
     - Hope the error handling bug causes exploitable behavior
     
  This is not a practical attack vector.
  The fix is important for filesystem robustness and preventing potential metadata inconsistencies during recovery, but it does not represent a security vulnerability that warrants a CVE assignment.
1e6ed33cabba8 btrfs: fix failure to rebuild free space tree using multiple transactions
- [sasha] Based on my analysis of this commit, I need to determine if this should receive a CVE.
  **Analysis:**
  1. **Nature of the issue**: This is a logic error where the free space tree rebuild process can encounter -EEXIST errors and abort the transaction when it tries to populate free space entries for block groups that already have entries added.
  2. **Root cause**: When rebuilding the free space tree using multiple transactions (introduced in commit 882af9f13e83), new metadata block groups can be allocated during the rebuild. These new block groups automatically get free space entries added when transactions end, but the rebuild process might later try to populate the same block groups, causing -EEXIST errors.
  3. **Impact**:
     - The issue causes a transaction abort with -EEXIST (error -17)
     - This happens during filesystem remount operations (specifically when remounting from read-only to read-write)
     - The filesystem operation fails but does not cause data corruption or system crashes
     - The issue is triggered during a specific administrative operation (remount)
     - No privilege escalation, information disclosure, or unauthorized access is possible
  4. **Trigger conditions**:
     - Requires rebuilding free space tree during remount
     - Requires allocation of new metadata block groups during the rebuild
     - This is a specific timing/ordering issue
  5. **Security relevance**:
     - This is primarily a reliability/functionality issue
     - No security boundary is crossed
     - No unauthorized access or data exposure occurs
     - The transaction abort is a controlled failure mechanism
  **Conclusion: NO**
  This commit should NOT be assigned a CVE because:
  1. It's a functional bug that causes a transaction abort during a specific administrative operation (remount), not a security vulnerability
  2. There is no security impact - no unauthorized access, privilege escalation, information disclosure, or data corruption
  3. The issue only affects availability during a specific operation and the failure is handled gracefully through transaction abort
  4. Similar to commit 3 in the examples (which was marked NO), this is about proper handling of internal filesystem state during operations
  The fix adds a flag (BLOCK_GROUP_FLAG_FREE_SPACE_ADDED) to track which block groups already have free space entries to avoid the duplicate population attempt. This is a correctness fix for an edge case in the filesystem's internal operations, not a security fix.
1f029b4e30a60 Bluetooth: Prevent unintended pause by checking if advertising is active
- [sasha] Now I need to understand what the issue is. The commit message says "When PA Create Sync is enabled, advertising resumes unexpectedly." Let me analyze this:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Not a Security Vulnerability**: This is a functional bug fix that prevents advertising from resuming unexpectedly when PA (Periodic Advertising) Create Sync is enabled. The issue is about incorrect state management, not a security vulnerability.
  2. **Nature of the Fix**: The change adds a simple check to verify if advertising is actually active before attempting to pause it:
     ```c
     +	/* If controller is not advertising we are done. */
     +	if (!hci_dev_test_flag(hdev, HCI_LE_ADV))
     +		return 0;
     ```
  3. **Impact Analysis**: 
     - The bug causes advertising to resume when it shouldn't (during PA Create Sync operations)
     - This is a behavioral issue that could affect Bluetooth functionality but doesn't create security risks
     - No memory corruption, privilege escalation, information disclosure, or other security impacts
  4. **Similar to Non-CVE Commits**: Looking at the similar commits provided as reference (all marked "CVE Status: NO"), they also deal with Bluetooth protocol state management, advertising control, and functional fixes without security implications.
  5. **Type of Bug**: This is a logic error where the code was attempting to pause advertising without first checking if advertising was actually active. This missing check could lead to unintended state changes but not security vulnerabilities.
  The commit is fixing a functional regression introduced by the referenced commit (ad383c2c65a5) but does not address any security vulnerability that would warrant a CVE assignment.
38074de35b015 NFSv4/flexfiles: Fix handling of NFS level errors in I/O
- [sasha] Now let me analyze the commit and its security implications:
  **NO**
  This commit should not be assigned a CVE. Here's my analysis:
  1. **Not a Security Vulnerability Fix**: The commit fixes error handling logic in the NFS flexfiles layout driver to properly distinguish between NFS-level errors (protocol errors) and RPC-level errors (transport errors). This is a functional bug fix, not a security vulnerability fix.
  2. **Specific Issue Being Fixed**: The commit addresses incorrect error handling when an NFS client connects to a data server through a port number lower than 1024 and receives NFSERR_PERM errors. The fix allows the client to:
     - Disconnect and retry READ operations on a different data server
     - Retry WRITE operations after reconnecting
  3. **Code Changes Analysis**:
     - The main changes add a new `u32 op_status` parameter to error handling functions
     - Separate handling is added for NFS-level errors (like `NFSERR_PERM`, `NFS4ERR_PERM`) vs RPC-level errors
     - New case handling for `NFSERR_PERM` that forces transport disconnection and retry
     - No security boundaries are crossed, no privilege escalation, no information disclosure
  4. **Impact**: The issue causes incorrect error handling that could lead to I/O failures or inefficient retries, but there's no security impact. It's a reliability/functionality issue where the client might not properly failover to another data server or retry operations correctly.
  5. **Similar to Non-CVE Examples**: This is similar to the provided examples that were marked as "CVE Status: NO" - they all fix error handling, return value processing, or protocol compliance issues without security implications.
  The commit improves robustness and correct behavior of the NFS client but does not address any security vulnerability.
e3e3775392f3f flexfiles/pNFS: update stats on NFS4ERR_DELAY for v4.1 DSes
- [sasha] Based on my analysis, I can now provide a determination on whether this commit should be assigned a CVE.
  **NO**
  This commit is a simple statistics consistency fix, not a security vulnerability fix. Here's the analysis:
  1. **Nature of the change**: The commit adds a single line `nfs_inc_stats(lseg->pls_layout->plh_inode, NFSIOS_DELAY);` to increment a statistics counter when an NFS4ERR_DELAY error occurs in flexfiles layout handling.
  2. **Consistency issue, not security**: The commit message states "On NFS4ERR_DELAY nfs slient updates its stats, but misses for flexfiles v4.1 DSes." This indicates that:
     - The main NFS v4 code already updates NFSIOS_DELAY statistics (confirmed in nfs4proc.c: `nfs_inc_server_stats(server, NFSIOS_DELAY)`)
     - The flexfiles layout code was missing this statistics update
     - This is purely a monitoring/statistics consistency issue
  3. **No security impact**: 
     - The code already handles the NFS4ERR_DELAY error properly by calling `rpc_delay(task, FF_LAYOUT_POLL_RETRY_MAX)`
     - The missing statistics update doesn't affect the error handling logic
     - NFSIOS_DELAY is just a performance/monitoring counter used for system monitoring tools
     - No memory corruption, privilege escalation, or access control issues are being fixed
  4. **Similar to non-CVE commits**: This is similar to the other non-CVE commits shown that make minor adjustments to NFS code without fixing actual security vulnerabilities.
  The commit simply ensures that delay events in flexfiles are properly counted in the statistics, bringing it in line with how the main NFS v4 code handles the same error condition.
cf0b812500e64 platform/x86: wmi: Fix WMI event enablement
- [sasha] Based on my analysis of the commit and the code changes, here is my determination:
  **NO** - This commit should NOT be assigned a CVE.
  Explanation:
  1. **Nature of the fix**: This is a functional bug fix that restores proper behavior for WMI event enablement. The commit fixes a regression introduced in commit 656f0961d126 where WMI events were only being enabled for devices marked as "expensive", when in fact Windows always enables/disables WMI events regardless of the expensive flag.
  2. **No security vulnerability**: The code changes show:
     - The fix changes the logic in `wmi_device_enable()` to always enable/disable WMI events (matching Windows behavior)
     - For non-event WMI devices, it still respects the ACPI_WMI_EXPENSIVE flag
     - This is a functional issue where hotkey events weren't working on some Dell laptops (Dell Latitude 5400 mentioned)
  3. **Impact analysis**:
     - The bug prevented hotkey events from functioning properly on certain devices
     - This is a usability/functionality issue, not a security vulnerability
     - No memory corruption, privilege escalation, information disclosure, or other security-relevant patterns are present
  4. **Similar commits comparison**: Looking at the provided similar commits:
     - Commits with "CVE Status: NO" deal with functional issues like ignoring suspend notifications, fixing race conditions in event reporting, and workarounds for firmware bugs
     - Commits with "CVE Status: YES" involve actual security issues like NULL pointer dereferences that could lead to crashes or other exploitable conditions
  This commit simply restores the correct behavior for enabling WMI events to match Windows driver behavior, fixing a functionality regression rather than addressing any security vulnerability.
d07143b507c51 platform/mellanox: nvsw-sn2201: Fix bus number in adapter error message
- [sasha] Based on my analysis of the commit message and code changes:
  **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Nature of the change**: This is a simple logging fix that corrects which bus number is displayed in an error message. At line 1183-1184, when failing to get the adapter for `main_mux_devs`, it was incorrectly logging `cpld_devs->nr` instead of `main_mux_devs->nr`.
  2. **No security impact**: 
     - The change only affects an error message displayed in logs
     - It doesn't modify any control flow, access control, or data handling
     - The actual functionality remains unchanged - the code still tries to get the adapter for `main_mux_devs` (line 1180)
     - The error handling path remains the same
  3. **Comparing with similar commits**:
     - Similar Commit 1 (NO CVE): Added missing error checking for `platform_device_add_resources()`
     - Similar Commit 2 (NO CVE): Added a new device ID
     - Similar Commit 3 (NO CVE): Fixed sparse warnings about incorrect types
     - Similar Commit 4 (YES CVE): Fixed a NULL pointer dereference (Oops)
  4. **Key difference from CVE-worthy commits**: The commit marked with CVE (Similar Commit 4) fixed an actual crash/Oops condition where the code was dereferencing an error pointer. In contrast, this commit only fixes incorrect logging output with no functional or security implications.
  The change is purely cosmetic for debugging purposes and has no impact on system security, stability, or functionality.
173bbec6693f3 platform/mellanox: mlxbf-pmc: Fix duplicate event ID for CACHE_DATA1
- [sasha] Based on my analysis of the code changes and the context provided, here is my CVE assessment:
  **NO**
  This commit should not be assigned a CVE for the following reasons:
  1. **Nature of the bug**: This is a simple duplicate event ID assignment error in a performance monitoring driver. The mlxbf_pmc_llt_events array had ID 103 assigned to both "GDC_BANK0_G_RSE_PIPE_CACHE_DATA0" and "GDC_BANK0_G_RSE_PIPE_CACHE_DATA1" events.
  2. **Limited impact**: The bug only affects event mapping in the Mellanox BlueField performance monitoring counters (PMC) driver. When users try to use event name "GDC_BANK0_G_RSE_PIPE_CACHE_DATA1", the driver would incorrectly map it to ID 103 instead of 104. This would result in:
     - Incorrect performance counter monitoring for that specific event
     - Users getting data for the wrong event when trying to monitor CACHE_DATA1
  3. **No security implications**: 
     - The bug doesn't allow privilege escalation
     - It doesn't cause memory corruption or crashes
     - It doesn't expose sensitive information
     - It doesn't allow unauthorized access to system resources
  4. **Functional bug only**: This is purely a functional correctness issue affecting performance monitoring accuracy, not a security vulnerability. Similar to the referenced commits that were marked as "CVE Status: NO", this is a driver quality issue rather than a security issue.
  5. **Limited scope**: The issue only affects users of the Mellanox BlueField-3 platform who are using the specific LLT (Last Level Tile) performance monitoring counters, and only when trying to monitor the specific CACHE_DATA1 event.
  The fix simply corrects the event ID from 103 to 104, ensuring each event has a unique identifier as intended.
a9a9e68954f29 RDMA/mlx5: Fix vport loopback for MPV device
- [sasha] Now I understand what's happening. Let me analyze the security implications:
  **NO**
  This commit does not warrant a CVE assignment. Here's my analysis:
  1. **Nature of the Issue**: The patch fixes a configuration issue where vport loopback was not being correctly enabled for MPV (Multi-Port Virtualization) devices in certain RoCE (RDMA over Converged Ethernet) scenarios. The loopback functionality allows packets to be sent back to the same port/device.
  2. **Not a Security Vulnerability**: 
     - The issue is about missing functionality (loopback not being enabled when it should be)
     - It affects packet routing behavior but doesn't introduce any security weaknesses
     - The code changes (`mlx5_ib_enable_lb_mp`/`mlx5_ib_disable_lb_mp`) simply ensure loopback is properly enabled for both master and slave devices in MPV configurations
  3. **Impact Analysis**:
     - The fix ensures packets correctly execute loopback checks at the vport level in firmware
     - Without this fix, some MPV RoCE configurations might not have working loopback functionality
     - This is a functional correctness issue, not a security issue
  4. **Code Changes**: The patch adds helper functions to enable/disable loopback for both master and slave devices together, and calls these functions during bind/unbind operations. This is purely configuration management code.
  5. **Similar Commits**: Looking at the provided similar commits, none of them received CVEs despite fixing various RDMA/mlx5 issues, including configuration problems, port state issues, and functional fixes.
  The commit fixes a functional bug where loopback wasn't working correctly in specific MPV configurations, but it doesn't address any security vulnerability that could be exploited by an attacker.
acd245b1e33fc RDMA/mlx5: Fix CC counters query for MPV
- [sasha] Based on my analysis of this commit, here is my determination:
  **NO**, this commit should not be assigned a CVE.
  Explanation:
  1. **No Security Impact**: This is a functional correctness bug, not a security vulnerability. The issue is that congestion control (CC) counters were being queried from the wrong device (master device instead of the port-specific device) in multi-port virtualization scenarios.
  2. **Only Affects Statistics/Monitoring**: The bug only affects the accuracy of performance/congestion counters being reported. It doesn't:
     - Allow unauthorized access
     - Cause memory corruption
     - Lead to privilege escalation
     - Create denial of service conditions
     - Expose sensitive information
  3. **Similar to Reference Commits**: The similar commits provided (all marked as "CVE Status: NO") also deal with:
     - Counter query fixes in multi-port configurations
     - Port number corrections for statistics
     - Correctness of device selection in multi-port scenarios
  4. **Impact is Limited**: The worst case is that users get incorrect congestion control statistics for the second port in a dual-port configuration. This is a quality/accuracy issue, not a security issue.
  5. **No Exploitable Condition**: There's no way for an attacker to leverage this bug to compromise the system. It's simply returning statistics from the wrong port, which while incorrect, doesn't create any exploitable condition.
  The fix correctly changes `mlx5_lag_query_cong_counters(dev->mdev, ...)` to `mlx5_lag_query_cong_counters(mdev, ...)` where `mdev` is the correct device obtained from `mlx5_ib_get_native_port_mdev()`. This ensures the counters are queried from the correct port-specific device rather than always from the master device.
3cc1dbfddf88d RDMA/mlx5: Fix HW counters query for non-representor devices
- [sasha] Now I understand the issue. Looking at the code and the commit message:
  **NO**
  This commit does not warrant a CVE assignment. Here's why:
  1. **Not a security vulnerability**: The issue is about incorrect counter queries for non-representor switchdev devices. The bug causes PPCNT counters and congestion control counters to be skipped/not updated for non-representor devices in switchdev mode.
  2. **Functional bug, not security issue**: The impact is that hardware performance counters are not properly reported - they remain unupdated/zero. This affects monitoring and statistics but doesn't create any security vulnerability.
  3. **No exploitable condition**: The code change adds `&& dev->is_rep` to line 401 to ensure that only representor devices skip the PPCNT and congestion counters (as intended), while non-representor devices properly query all counters. This is a logic fix to ensure correct behavior.
  4. **Similar to other non-CVE commits**: Looking at the similar commits provided, they all deal with counter query fixes, port configuration issues, and statistical reporting - none were assigned CVEs because they don't represent security vulnerabilities.
  The change ensures that the condition at line 401 properly distinguishes between representor and non-representor devices, fixing a functional regression where non-representor devices were incorrectly skipping important counter queries.
2ed25aa7f7711 IB/mlx5: Fix potential deadlock in MR deregistration
- [sasha] Based on my analysis of this commit, here is my determination:
  **YES**, this commit should be assigned a CVE.
  Here's my reasoning based on the code changes and commit message:
  1. **It fixes a real deadlock vulnerability**: The commit clearly identifies and fixes a deadlock condition that can occur in production systems. The deadlock happens when:
     - Thread A holds `umem_odp->umem_mutex` in `mlx5_revoke_mr()`
     - Thread A calls `cache_ent_find_and_store()` which may allocate memory with `kzalloc(GFP_KERNEL)` 
     - Memory allocation triggers memory reclaim which can invoke `mmu_notifier_invalidate_range_start()`
     - This leads to `mlx5_ib_invalidate_range()` which tries to acquire the same `umem_odp->umem_mutex`
     - Result: Deadlock
  2. **Security impact**: Deadlocks are security vulnerabilities because they can:
     - Lead to denial of service (DoS) by hanging kernel threads
     - Make system resources unavailable
     - Potentially be triggered by unprivileged users through memory pressure
  3. **The fix involves substantial restructuring**: The commit shows significant code refactoring to fix the lock ordering issue:
     - Creates new functions `mlx5_umr_revoke_mr_with_lock()` and `mlx5r_handle_mkey_cleanup()`
     - Releases `umem_mutex` before acquiring `rb_lock` to prevent the deadlock
     - Changes the locking strategy to ensure proper lock ordering
  4. **It's a regression introduced by a previous security fix**: The commit fixes a regression introduced by commit `abb604a1a9c8` ("RDMA/mlx5: Fix a race for an ODP MR which leads to CQE with error"), which itself was assigned a CVE according to the similar commits provided.
  5. **Clear exploit path**: The lockdep trace in the commit message shows this can be triggered through normal RDMA operations combined with memory pressure, making it exploitable.
  The vulnerability allows local users to cause a denial of service (system deadlock) through RDMA operations that trigger specific memory allocation patterns while holding critical locks.
021f243627ead scsi: ufs: core: Fix spelling of a sysfs attribute name
- [sasha] **NO**
  This commit should NOT be assigned a CVE. Here's my analysis:
  1. **Nature of the change**: This is purely a cosmetic fix that corrects a spelling error in a sysfs attribute name from "physical_memory_resourse_count" to "physical_memory_resource_count" (changing "resourse" to "resource").
  2. **No security impact**: The code changes only affect:
     - The sysfs attribute name exposed to userspace
     - Documentation that describes this attribute
     - No changes to the underlying functionality, data access, or security boundaries
  3. **Read-only attribute**: The attribute is read-only as evidenced by:
     - The `DEVICE_ATTR_RO` macro usage
     - The documentation stating "The file is read only"
     - The implementation only provides a `_show` function, not a `_store` function
  4. **No privilege escalation or data exposure**: This attribute simply exposes hardware descriptor information that was already accessible through the misspelled name. The spelling correction doesn't:
     - Change access permissions
     - Expose new data
     - Create new attack vectors
     - Fix any security vulnerability
  5. **Similar to non-CVE commits**: Looking at the reference commits, this is similar to "Similar Commit 4" which fixed a helper function signature but didn't get a CVE because it was just a code cleanup with no security implications.
  The commit is a simple typo fix in a userspace-visible API with no security ramifications whatsoever.
4937e604ca24c scsi: core: Enforce unlimited max_segment_size when virt_boundary_mask is set
- [sasha] ## Analysis
  **YES**, this commit should be assigned a CVE.
  ### Reasoning:
  1. **Data Corruption Vulnerability**: The commit explicitly states it "fixes reported data corruption on storvsc". Data corruption is a serious security issue that can lead to:
     - Loss of data integrity
     - Potential information disclosure if corrupted data is read incorrectly
     - System instability or crashes
  2. **Long-standing Issue**: The bug has existed since commit 81988a0e6b03 (October 2015), affecting nearly 10 years of kernel releases. This long exposure window significantly increases the impact.
  3. **Similarity to CVE-assigned Commit**: Similar Commit 3 (mmc: sdhci) was assigned a CVE for a very similar issue - incorrect max_seg_size handling when PAGE_SIZE is 64KiB. Both commits:
     - Fix max_segment_size issues
     - Prevent data corruption
     - Address block layer limit validation problems
  4. **Exploitable Condition**: The vulnerability occurs when:
     - A SCSI driver sets virt_boundary_mask
     - The driver doesn't explicitly set max_segment_size to UINT_MAX
     - This causes improper bio splitting that can corrupt data
  5. **Real-world Impact**: The commit message specifically mentions "reported data corruption on storvsc", indicating this is not just theoretical but has affected actual systems. The storvsc driver is used in Hyper-V virtualized environments, making this relevant for cloud and virtualized deployments.
  The code changes show the fix enforces that when virt_boundary_mask is set, max_segment_size must be UINT_MAX, preventing the data corruption scenario that has existed since 2015.
8889676cd6216 scsi: sd: Fix VPD page 0xb7 length check
- [sasha] Based on my analysis, I need to provide a YES/NO decision on whether this commit should be assigned a CVE.
  **YES**
  This commit fixes an out-of-bounds memory read vulnerability. The code checks if `vpd->len >= 2` but then accesses `vpd->data[5]`, which could read beyond the allocated buffer if the VPD page length is between 2 and 5 bytes. This is similar to the CVE-assigned commit "sd: Fix off-by-one error in sd_read_block_characteristics()" which also fixed an out-of-bounds read when accessing VPD page data.
  The vulnerability could be triggered by a malicious or malfunctioning SCSI device that returns a VPD page 0xb7 with a length between 2-5 bytes, potentially causing kernel crashes or information disclosure. While the commit message mentions "in practice this is not really a problem," the actual code change fixes a genuine security vulnerability with potential for exploitation.
00f452a1b084e scsi: qla4xxx: Fix missing DMA mapping error in qla4xxx_alloc_pdu()
- [sasha] **YES**
  This commit should be assigned a CVE. The missing DMA mapping error check represents a significant security vulnerability with the following impacts:
  1. **System Crashes**: When `dma_map_single()` fails (typically under memory pressure), it returns `DMA_MAPPING_ERROR`. Without checking, the driver proceeds with an invalid DMA address that gets programmed into hardware control blocks. This will likely cause IOMMU faults or bus errors leading to system crashes.
  2. **Memory Corruption**: If the invalid DMA address happens to map to valid memory, hardware DMA operations could corrupt arbitrary kernel memory.
  3. **Information Disclosure**: Invalid DMA reads could potentially expose sensitive kernel memory contents.
  The vulnerability has been present since commit b3a271a94d00 (2011), making it a long-standing issue. It's comparable in severity to Similar Commit 5 which received a CVE for a null dereference causing kernel oops. The fact that this can be triggered through iSCSI operations (potentially by a malicious iSCSI target or local attacker) and leads to system instability warrants CVE assignment.
c3b214719a877 scsi: qla2xxx: Fix DMA mapping test in qla24xx_get_port_database()
- [sasha] Based on my analysis of this commit, here is my determination:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Security Impact**: The bug involves incorrect error checking for DMA mapping operations. When `dma_map_single()` fails, it returns `DMA_MAPPING_ERROR` which is defined as `~(dma_addr_t)0` (all bits set to 1, typically 0xFFFFFFFF or 0xFFFFFFFFFFFFFFFF). The buggy code checks `if (!pdb_dma)` which only catches when the address is 0, missing the actual error value.
  2. **Invalid DMA Address Usage**: When the DMA mapping fails but isn't properly detected, the code continues to use the invalid DMA address (0xFFFFFFFF...) in lines 2157-2160, programming it into the hardware mailbox registers. This causes the hardware to attempt DMA operations to an invalid memory address.
  3. **Memory Corruption Risk**: Using an invalid DMA address can lead to:
     - The hardware attempting to access unmapped memory regions
     - Potential corruption of kernel memory if the invalid address happens to point to valid memory
     - System instability or crashes
     - In worst case scenarios with IOMMU bypass, potential information disclosure
  4. **Similar CVE Precedents**: Looking at the similar commits provided:
     - Similar Commit 2 (CVE Status: YES) fixed a DMA API error checking issue
     - Similar Commit 3 (CVE Status: YES) fixed improper DMA unmapping
     - Similar Commit 5 (CVE Status: YES) fixed DMA unmapping issues
  The pattern is clear that improper DMA mapping/unmapping handling is considered a security vulnerability worthy of CVE assignment, as it can lead to memory corruption and system instability.
c01776287414c NFSv4/pNFS: Fix a race to wake on NFS_LAYOUT_DRAIN
- [sasha] Based on my analysis of this commit:
  **NO**, this commit should not be assigned a CVE.
  **Explanation:**
  1. **Nature of the bug**: This is a race condition that causes a system hang/deadlock in the NFS pNFS client code. The issue is a missing memory barrier (`smp_mb__after_atomic()`) between clearing the `NFS_LAYOUT_DRAIN` bit and calling `wake_up_bit()`.
  2. **Impact**: The bug causes writeback operations to hang indefinitely when waiting on the `NFS_LAYOUT_DRAIN` bit in `pnfs_update_layout()`. This results in a denial of service condition where the system becomes unresponsive for NFS operations.
  3. **Not a security vulnerability**: While this is a serious reliability issue that can cause system hangs:
     - It does not allow privilege escalation
     - It does not expose sensitive information
     - It does not allow unauthorized access
     - It does not enable remote code execution
     - It's essentially a quality/reliability bug rather than a security vulnerability
  4. **Similar commits pattern**: The similar commits provided show that race conditions in NFS/pNFS that cause hangs or live locks are generally NOT assigned CVEs (Similar Commits 1, 2, and 3 all have "CVE Status: NO").
  5. **The code change**: The fix is adding a memory barrier (`smp_mb__after_atomic()`) to ensure proper ordering between the atomic operation and the wake-up call. This is a standard synchronization fix for race conditions in concurrent code.
  The commit fixes a reliability issue that causes system hangs, but does not introduce or fix any security vulnerabilities that would warrant a CVE assignment.
e8d6f3ab59468 nfs: Clean up /proc/net/rpc/nfs when nfs_fs_proc_net_init() fails.
- [sasha] Based on the commit message and code changes provided, let me analyze this:
  ## CVE Analysis
  **CVE Status: NO**
  This commit fixes a resource cleanup issue in error handling, but it does not represent a security vulnerability that warrants a CVE assignment. Here's why:
  1. **Nature of the bug**: This is a resource leak in error handling path where `/proc/net/rpc/nfs` is not properly cleaned up when `nfs_fs_proc_net_init()` fails during network namespace initialization.
  2. **Impact**: The impact is limited to:
     - A warning message in the kernel log when the network namespace is destroyed
     - A leaked proc directory entry (`/proc/net/rpc/nfs`)
     - No memory corruption, privilege escalation, or denial of service
  3. **Attack vector**: This requires:
     - Ability to create network namespaces (typically requires CAP_SYS_ADMIN)
     - Triggering a specific failure in `nfs_fs_proc_net_init()` (likely through fault injection as shown in the syzbot report)
     - Not exploitable by unprivileged users
  4. **Comparison with similar commits**:
     - Similar commits 1 & 2 (CVE Status: YES) fixed a bug that could cause kernel warnings and potential issues during namespace destruction
     - Similar commits 4 & 5 (CVE Status: YES) fixed similar proc registration error handling in nfsd
     - However, those commits had more severe implications for system stability
  5. **Security implications**: While this is a bug that needs fixing, it doesn't pose a significant security risk:
     - No unauthorized access is possible
     - No information disclosure
     - No system instability beyond the warning message
     - Requires privileged operations to trigger
  The fix is a proper cleanup in error handling paths, which is good practice but doesn't address a security vulnerability severe enough for CVE assignment.
cbe4134ea4bc4 fs: export anon_inode_make_secure_inode() and fix secretmem LSM bypass
- [sasha] **YES**
  This commit fixes a security vulnerability where LSM (Linux Security Module) checks were being bypassed for secretmem file descriptors. 
  The key evidence:
  1. **Security Bypass**: The commit message explicitly states it fixes "LSM/SELinux checks to be bypassed for secretmem file descriptors"
  2. **Root Cause**: In fs/libfs.c, `alloc_anon_inode()` sets the S_PRIVATE flag:
     ```c
     inode->i_flags |= S_PRIVATE | S_ANON_INODE;
     ```
  3. **Impact**: Throughout security/security.c, S_PRIVATE causes security checks to be bypassed. For example, in `security_inode_permission()`:
     ```c
     if (unlikely(IS_PRIVATE(inode)))
         return 0;  // Bypasses all security checks
     ```
  4. **The Fix**: The new `anon_inode_make_secure_inode()` function properly clears S_PRIVATE:
     ```c
     inode->i_flags &= ~S_PRIVATE;
     ```
  This means that despite secretmem calling `security_inode_init_security_anon()` to create a security context, all subsequent LSM policy enforcement (SELinux, AppArmor, etc.) was being bypassed due to the S_PRIVATE flag remaining set. This is a clear security vulnerability affecting access control mechanisms.
707f853d7fa3c module: Provide EXPORT_SYMBOL_GPL_FOR_MODULES() helper
- [sasha] **NO**
  This commit does not fix a security vulnerability and should not be assigned a CVE. Instead, it introduces a new security feature that enhances access control for kernel symbol exports.
  Key reasons:
  1. **New Feature, Not a Fix**: The commit adds `EXPORT_SYMBOL_GPL_FOR_MODULES()`, a new macro that restricts symbol usage to specific modules. This is a proactive security enhancement, not a reactive fix to an existing vulnerability.
  2. **Adds Restrictions, Not Removing Them**: The code changes show:
     ```c
     #define EXPORT_SYMBOL_GPL_FOR_MODULES(sym, mods) __EXPORT_SYMBOL(sym, "GPL", "module:" mods)
     ```
     This creates a namespace mechanism that prevents unauthorized modules from accessing symbols - it's tightening security, not fixing a security hole.
  3. **No Vulnerability Pattern**: The commit doesn't exhibit any patterns typical of security fixes (buffer overflow corrections, access control bypasses, privilege escalation fixes, etc.). It's purely adding new functionality.
  4. **Documentation Focus**: A significant portion of the changes are documentation updates explaining how to use the new feature, which is typical of feature additions rather than security fixes.
  5. **Similar Commits Pattern**: All five similar commits provided as reference (namespace conversions, export macros additions) were marked as "CVE Status: NO" - they were all feature additions or code organization changes, not security fixes.
  CVEs are assigned to vulnerabilities that need to be patched. This commit introduces a mechanism to improve security going forward but doesn't address any existing exploitable condition in the kernel.
8edab8a72d677 RDMA/mlx5: Initialize obj_event->obj_sub_list before xa_insert
- [sasha] Based on my analysis of the commit and code changes, here is my determination:
  **YES**, this commit should be assigned a CVE.
  This is a clear security vulnerability that causes a **NULL pointer dereference** leading to a kernel crash. The specific issue is:
  1. **Race Condition**: The code has a race condition where `obj_event->obj_sub_list` is accessed immediately after `xa_insert()` but before `INIT_LIST_HEAD()` is called.
  2. **Crash Details**: The crash trace shows:
     - NULL pointer dereference at virtual address 0x0000000000000060
     - Occurs in `dispatch_event_fd+0x68/0x300` when iterating through `obj_sub_list`
     - The poisonous pointer (0xfffffffffffffff0) indicates uninitialized list_head
  3. **Root Cause**: In the original code:
     ```c
     err = xa_insert(&event->object_ids, key_level2, obj_event, GFP_KERNEL);
     if (err)
         return err;
     INIT_LIST_HEAD(&obj_event->obj_sub_list);  // Initialized AFTER xa_insert
     ```
     
     The `xa_insert()` makes the object visible to other threads before the list is initialized. Another thread can load this object via `xa_load()` and try to iterate the uninitialized list.
  4. **Security Impact**: This can be triggered remotely through RDMA operations, causing a **denial of service** by crashing the kernel. The vulnerability affects the mlx5 InfiniBand driver's DEVX event subscription mechanism.
  5. **Fix**: The patch correctly moves `INIT_LIST_HEAD()` before `xa_insert()`:
     ```c
     INIT_LIST_HEAD(&obj_event->obj_sub_list);  // Now initialized BEFORE xa_insert
     err = xa_insert(&event->object_ids, key_level2, obj_event, GFP_KERNEL);
     ```
  This vulnerability is similar to the other CVE-assigned commits shown, which also fix memory safety issues (use-after-free, memory leaks, uninitialized access) in the mlx5 driver that can lead to crashes or memory corruption.
2c6b640ea08bf RDMA/mlx5: Fix unsafe xarray access in implicit ODP handling
- [sasha] Now I understand the issue. The commit d3d930411ce3 introduced the use of `__xa_store()` and `__xa_erase()` on the `dev->odp_mkeys` xarray, but it's being called while holding the lock for a different xarray (`imr->implicit_children`). This is incorrect because:
  1. `__xa_store()` and `__xa_erase()` are internal xarray functions that require the caller to hold the xarray's lock
  2. The code is holding `imr->implicit_children` lock but accessing `dev->odp_mkeys` xarray
  3. This violates RCU protection requirements, causing the lockdep warning
  The fix in this commit changes `__xa_store()` to `xa_store()` and `__xa_erase()` to `xa_erase()`, which handle locking internally.
  **NO**
  This commit should not be assigned a CVE. While it fixes a locking issue that could potentially cause problems, the bug does not represent a security vulnerability:
  1. The issue is a **locking/synchronization bug** rather than a security vulnerability
  2. The lockdep warning indicates incorrect RCU usage but not an exploitable condition
  3. The bug could potentially cause race conditions or data corruption in the RDMA subsystem, but there's no evidence of:
     - Privilege escalation potential
     - Information disclosure
     - Denial of service beyond potential system instability
     - Remote exploitability
  4. The fix is essentially correcting improper use of internal xarray APIs by switching to the public APIs that handle locking correctly
  5. This is a correctness issue in the kernel's RDMA/InfiniBand driver subsystem, not a security vulnerability
  The similar commits shown (commits 1-5) that were assigned CVEs all involved actual **use-after-free** vulnerabilities with clear security implications. In contrast, this commit only fixes incorrect locking that could lead to RCU warnings but not exploitable memory safety issues.
109f4d29dade8 platform/mellanox: mlxbf-tmfifo: fix vring_desc.len assignment
- [sasha] Based on the analysis of this commit, here's my assessment:
  **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Type correction only**: The fix is purely a sparse warning correction that addresses incorrect type assignment. The original code assigned `VRING_DROP_DESC_MAX_LEN` (which evaluates to 0xFFFF) directly to `vring->drop_desc.len`, while the correct approach is to use `cpu_to_virtio32()` for proper endianness conversion.
  2. **No security impact**: This is a type safety/endianness issue caught by sparse (a static analysis tool). The field `len` in `struct vring_desc` is of type `__virtio32`, which requires proper endianness handling through virtio conversion functions. The fix ensures correct type usage but doesn't address any security vulnerability.
  3. **Functional equivalence**: On little-endian systems (which are most common), the behavior would be identical before and after the fix. The issue would only potentially manifest on big-endian systems, and even then it's about protocol correctness rather than security.
  4. **Drop descriptor context**: The `drop_desc` is a dummy descriptor used for dropping packets when no descriptors are available. This is a resource management feature, not a security-critical path.
  5. **Similar commits pattern**: Looking at the similar commits provided, they all received "CVE Status: NO" and were also sparse warning fixes for type correctness (incorrect type assignments, endianness issues, etc.).
  The commit is a good code quality improvement that ensures proper type safety and portability across different architectures, but it does not fix a security vulnerability that would warrant a CVE assignment.
08a0d93c353bd arm64: dts: apple: Move touchbar mipi {address,size}-cells from dtsi to dts
- [sasha] Now let me analyze this change in detail. This commit is moving `#address-cells` and `#size-cells` properties from the device tree include file (.dtsi) to the device-specific files (.dts). This is done to fix device tree compiler warnings about unnecessary address/size cells in nodes that don't have child nodes with "reg" properties when the node is disabled.
  Based on my analysis:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Not a security fix**: This is purely a device tree syntax/warning fix to address compiler warnings. The commit message explicitly states it's to "fix the following W=1 warnings" about unnecessary #address-cells/#size-cells properties.
  2. **No functional impact**: The change merely moves properties from a shared .dtsi file to model-specific .dts files where the nodes are actually enabled. This has no runtime impact on the kernel's behavior or security.
  3. **Similar to other DTS warning fixes**: Looking at similar commits in the kernel history (like commit 3a4bb8185066), these types of changes are routine device tree cleanups that fix compiler warnings without any security implications.
  4. **No security-sensitive components affected**: The change only affects device tree property placement for Apple touchbar display nodes, which are display-related configuration items, not security-critical components.
  5. **Pattern matches NO CVE examples**: This follows the same pattern as the similar commits shown in the historical examples (commits about dropping invalid properties, adding missing properties, etc.) which were all marked as "CVE Status: NO".
  The code changes show this is a purely cosmetic fix to eliminate device tree compiler warnings by properly placing the address/size-cells properties only where they're needed (when the node is enabled and has child nodes).
811a909978bf5 arm64: dts: apple: Drop {address,size}-cells from SPI NOR
- [sasha] Notice that the Intel example doesn't have #address-cells and #size-cells in the flash node itself, only in the partitions node. Let me check if this is a security issue:
  **Analysis:**
  1. **Nature of the change**: This commit removes unnecessary `#address-cells` and `#size-cells` properties from the SPI NOR flash node. These properties were incorrectly placed at the flash@0 level when they should only be in the "partitions" subnode.
  2. **Security implications**: 
     - This is purely a device tree structure/formatting fix
     - It addresses a DTC (Device Tree Compiler) warning about unnecessary properties
     - The change doesn't affect runtime behavior or security
     - No memory management, access control, or input validation issues
     - No potential for buffer overflows, privilege escalation, or other vulnerabilities
  3. **Code changes**:
     - Only removes two lines: `#address-cells = <1>;` and `#size-cells = <1>;` from the flash@0 node
     - These properties remain correctly placed in the "partitions" subnode where they are actually needed
     - The partitions node has child nodes with "reg" properties, so it needs these properties
     - The flash@0 node only has the "partitions" child which doesn't have a "reg" property, so it doesn't need these properties
  4. **Similar commits**: All the provided similar commits (with CVE Status: NO) also deal with device tree property corrections:
     - Removing invalid properties from ethsys
     - Dropping unnecessary #address-cells/#size-cells from PMIC nodes
     - Adding missing properties to timer nodes
     - Correcting PCIe region ranges
     - Adjusting GIC register sizes
  **NO**
  This commit is a device tree formatting fix that removes unnecessary properties to comply with DTC validation rules. It has no security implications and does not fix any vulnerability. It's purely a structural/syntactic correction similar to the other non-CVE commits shown as reference.
ac1daa91e9370 arm64: dts: apple: t8103: Fix PCIe BCM4377 nodename
- [sasha] Based on my analysis of this commit:
  **NO** - This commit should NOT be assigned a CVE.
  Explanation:
  1. **Nature of change**: This is purely a cosmetic device tree node name change from `network@0,0` to `wifi@0,0` to comply with device tree schema validation requirements.
  2. **No security impact**: The change only affects the node name, not any functional properties. The node still has the same:
     - Compatible string ("pci14e4,4425")
     - Register address (0x10000 0x0 0x0 0x0 0x0)
     - MAC address property structure
     - Antenna SKU property
  3. **Validation-only fix**: The commit message explicitly states this fixes "dtbs_check warnings" - these are device tree schema validation warnings that ensure consistency in device tree naming conventions across the kernel.
  4. **Similar to reference commits**: All the similar commits provided (CVE Status: NO) show the same pattern - they fix device tree node names to comply with schema validation (e.g., "power-controller" → "clock-controller", "cir" → "ir-receiver", "eth-phy0" → "ethernet-phy").
  5. **No vulnerability fixed**: There's no buffer overflow, memory leak, access control issue, input validation problem, race condition, or any other security-relevant bug being fixed here. It's purely a naming convention compliance fix.
b26852daaa83f RDMA/mlx5: reduce stack usage in mlx5_ib_ufile_hw_cleanup
- [sasha] Based on my analysis of this commit, here's my assessment:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **Not a security vulnerability**: This is purely a stack size optimization issue. The commit changes from stack allocation to dynamic allocation to avoid compiler warnings about excessive stack frame size (1392 bytes exceeding the 1280 byte limit).
  2. **No security impact from the change**: The change from:
     ```c
     struct mlx5_async_cmd async_cmd[MAX_ASYNC_CMDS];  // Stack allocation
     ```
     to:
     ```c
     struct mlx5_async_cmd *async_cmd;
     async_cmd = kcalloc(MAX_ASYNC_CMDS, sizeof(*async_cmd), GFP_KERNEL);
     ```
     doesn't fix any security vulnerability. It's a coding practice improvement to reduce stack usage.
  3. **Graceful handling of allocation failure**: When the new `kcalloc()` fails, the function simply returns early without cleaning up hardware resources. This is not a security issue but rather a resource cleanup optimization that gets skipped in low memory conditions. The commit message even acknowledges this is acceptable behavior.
  4. **No memory corruption or privilege escalation**: The original code with large stack allocation didn't cause any memory corruption, use-after-free, buffer overflow, or privilege escalation. It simply used more stack space than recommended.
  5. **Similar to non-CVE commits**: This is similar to the pattern in Similar Commit 1 and 2 which were marked as "CVE Status: NO" - they fix resource management and cleanup issues without security implications.
  The commit is a legitimate code improvement for better stack usage management, but it does not address any security vulnerability that would warrant a CVE assignment.
8d2c2fa2209e8 firmware: exynos-acpm: fix timeouts on xfers handling
- [sasha] Now let me analyze the code changes in the fix commit:
  **NO**
  This commit fixes a timing issue in the ACPM firmware driver but does not represent a security vulnerability. Here's why:
  1. **Nature of the bug**: The issue is a race condition in timeout handling where multiple transfers could have their timeout counters running in parallel. This caused legitimate transfers to timeout prematurely (false positives), resulting in functional issues but not security problems.
  2. **Impact**: The impact is limited to:
     - Performance degradation (unnecessary delays)
     - False timeout errors for legitimate operations
     - Potential denial of service only in terms of functionality, not a security DoS
  3. **No security boundaries crossed**: The fix reorganizes the order of operations (moving mailbox operations inside the TX lock) to ensure proper serialization. This doesn't:
     - Allow unauthorized access
     - Enable privilege escalation
     - Expose sensitive data
     - Allow memory corruption
     - Enable code execution
  4. **Code analysis**: The changes show:
     - Moving `mbox_send_message()` and `mbox_client_txdone()` inside the TX lock scope
     - Changed `mbox_client_txdone()` parameter from `ret` to `0`
     - This ensures the doorbell is rung immediately after TX write, preventing timeout races
  5. **Similar to reference commits**: Like the similar commits shown (mailbox timeout fixes in arm_scmi, imx, idpf, fbnic, and pcc drivers), this is a functional timing/synchronization fix rather than a security vulnerability.
  The commit improves reliability and performance but doesn't fix a vulnerability that could be exploited for malicious purposes.
4c46a471be122 firmware: arm_ffa: Fix the missing entry in struct ffa_indirect_msg_hdr
- [sasha] Based on my analysis:
  **NO** - This commit should NOT be assigned a CVE.
  **Explanation:**
  1. **Nature of the fix**: This is a structural alignment fix to match the FF-A (Firmware Framework for Arm) specification. The commit adds a missing reserved field (`res1`) in the `ffa_indirect_msg_hdr` structure.
  2. **No security vulnerability**: The missing field does not create a security vulnerability. It's a specification compliance issue where:
     - The structure was 4 bytes shorter than specified (36 bytes instead of 40 bytes)
     - The UUID field was at offset 20 instead of offset 24
  3. **Limited impact**: 
     - The buffer is properly allocated with sufficient size (`drv_info->rxtx_bufsz`)
     - The offset calculation uses `sizeof(*msg)` which would be incorrect but not exploitable
     - There's no buffer overflow or memory corruption possibility
     - The data after the header is copied using the offset field which is set to `sizeof(*msg)`
  4. **Interoperability issue**: This is primarily an interoperability/compatibility issue with firmware expecting the correct structure layout per the FF-A v1.2 specification. The firmware might read the UUID from the wrong offset, causing functional issues but not security vulnerabilities.
  5. **Similar commits**: The referenced similar commits show that structure definition updates and specification compliance fixes in the FF-A driver are typically not assigned CVEs, as they don't represent security vulnerabilities.
  The commit fixes a specification compliance bug that could cause functional issues when communicating with FF-A compliant firmware, but does not introduce or fix any security vulnerability.
9ca7a421229bb firmware: arm_ffa: Replace mutex with rwlock to avoid sleep in atomic context
- [sasha] Based on my analysis, here is my assessment:
  **NO**
  This commit should NOT be assigned a CVE for the following reasons:
  1. **Not a security vulnerability**: The issue is a "sleep in atomic context" warning that affects system stability/functionality in PREEMPT_RT kernels, but does not create a security vulnerability. The warning trace shows:
     ```
     BUG: sleeping function called from invalid context at kernel/locking/mutex.c:258
     ```
  2. **Limited scope**: The issue only affects PREEMPT_RT (real-time) kernel configurations, which is a specialized kernel variant used for real-time applications. Standard kernels are not affected.
  3. **Nature of the fix**: The fix simply replaces a mutex with a rwlock to avoid sleeping in atomic context. This is a correctness fix for proper locking semantics, not a security fix:
     ```c
     - struct mutex notify_lock; /* lock to protect notifier hashtable  */
     + rwlock_t notify_lock; /* lock to protect notifier hashtable  */
     ```
  4. **No security impact**: The commit message and code changes show this is purely about fixing incorrect locking that could cause warnings/deadlocks in PREEMPT_RT kernels. There's no mention of:
     - Memory corruption
     - Privilege escalation
     - Information disclosure
     - Access control bypass
     - Any other security-relevant issues
  5. **Similar to previous commits**: Looking at the similar commits provided, the ones marked with "CVE Status: YES" involved:
     - Memory allocation in atomic context that could lead to system crashes
     - Spinlock usage in RT kernels causing actual functional failures
     - But even those were borderline cases
  This is a functional correctness fix for PREEMPT_RT kernels to avoid potential deadlocks, not a security vulnerability.
27e850c88df0e firmware: arm_ffa: Move memory allocation outside the mutex locking
- [sasha] Based on my analysis of the commit and its context, I can now provide my assessment:
  **NO**
  This commit should NOT be assigned a CVE. Here's my reasoning:
  1. **Not a Security Vulnerability**: This is a preparatory refactoring commit that moves memory allocation outside a mutex-protected region. The commit message explicitly states this is done "in preparation to move from using mutexes to rwlocks."
  2. **No Current Security Impact**: While the commit mentions avoiding "potential sleeping in atomic context," this is only a future concern once the mutex is converted to rwlock. At the time of this commit, the code still uses mutexes, which are allowed to sleep.
  3. **Code Safety**: The changes maintain the same functionality:
     - Memory allocation is moved from inside `update_notifier_cb()` to `__ffa_notify_request()`
     - The allocated memory is properly freed on error paths (`out_unlock_free` label)
     - No race conditions or memory leaks are introduced
  4. **Comparison with Similar Commits**: Looking at the similar commits marked with "CVE Status: YES", those involved:
     - Actual bugs causing sleeping in atomic context (af_packet, xilinx commits)
     - Real security issues like buffer overflows or access control problems
     - This commit has none of these characteristics
  5. **Nature of Fix**: This is purely a code refactoring to prepare for future changes. The "Fixes:" tag references the original implementation, but not because it had a security bug - rather to indicate which commit this refactoring relates to.
  The actual security-relevant issue (sleeping in atomic context) only occurs in the subsequent commit that converts mutex to rwlock, not in this preparatory change.
a833d31ad8671 firmware: arm_ffa: Fix memory leak by freeing notifier callback node
- [sasha] Based on my analysis, here's my determination:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Clear Memory Leak**: The code allocates memory for `struct notifier_cb_info` during notification registration (`kzalloc(sizeof(*cb_info), GFP_KERNEL)`) but fails to free it during unregistration. The fix adds the missing `kfree(cb_info)` after `hash_del(&cb_info->hnode)`.
  2. **Security Impact**: This is a kernel memory leak that occurs each time a notification callback is registered and then unregistered. The `struct notifier_cb_info` contains:
     - hlist_node (16 bytes on 64-bit)
     - ffa_device pointer (8 bytes)
     - Two callback pointers (16 bytes)
     - cb_data pointer (8 bytes)
     Total: approximately 48+ bytes per leak
  3. **Attack Vector**: ARM FFA (Firmware Framework for Armv8-A) is used for communication between different security domains (Normal world, Secure world, VMs). A malicious or buggy client could repeatedly register and unregister notification callbacks to exhaust kernel memory, leading to:
     - Denial of Service through memory exhaustion
     - System instability
     - Potential crashes
  4. **Similar to CVE-assigned commits**: Looking at the similar commits provided:
     - Commit 2 (firmware_loader memory leak) - CVE assigned
     - Commit 3 (ath12k UAF) - CVE assigned  
     - Commits 4 & 5 (phy_led_triggers memory leak) - CVE assigned
     These all involve memory management issues (leaks/UAF) in kernel drivers, similar to this case.
  5. **Exploitability**: While the ARM FFA driver requires specific hardware/firmware support, on systems where it's available, any privileged process that can access the FFA interface could trigger this leak repeatedly.
  The fix is straightforward - adding the missing `kfree(cb_info)` in the unregistration path, which confirms this was an oversight in the original implementation that creates a memory leak vulnerability.
226862f50a7a8 drm/v3d: Disable interrupts before resetting the GPU
- [sasha] Based on my analysis of the commit and the kernel trace in the commit message, here's my assessment:
  **YES**
  This commit should be assigned a CVE based on the following analysis:
  1. **NULL pointer dereference vulnerability**: The kernel trace shows a NULL pointer dereference at virtual address 0x00000000000000c0 in the v3d_irq() function, occurring when the system tried to access a structure member at offset 0xc0 from a NULL pointer.
  2. **Race condition causing kernel panic**: The issue occurs when an interrupt is triggered during GPU reset. The trace shows the system was handling an interrupt (el1h_64_irq) when it crashed. The specific line in v3d_irq+0xec points to accessing job structures that have become NULL.
  3. **Security impact**: This vulnerability can cause:
     - Kernel panic and system crash (DoS)
     - Potential for exploitation if an attacker can trigger GPU resets while interrupts are being processed
     - The crash happens in interrupt context, making it particularly severe
  4. **Root cause**: Looking at the code changes, the issue is that during GPU reset, job pointers (v3d->bin_job, v3d->render_job, etc.) can be accessed by interrupt handlers while the GPU is being reset. The interrupt handler tries to dereference these pointers (e.g., line 106: `to_v3d_fence(v3d->bin_job->base.irq_fence)`) without checking if they're NULL.
  5. **Fix validates the vulnerability**: The fix adds:
     - `v3d_irq_disable(v3d)` before GPU reset
     - `synchronize_irq()` calls to ensure no interrupt handlers are in-flight
     - Proper interrupt state tracking with the new `v3d->irq[]` array
  This matches the pattern of CVE-worthy bugs seen in the similar commits, particularly those involving NULL pointer dereferences in interrupt/critical contexts that can cause kernel panics.
ec54c0a20709e mtk-sd: reset host->mrq on prepare_data() error
- [sasha] Now I understand the issue. Let me analyze the potential security impact:
  **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Not a security vulnerability**: The issue being fixed is a dangling pointer (host->mrq) that remains set after an error path. However, this doesn't lead to exploitable security issues like:
     - Memory corruption
     - Use-after-free
     - Privilege escalation
     - Information disclosure
  2. **Limited impact**: The consequences of leaving host->mrq set are:
     - A WARN_ON() will trigger on the next request: `WARN_ON(!host->hsq_en && host->mrq)` at line 1483
     - This is a diagnostic warning, not a security issue
     - The code still sets host->mrq to the new value, overwriting the dangling pointer
  3. **No memory safety issues**: Unlike the referenced CVE commits (commits 2-4 in the similar commits):
     - There's no NULL pointer dereference
     - There's no double-free condition
     - There's no use-after-free scenario
     - The mrq pointer is just a reference to a request structure that's handled elsewhere
  4. **Quality improvement**: This is a code quality fix that ensures cleaner state management and prevents a warning message, but doesn't fix any security vulnerability.
  The commit correctly fixes an incomplete error path cleanup, but the impact is limited to triggering a diagnostic warning on subsequent operations - not a security issue warranting a CVE assignment.
f5de469990f19 mtk-sd: Prevent memory corruption from DMA map failure
- [sasha] Based on my analysis of the commit message and code changes, I need to determine if this commit should be assigned a CVE.
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Memory Corruption Vulnerability**: The commit message explicitly states "Prevent memory corruption from DMA map failure" and describes how the vulnerability can "lead a memory corruption". Memory corruption is a serious security vulnerability.
  2. **Failure Path Vulnerability**: The issue occurs when `msdc_prepare_data()` fails to map the DMA region (when `dma_map_sg()` returns 0), but the code still proceeds to `msdc_start_data()` which then calls `msdc_dma_setup()`. This function uses `data->sg_count` in a for loop at line 803 to iterate through scatter-gather entries.
  3. **Use of Uninitialized/Invalid Data**: When DMA mapping fails, `data->sg_count` would be 0 or contain stale data from a previous operation, but `msdc_dma_setup()` would still use the previous DMA settings and potentially access invalid memory regions, leading to memory corruption.
  4. **Similar to CVE-assigned commits**: This commit has similar characteristics to the example commits that were assigned CVEs:
     - Like the "mt76: mt7915: fix tx skb dma unmap" commit, it fixes improper DMA handling
     - Like the "net: ethernet: mtk_eth_soc: fix memory corruption" commit, it prevents memory corruption by fixing bounds/validation issues
  5. **Exploitable Impact**: The vulnerability could potentially be exploited by triggering DMA mapping failures (e.g., through memory pressure) to cause the driver to use stale DMA configurations, potentially leading to arbitrary memory access.
  The fix adds a check `msdc_data_prepared()` to verify that DMA mapping succeeded before proceeding with the operation, preventing the memory corruption scenario.
539d80575b810 mtk-sd: Fix a pagefault in dma_unmap_sg() for not prepared data
- [sasha] Let me examine the security implications of this bug. Based on the commit message and code changes:
  **NO**
  This commit should not be assigned a CVE. Here's my analysis:
  1. **Nature of the bug**: This is a bug handling error path when `dma_map_sg()` fails (returns 0) due to swiotlb buffer being full. The code incorrectly sets the `MSDC_PREPARE_FLAG` even when DMA mapping fails, leading to an improper call to `dma_unmap_sg()` on unmapped pages.
  2. **Impact**: The bug causes a page fault (kernel crash) when the system is under memory pressure and swiotlb buffer is full. This is a reliability/stability issue, not a security vulnerability.
  3. **Exploitability**: This bug:
     - Cannot be triggered intentionally by an attacker
     - Requires specific system conditions (swiotlb buffer full)
     - Does not lead to privilege escalation, information disclosure, or arbitrary code execution
     - Only causes a system crash under rare conditions
  4. **Comparison with similar commits**: The similar commits with CVE status YES involved:
     - DMA buffer leaks that could lead to memory exhaustion attacks
     - Improper DMA unmapping that could lead to use-after-free conditions
     - Race conditions in DMA handling
  This commit differs because it's simply fixing a crash in an error handling path when system resources are exhausted, not fixing a security vulnerability.
  The fix properly checks if `dma_map_sg()` succeeded before setting the `MSDC_PREPARE_FLAG`, preventing the incorrect `dma_unmap_sg()` call in the cleanup path.
af4db5a35a4ef usb: typec: altmodes/displayport: do not index invalid pin_assignments
- [sasha] Based on my analysis of this commit, I need to determine if it should be assigned a CVE.
  **YES**
  This commit fixes a security vulnerability that can cause a BRK exception (kernel crash) due to an out-of-bounds array access. Here's my analysis:
  1. **Security Impact**: The commit fixes an out-of-bounds array access in `pin_assignment_show()` that occurs when a malicious or poorly implemented DisplayPort Alt Mode port partner indicates pin assignment capabilities greater than `DP_PIN_ASSIGN_F` (which is index 5).
  2. **Vulnerability Details**: 
     - The `pin_assignments` array has 6 elements (indices 0-5)
     - The loop in `pin_assignment_show()` originally had no upper bound check: `for (i = 0; assignments; assignments >>= 1, i++)`
     - If `assignments` has bits set beyond position 5, the code would access `pin_assignments[i]` with i > 5, causing an out-of-bounds read
  3. **Attack Vector**: A malicious USB Type-C device could exploit this by advertising invalid pin assignment capabilities in its VDO (Vendor Defined Object), triggering the vulnerability when a user reads the sysfs attribute.
  4. **Fix**: The patch adds `i < DP_PIN_ASSIGN_MAX` to the loop condition and defines `DP_PIN_ASSIGN_MAX` in the enum, preventing the out-of-bounds access.
  5. **Similarity to CVE-assigned commits**: This is similar to the CVE-assigned commits shown in the examples that fix NULL pointer dereferences and race conditions in the same subsystem. The vulnerability allows external hardware to crash the kernel, which is a denial-of-service security issue.
  The commit message explicitly states this causes a "BRK exception," which is a kernel crash, making this a clear security vulnerability that warrants a CVE assignment.
1e7ab6f678243 anon_inode: rework assertions
- [sasha] Based on my analysis of the commit and code changes, my answer is:
  **NO**
  This commit should not be assigned a CVE because:
  1. **No security vulnerability is being fixed** - The commit is reverting a change that made anonymous inodes appear as regular files internally, which caused "regression potential" and compatibility issues (particularly with io_uring), but there's no indication of an exploitable security vulnerability.
  2. **The changes are assertion/compatibility fixes** - The code modifications are:
     - Reverting `i_mode` from `S_IFREG | S_IRUSR | S_IWUSR` back to `S_IRUSR | S_IWUSR` (no file type)
     - Updating VFS assertions to properly handle anonymous inodes (`VFS_BUG_ON_INODE(!IS_ANON_FILE(inode), inode)`)
     - Adding safety checks for `path_noexec()` with anonymous inodes
  3. **No exploitable impact** - Unlike the historical ext4 commit that received a CVE (which fixed "silent memory corruption"), this commit doesn't address memory corruption, privilege escalation, information disclosure, or any other security vulnerability.
  4. **Functional/compatibility fix** - The commit message explicitly mentions "risk and regression potential" and a "hickup in io_uring" rather than security issues. This is fixing functional problems introduced by the previous change, not security vulnerabilities.
  The commit is properly marked as a fix and sent to stable kernels, but it's addressing correctness and compatibility rather than security.
4cf65845fdd09 Input: cs40l50-vibra - fix potential NULL dereference in cs40l50_upload_owt()
- [sasha] Based on my analysis, here is my determination:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **NULL pointer dereference vulnerability**: The original code at line 240 calls `kmalloc()` but doesn't check if it returns NULL. The very next line (242) immediately dereferences this pointer with `memcpy(new_owt_effect_data, ...)`, which will cause a kernel NULL pointer dereference if the allocation fails.
  2. **User-triggerable**: This vulnerability can be triggered by unprivileged users who have access to the input device. The `cs40l50_add()` function is registered as the `ff->upload` handler (line 519), which can be called via the force feedback ioctl interface when users upload custom haptic effects.
  3. **Attack path**: A local attacker could:
     - Open the input device file (typically /dev/input/eventX)
     - Upload a custom force feedback effect with specific parameters that reach the `cs40l50_upload_owt()` function
     - If memory allocation fails (which can be induced under memory pressure), the NULL dereference occurs
  4. **Security impact**: This results in a kernel crash (denial of service), requiring system restart. While it's not a privilege escalation or memory corruption vulnerability, it still represents a security issue as it allows local users to crash the system.
  5. **Similar to other CVE-assigned commits**: This follows the same pattern as the similar commits shown with "CVE Status: YES" - they all fix NULL pointer dereferences after failed memory allocations (kmalloc, devm_kzalloc, etc.) without proper NULL checks.
  The fix correctly adds the missing NULL check (lines 240-241 in the patched version) and returns -ENOMEM on allocation failure, preventing the NULL pointer dereference.
c9764fd88bc74 regulator: gpio: Fix the out-of-bounds access to drvdata::gpiods
- [sasha] Now I have a complete understanding of the issue. Let me analyze:
  **YES**
  This commit fixes a clear out-of-bounds memory access vulnerability that should be assigned a CVE. Here's why:
  1. **Memory Allocation Error**: The original code allocates memory for only ONE pointer (`sizeof(struct gpio_desc *)`) regardless of the value of `config->ngpios`:
     ```c
     drvdata->gpiods = devm_kzalloc(dev, sizeof(struct gpio_desc *), GFP_KERNEL);
     ```
  2. **Out-of-Bounds Access**: The code then accesses this array in a loop from 0 to `config->ngpios - 1`:
     ```c
     for (i = 0; i < config->ngpios; i++) {
         drvdata->gpiods[i] = devm_gpiod_get_index(...);
     ```
     When `config->ngpios > 1`, this causes out-of-bounds writes beyond the allocated memory.
  3. **Runtime Access**: The vulnerability is also triggered during runtime operations when setting voltages/currents:
     ```c
     for (ptr = 0; ptr < data->nr_gpios; ptr++) {
         gpiod_set_value_cansleep(data->gpiods[ptr], state);
     }
     ```
  4. **Security Impact**: This is a heap buffer overflow that can lead to:
     - Memory corruption
     - Potential arbitrary code execution if exploited
     - System crashes/denial of service
  5. **Similar to CVE-worthy commits**: This follows the same pattern as the similar commits shown, particularly the "invalid memory access" commits which were assigned CVEs. The vulnerability allows writing beyond allocated bounds, potentially corrupting adjacent heap memory.
  The fix correctly changes from `devm_kzalloc()` to `devm_kcalloc()` with the proper size calculation to allocate memory for `config->ngpios` pointers.
818625570558c iommufd/selftest: Fix iommufd_dirty_tracking with large hugepage sizes
- [sasha] **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Test-only code**: The changes are exclusively in `tools/testing/selftests/iommu/iommufd.c`, which is selftest code that does not run in production systems. This is clearly visible from the file path and the test fixture definitions (`FIXTURE()`, `FIXTURE_SETUP()`, etc.).
  2. **No kernel vulnerability**: The issue being fixed is in userspace test code, not in the actual kernel iommufd driver. The "memory wipe out" mentioned in the commit message refers to test memory being overwritten due to incorrect size calculations when using hugepages in the test setup.
  3. **Test infrastructure bug**: The problem is that when `posix_memalign()` allocates memory with a size smaller than the system's default hugepage size (e.g., 64MB/128MB vs 512MB), and then `mmap()` is called with `MAP_HUGETLB`, the kernel rounds up the size to the hugepage boundary. This causes memory beyond the originally allocated size to be mapped, potentially overwriting adjacent memory regions in the test process.
  4. **Fix details**: The patch:
     - Adjusts the allocation size to match what `mmap()` will actually use when hugepages are requested
     - Changes from `munmap()` to `free()` for memory allocated with `posix_memalign()` (proper cleanup)
     - Only affects test reliability, not system security
  5. **Similar commits**: The referenced similar commits (CVE Status: NO) also deal with selftest fixes for bitmap sizing and buffer calculations, none of which were assigned CVEs.
  This is a legitimate bug fix that improves test reliability, but it has no security implications for production systems.
f3cb5676e5c11 Bluetooth: MGMT: mesh_send: check instances prior disabling advertising
- [sasha] Based on my analysis of this commit:
  **NO**
  This commit does not fix a security vulnerability that warrants a CVE. Here's why:
  1. **Functional Bug, Not Security**: The issue being fixed is a functional bug where mesh advertising completion was unconditionally disabling ALL advertising instances, including non-mesh related ones. This is a functionality problem, not a security vulnerability.
  2. **No Security Impact**: The code change simply adds a check to only disable advertising if the advertising instances list is empty (`if (list_empty(&hdev->adv_instances))`). This prevents unintended disruption of other advertising operations but doesn't fix any:
     - Memory corruption
     - Privilege escalation
     - Information disclosure
     - Denial of service (beyond normal functionality)
     - Access control bypass
  3. **Similar to Historical Patterns**: Looking at the similar commits provided, they all have "CVE Status: NO" and deal with functional fixes in the Bluetooth subsystem like:
     - Iterating over wrong lists
     - Fixing invalid addresses in events
     - Using correct handles
     - Managing work queues properly
  4. **Impact is Limited**: The worst case scenario is that legitimate advertising instances get incorrectly disabled when mesh operations complete. This is a usability/functionality issue that doesn't compromise system security.
  The fix is appropriate and necessary for proper Bluetooth mesh functionality, but it addresses a logic error rather than a security vulnerability.
e5af67a870f73 Bluetooth: MGMT: set_mesh: update LE scan interval and window
- [sasha] Looking at this commit, I need to analyze whether it fixes a security vulnerability that warrants a CVE assignment.
  Let me examine the commit details:
  **Subject**: Bluetooth: MGMT: set_mesh: update LE scan interval and window
  **What the commit does**:
  - Fixes MGMT_OP_SET_MESH_RECEIVER to properly handle scan interval and window parameters
  - Previously these parameters were "silently ignored"
  - Adds validation for the period and window parameters (must be between 0x0004-0x4000, window must not exceed period)
  **Code changes analysis**:
  1. In `set_mesh_sync()`:
     - Now sets `hdev->le_scan_interval` and `hdev->le_scan_window` from the command parameters
     - Previously these were ignored
  2. In `set_mesh()`:
     - Adds input validation for period and window parameters
     - Returns `MGMT_STATUS_INVALID_PARAMS` if values are out of range
  **Security implications**:
  - This is primarily a **functionality fix** - the feature wasn't working as documented/expected
  - The lack of parameter validation could potentially have allowed invalid values, but:
    - The parameters are constrained to reasonable ranges (0x0004-0x4000)
    - These are scan timing parameters, not memory addresses or sizes
    - No buffer overflows, memory corruption, or privilege escalation risks are evident
    - The impact is limited to scan timing configuration
  **Comparison with similar commits**:
  Looking at the historical CVE assignments provided:
  - Commit 1 (CVE: YES) - Fixed a buffer overflow where data could exceed allocated size
  - Commits 2-5 (CVE: NO) - Fixed functionality issues, incorrect iterations, timing adjustments, state management
  This commit is more similar to commits 2-5 that fix functionality issues rather than security vulnerabilities.
  **Answer**: NO
  This commit fixes a functionality issue where scan parameters were being ignored, not a security vulnerability. While it adds input validation, the lack of validation previously would only have allowed setting invalid scan timing parameters, which doesn't constitute a security risk. The fix ensures the feature works as documented but doesn't address any memory safety issues, privilege escalation, or other security concerns that would warrant a CVE assignment.
46c0d947b64ac Bluetooth: hci_sync: revert some mesh modifications
- [sasha] **NO**, this commit should not be assigned a CVE.
  This commit is a code cleanup that removes redundant error handling patterns. The changes fix coding style issues where the same condition `ext_adv_capable(hdev)` was being checked twice consecutively:
  ```c
  // Before (redundant pattern):
  if (ext_adv_capable(hdev))
      err = hci_clear_adv_sets_sync(hdev, sk);
  if (ext_adv_capable(hdev))
      return err;
  // After (cleaned up):
  if (ext_adv_capable(hdev))
      return hci_clear_adv_sets_sync(hdev, sk);
  ```
  The commit message explicitly states these were "development purposes" changes that "shouldn't have been part of the commit." This indicates debugging or temporary code that was accidentally left in.
  There is no security vulnerability here because:
  1. The redundant checks don't change the program's behavior or control flow
  2. No memory corruption, privilege escalation, or other security issues are present
  3. The fix is purely cosmetic/maintainability focused
  4. The functionality remains exactly the same before and after the change
  While marked with `Cc: stable`, this is for code quality/maintainability reasons, not security. Many non-security fixes are backported to stable kernels to improve code quality.
89fb8acc38852 Bluetooth: HCI: Set extended advertising data synchronously
- [sasha] Based on my analysis of the commit message and code changes:
  **YES**, this commit should be assigned a CVE.
  **Explanation:**
  1. **Information Disclosure Vulnerability**: The race condition between asynchronous advertising data setting and synchronous advertising enable could result in devices advertising with stale, incorrect, or potentially uninitialized data. This creates a real information disclosure risk where sensitive data from previous advertising sessions could be exposed.
  2. **Attack Surface**: The vulnerability affects all Bluetooth controllers that support extended advertising (a widely deployed feature in modern Bluetooth LE devices). An attacker within Bluetooth range could passively observe these incorrect advertisements to gather leaked information.
  3. **Exploitability**: While this is a race condition, it's reliably triggerable during normal advertising operations when extended advertising is used, making it a practical vulnerability rather than a theoretical one.
  4. **Security Impact**: The code changes show that previously, in `hci_cc_set_ext_adv_param()`, the advertising data update was triggered asynchronously via `hci_update_adv_data()` after receiving the command complete event. This created a window where advertising could be enabled (via `hci_setup_ext_adv_instance_sync()`) before the data was properly set, potentially exposing whatever data was previously in the advertising buffers.
  5. **Fixes Tag**: The commit explicitly marks this as fixing a regression introduced by commit a0fb3726ba55 ("Bluetooth: Use Set ext adv/scan rsp data if controller supports"), indicating this was a functional bug with security implications that affected stable kernel versions.
  The synchronous reordering implemented in this patch eliminates the race condition by ensuring advertising data is always set immediately after parameters and before enabling advertising, properly protecting against information disclosure.
14633da0f416f mmc: core: Adjust some error messages for SD UHS-II cards
- [sasha] Based on the commit information provided and my analysis:
  **NO**, this commit should not be assigned a CVE.
  **Explanation:**
  1. **Nature of the change**: The commit only changes the logging level from `pr_err()` to `pr_debug()` for an error message in the `sd_uhs2_phy_init()` function. This is a cosmetic change that affects only debug output, not functional behavior.
  2. **No security impact**: The code change does not:
     - Fix a security vulnerability
     - Address any memory safety issues (buffer overflows, memory leaks, etc.)
     - Fix access control problems
     - Resolve race conditions
     - Fix privilege escalation issues
     - Address any data corruption or integrity issues
  3. **Pure logging adjustment**: The commit message explicitly states it's adjusting error messages to debug mode "to avoid causing misunderstanding it is an error." This is a user experience improvement, not a security fix.
  4. **No functional changes**: The error handling logic remains exactly the same - the function still returns the error code. Only the visibility of the log message changes from always visible (pr_err) to debug-only (pr_debug).
  5. **Similar commits**: Looking at the similar commits provided as reference, they all have "CVE Status: NO" and involve functional changes to MMC/SD card handling, power management, or timing issues - yet none were assigned CVEs. This cosmetic logging change is even less significant than those functional changes.
  This is a typical maintenance commit that improves code quality and user experience but has no security implications whatsoever.
009c3a4bc41e8 mmc: core: sd: Apply BROKEN_SD_DISCARD quirk earlier
- [sasha] Looking at line 1503, this is called AFTER mmc_fixup_device at line 1501. So we have the order:
  1. Line 1501: `mmc_fixup_device(card, mmc_sd_fixups)` - This is where SD quirks would be applied
  2. Line 1503: `mmc_sd_setup_card` - Which calls `mmc_read_ssr` that sets `card->erase_arg` based on discard support
  The problem is that when `mmc_read_ssr` is determining the discard support and setting `card->erase_arg`, it doesn't check the `MMC_QUIRK_BROKEN_SD_DISCARD` quirk. This means even if the quirk is set earlier, the card will still advertise discard support.
  The quirk check only happens later in `mmc_blk_issue_discard_rq` in the block layer, but by that time, the card has already advertised discard support to the upper layers.
  Based on my analysis:
  **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Not a security vulnerability**: This is a timing issue in applying a hardware quirk for broken SD cards. The commit simply moves a quirk entry from one list (`mmc_blk_fixups`) to another (`mmc_sd_fixups`) to ensure it's applied earlier in the initialization sequence.
  2. **Hardware compatibility issue**: The issue being fixed is that certain SanDisk SD cards incorrectly report discard support when they don't actually support it. This can cause filesystem operations to fail, but it's a functionality/compatibility issue, not a security vulnerability.
  3. **No security impact**: The worst case scenario is that mkfs might fail when trying to format the card, potentially putting it in read-only mode. This is an availability issue at most, not a security vulnerability that could lead to privilege escalation, information disclosure, or other security impacts.
  4. **Similar commits marked as NO**: The similar commits provided show the same pattern - they all deal with SD/MMC card quirks for hardware compatibility issues and none were assigned CVEs.
  The commit is purely a bug fix to ensure hardware quirks are applied at the correct time during device initialization to prevent functionality issues with specific SD cards.
49b14db035135 mmc: sdhci-uhs2: Adjust some error messages and register dump for SD UHS-II card
- [sasha] Based on my analysis of this commit, here is my determination:
  **NO**
  This commit should NOT be assigned a CVE because:
  1. **No security vulnerability is being fixed**: The commit only changes log levels from `pr_warn` to `pr_debug` and replaces `sdhci_dumpregs` calls with `sdhci_dbg_dumpregs` calls. This is purely a cosmetic change to reduce unnecessary error messages.
  2. **No functional changes**: The code logic remains exactly the same - it still performs the same error handling, timeouts, and register operations. Only the verbosity of logging is being adjusted.
  3. **Purpose is to avoid user confusion**: As stated in the commit message, the change is to "avoid causing misunderstanding it is an error." The previous warning messages were misleading users into thinking there were errors when these were actually normal debug messages during UHS-II card initialization.
  4. **Similar to historical non-CVE commits**: Looking at the similar commits provided, they all involve error handling improvements, driver fixes, or feature adjustments without security implications. None were assigned CVEs.
  5. **No security-relevant patterns**: The code changes don't show any of the typical security patterns like:
     - Buffer overflow fixes
     - Memory leak fixes  
     - Access control changes
     - Input validation improvements
     - Race condition fixes
     - Privilege escalation fixes
  The commit is purely a logging/debugging improvement to make the driver less noisy during normal operation with UHS-II cards.
dcc3bcfc5b50c Revert "mmc: sdhci: Disable SD card clock before changing parameters"
- [sasha] Based on my analysis of this commit, here's my determination:
  **NO** - This commit should not be assigned a CVE.
  Here's my reasoning:
  1. **Not a security vulnerability fix**: This is a revert of a functional change, not a security fix. The original commit (fb3bbc46c94f) was attempting to fix a hardware compatibility issue with specific SD controllers and cards, not a security vulnerability.
  2. **No security impact**: The code changes only affect the timing sequence of SD card clock control:
     - The original change modified how the SD card clock is disabled before changing parameters
     - The revert returns to the previous behavior of directly writing 0 to SDHCI_CLOCK_CONTROL
     - There's no memory corruption, privilege escalation, access control bypass, or other security-relevant issue
  3. **Hardware compatibility issue**: The commit message clearly indicates this is about hardware compatibility problems ("trying to strictly conform to the SDHCI specification is causing problems"). The original change broke functionality for some users (referenced bug reports).
  4. **No exploitable condition**: The changes don't introduce or fix any condition that could be exploited by an attacker. It's purely about SD card clock timing management during normal operations.
  5. **Similar to the historical commits**: All 5 similar commits provided were marked as "CVE Status: NO" and dealt with similar MMC/SDHCI timing, clock, and hardware compatibility issues - none were security vulnerabilities.
  This is a functional regression fix for hardware compatibility, not a security vulnerability fix.
db44d088a5ab0 xfs: actually use the xfs_growfs_check_rtgeom tracepoint
- [sasha] Based on my analysis, **NO**, this commit should not be assigned a CVE.
  Here's my reasoning:
  1. **No Security Vulnerability**: This commit simply adds a missing tracepoint call (`trace_xfs_growfs_check_rtgeom()`) that was defined but never actually used. Tracepoints are debugging/monitoring infrastructure used for observability and have no impact on the security or correctness of the filesystem.
  2. **No Functional Change**: The commit only adds instrumentation code. It doesn't fix any security vulnerability, memory corruption, privilege escalation, or data integrity issue. The function's logic and validation checks remain unchanged.
  3. **Developer/Debugging Feature**: Tracepoints are primarily used by developers and system administrators for debugging and performance analysis. A missing tracepoint doesn't create any security exposure - it just means less visibility into the system's operation.
  4. **Similar to Historical Commits**: Looking at the similar commits provided, none of them received CVEs despite making more significant functional changes to the XFS filesystem code (like fixing integer truncation, adding locks, changing transaction reservations, etc.).
  The commit is simply completing the implementation of a debugging feature that was partially added in commit 59a57acbce282d. While it's tagged for stable kernels (v6.14), this is likely just to ensure consistent debugging capabilities across kernel versions, not because of any security implications.
2881ba9af073f mmc: sdhci: Add a helper function for dump register in dynamic debug mode
- [sasha] **NO**
  This commit does not need a CVE assignment. Here's why:
  1. **Not a security fix**: This commit adds a debugging helper macro `sdhci_dbg_dumpregs` that conditionally calls the existing `sdhci_dumpregs()` function based on dynamic debug settings. It doesn't fix any vulnerability.
  2. **Pure debugging infrastructure**: The change only affects how register dumps are triggered in debug scenarios. The macro:
     - Uses `DEFINE_DYNAMIC_DEBUG_METADATA` to create dynamic debug metadata
     - Checks if dynamic debugging is enabled or if DEBUG is defined
     - Simply calls the existing `sdhci_dumpregs()` function
  3. **No security impact**: The existing `sdhci_dumpregs()` function already exists and dumps register contents using `pr_err()`. This commit just provides a more flexible way to invoke it during debugging without changing any security-relevant behavior.
  4. **Similar to non-CVE commits**: This is similar to the "Revise printk(KERN_DEBUG ...) messages" commit which was marked as NO CVE - both are debugging/logging improvements without security implications.
  The commit is purely a code quality/debugging improvement that allows developers to control register dumps through dynamic debugging infrastructure rather than always printing with `pr_err()`.
5186ff7e1d0e2 net: libwx: fix the incorrect display of the queue number
- [sasha] Now I see the issue clearly. Let me analyze the fix:
  **NO**
  This commit fixes a display issue in ethtool that shows an incorrect queue count. The issue is:
  1. When setting `ethtool -L eth0 combined 1`, RSS is disabled (single queue)
  2. The code had a logic bug where if RSS has only 1 queue (`f->indices <= 1`), it would skip updating the FDIR indices
  3. This caused `wx_get_channels()` to report the old FDIR queue count instead of 1
  4. The fix adds `wx->ring_feature[RING_F_FDIR].indices = 1;` to properly set FDIR to 1 queue when RSS is disabled
  This is purely a **cosmetic/display bug** - the ethtool command shows incorrect information but the actual network functionality works correctly. The queue configuration itself is properly set to 1, only the display value is wrong. There's no security impact:
  - No memory corruption
  - No privilege escalation
  - No denial of service
  - No data exposure
  - Just incorrect information displayed to the user
  This is similar to the reference commits which also fix display/reporting issues or configuration problems without security implications.
a9bf67ee17051 iommufd/selftest: Add asserts testing global mfd
- [sasha] **NO**
  This commit should not be assigned a CVE. Here's why:
  1. **Location**: The changes are entirely in selftest code (`tools/testing/selftests/iommu/iommufd.c`), not in the kernel driver itself. Selftest code runs in userspace for testing purposes only.
  2. **Nature of the fix**: The commit adds two assert statements to verify that `mfd_buffer` and `mfd` are properly initialized:
     ```c
     assert(mfd_buffer != MAP_FAILED);
     assert(mfd > 0);
     ```
  3. **Impact**: The issue being fixed is that the selftests might use uninitialized or invalid values for `mfd_buffer` and `mfd`. This could cause test failures or crashes in the test suite, but:
     - It doesn't affect the kernel itself
     - It doesn't affect production systems
     - It only impacts developers running the test suite
  4. **Security implications**: There are no security implications for production systems. This is purely a test reliability issue where:
     - `memfd_mmap()` could return `MAP_FAILED` if memory allocation fails
     - `mfd` could be invalid if `memfd_create()` fails
     - Without the asserts, tests would continue with invalid values and potentially crash or produce incorrect results
  5. **Similar commits reference**: The similar commits shown (CVE Status: NO) also involve fixes to selftest code with no CVEs assigned, which aligns with the decision not to assign CVEs to test infrastructure issues.
  The fix improves test reliability by ensuring early detection of initialization failures, but it has no security impact on the kernel or production systems.
4b75e3babb852 iommufd/selftest: Add missing close(mfd) in memfd_mmap()
- [sasha] **NO**
  This commit should not be assigned a CVE. The change fixes a file descriptor leak in selftest code (`tools/testing/selftests/iommu/iommufd_utils.h`), not in the kernel itself. The `memfd_mmap()` function is only used in test programs that run in userspace during kernel testing.
  Key reasons:
  1. **Test code only**: The fix is in selftest utility code under `tools/testing/selftests/`, which doesn't run in production systems
  2. **Simple resource leak**: It's just a file descriptor leak in userspace test code when error paths are taken
  3. **No security impact**: File descriptor leaks in test programs don't cross security boundaries, escalate privileges, or affect system stability
  4. **Limited scope**: Even if triggered, the leak only affects the test process itself and is cleaned up when the test exits
  This is a code quality improvement to prevent resource exhaustion during extended test runs, but has no security implications worthy of a CVE assignment.
223e2288f4b8c vsock/vmci: Clear the vmci transport packet properly when initializing it
- [sasha] **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Limited scope of uninitialized data**: The code was already partially initializing fields with `memset(&pkt->proto, 0, sizeof(pkt->proto))` and `memset(&pkt->_reserved2, 0, sizeof(pkt->_reserved2))`. The main uninitialized data would be in the union `u` field, but this is explicitly set based on the packet type in the switch statement.
  2. **Stack allocation pattern**: The packet is often allocated on the stack (as seen in `vmci_transport_send_control_pkt_bh` with `static struct vmci_transport_packet pkt`), and the uninitialized data would be whatever was previously on the stack.
  3. **Not a direct information leak**: While the packet is sent via `vmci_datagram_send()`, this is an internal kernel communication mechanism between VMs and the hypervisor, not a direct interface to unprivileged userspace.
  4. **Defense in depth improvement**: This change is more of a defensive programming practice to ensure all fields are properly initialized, rather than fixing an exploitable vulnerability.
  5. **Similar commits marked NO**: Looking at the historical similar commits, we see that other initialization-related fixes in the vsock subsystem (like "vsock: reset socket state when de-assigning the transport") were marked as NO for CVE assignment.
  The commit improves code quality and prevents potential future issues, but doesn't fix an actively exploitable security vulnerability that would warrant a CVE.
cc9f7f65cd2f3 net: txgbe: request MISC IRQ in ndo_open
- [sasha] Based on my analysis, I can now provide a determination:
  **NO**, this commit should not be assigned a CVE.
  Here's my reasoning:
  1. **This is a fix, not a vulnerability introduction**: The commit cc9f7f65cd2f is fixing an issue introduced by commit aefd013624a1. The commit message clearly states "Move the creating of irq_domain for MISC IRQ from .probe to .ndo_open" and includes "Fixes:" tag.
  2. **The vulnerability exists in the referenced commit**: The actual vulnerability (race conditions and potential crashes) was introduced in commit aefd013624a1 ("net: txgbe: use irq_domain for interrupt controller"), not in this fix commit.
  3. **Pattern matches similar non-CVE commits**: Looking at the similar commits provided:
     - Commit 3 (aefd013624a1) which introduced the IRQ domain was marked "CVE Status: NO"
     - Commits 4 and 5 which fixed issues related to aefd013624a1 were also marked "CVE Status: NO"
  4. **Nature of the fix**: The commit moves IRQ setup from probe to ndo_open, which is a proper design pattern for network drivers and actually improves security by:
     - Reducing the window where interrupts could fire on uninitialized structures
     - Ensuring IRQ resources are only allocated when the device is actually in use
     - Maintaining consistency with queue IRQ handling
  5. **Similar commits with CVE status YES were different**: The commits marked with "CVE Status: YES" (commits 1 and 2) were fixing a system crash issue where "request_irq() for pdev->irq will conflict with request_threaded_irq() for txgbe->misc.irq, to cause system crash." This current commit is implementing a design improvement, not fixing a crash.
  The commit is a defensive fix that improves the driver's robustness by properly managing IRQ lifecycle, but it doesn't fix an exploitable vulnerability that would warrant a CVE assignment.
f030713e5abf6 dt-bindings: net: sophgo,sg2044-dwmac: Drop status from the example
- [sasha] Based on my analysis of this commit:
  **NO** - This commit should NOT be assigned a CVE.
  This commit is a pure documentation fix for device tree bindings. The changes are:
  1. **Removes `status = "disabled"`** from the example in the YAML binding file
  2. **Adds required properties `phy-handle` and `phy-mode`** to make the example complete
  The key reasons this is not a security vulnerability:
  1. **Documentation-only change**: This only modifies a YAML schema file used for device tree binding validation. It has no impact on actual kernel runtime behavior.
  2. **No security implications**: The `status = "disabled"` property in device tree examples is purely cosmetic. Its removal doesn't affect any security boundaries, access controls, or system behavior.
  3. **Validation improvement**: The commit actually improves the binding documentation by making the example complete and allowing proper validation (the commit message notes that having `status = "disabled"` prevents dt_binding_check from validating the example).
  4. **Similar to other NO-CVE commits**: This follows the same pattern as the similar commits shown - they are all device tree binding documentation fixes with no security implications (correcting property values, removing deprecated properties, fixing schema validation issues).
  The change is purely a quality improvement to ensure device tree binding examples are complete and can be properly validated by tooling.
b97a7972b1f4f s390/pci: Do not try re-enabling load/store if device is disabled
- [sasha] **NO**
  This commit is a logic fix in the s390 PCI error recovery path, not a security vulnerability. The change adds a check to prevent attempting load/store operations on a disabled PCI device:
  ```c
  /* The underlying device may have been disabled by the event */
  if (!zdev_enabled(zdev))
      return PCI_ERS_RESULT_NEED_RESET;
  ```
  The `zdev_enabled()` function checks bit 31 of the function handle to determine if the device is enabled. Without this check, the code would attempt to call `zpci_reset_load_store_blocked()` on a disabled device, which would likely fail but doesn't pose a security risk. This is purely a functional correctness issue in error recovery handling - there's no evidence of:
  - Memory corruption or buffer overflows
  - Privilege escalation 
  - Information disclosure
  - Unauthorized access
  The fix ensures proper error recovery flow by detecting disabled devices early and requesting a full reset instead of attempting partial recovery operations that would fail anyway.
45537926dd2aa s390/pci: Fix stale function handles in error handling
- [sasha] Based on my analysis of the commit and the kernel source code, my determination is:
  **YES**
  This commit should be assigned a CVE for the following reasons:
  1. **Security Vulnerability**: The bug allows the use of stale function handles in PCI error handling, which represents a "handle use-after-free" vulnerability. Using a stale function handle could potentially allow accessing the wrong PCI device, leading to:
     - Data corruption between PCI functions
     - Information disclosure across security boundaries
     - Potential privilege escalation if PCI functions belong to different security contexts (e.g., different VMs)
  2. **Race Condition**: There's a TOCTOU (Time-Of-Check-Time-Of-Use) vulnerability where the function handle could become stale between when the error event was generated and when it's processed.
  3. **Impact on Virtualization**: The code specifically mentions pass-through devices and has special handling for them. In virtualized environments where PCI devices are assigned to different VMs, using a stale handle could potentially allow cross-VM access.
  4. **Similar to Previous CVEs**: Looking at the similar commits, the pattern shows that missing validation checks in s390 PCI code have been assigned CVEs before (e.g., the missing IS_ERR check for zpci_create_device()).
  5. **Stable Backport**: The commit is marked for stable kernel backporting with "Cc: stable@vger.kernel.org", indicating the maintainers consider this a significant bug that needs to be fixed in older kernels.
  The fix properly validates that the function handle in the error event matches the current handle by calling `clp_refresh_fh()` to get the current handle from firmware and comparing it with the event's handle before use.
315dbdd7cdf6a virtio-net: ensure the received length does not exceed allocated size
- [sasha] Now I understand the vulnerability. Let me analyze the commit changes more closely:
  **YES**
  This commit should be assigned a CVE because it fixes an out-of-bounds read vulnerability in the virtio-net driver.
  The vulnerability occurs in the `xdp_linearize_page` function when processing mergeable receive buffers. The key security issues are:
  1. **Missing bounds check**: In the while loop that reads additional buffers from the ring (line 1820 in the original code), the code retrieves `buflen` from `virtnet_rq_get_buf()` but fails to validate that this length doesn't exceed the actual allocated buffer size.
  2. **Out-of-bounds read via memcpy**: The vulnerable code at line 1840 performs:
     ```c
     memcpy(page_address(page) + page_off, page_address(p) + off, buflen);
     ```
     If `buflen` exceeds the actual allocated size of the buffer, this memcpy will read beyond the allocated memory boundaries.
  3. **Untrusted input from device**: The `buflen` value comes from the virtio device via `virtqueue_get_buf_ctx()`, which means a malicious or compromised hypervisor/backend could provide an incorrect length value that exceeds the actual buffer allocation.
  The fix adds a new `check_mergeable_len()` function that validates the received length against the true allocated size stored in the context (`mrg_ctx`). This prevents the out-of-bounds read by ensuring `buflen` never exceeds the actual allocation minus the required room for headroom and tailroom.
  This vulnerability is similar to the CVE-assigned commits in the reference set that validate untrusted lengths from virtio devices (e.g., "virtio-net: Add validation for used length" and "virtio_net: Add hash_key_length check"), making it a clear security issue warranting a CVE assignment.
5177373c31318 virtio-net: xsk: rx: fix the frame's length check
- [sasha] Based on my analysis of the commit and the kernel tree context, my answer is:
  **YES** - This commit should be assigned a CVE.
  This commit fixes a buffer overflow vulnerability in the virtio-net XSK (AF_XDP) receive path. The bug allows network data to overflow beyond allocated buffer boundaries due to incorrect length validation in `buf_to_xdp()`.
  Specifically:
  1. The original code incorrectly added `vi->hdr_len` to the buffer size check for ALL buffers
  2. For the first buffer (which contains the virtio header), the actual available space is `xsk_pool_get_rx_frame_size()`, NOT `xsk_pool_get_rx_frame_size() + vi->hdr_len`
  3. This allowed frames that were `vi->hdr_len` bytes too large to pass validation for the first buffer
  4. Since `len` is data from network packets (potentially untrusted), this creates a buffer overflow where data can be written beyond the allocated XSK buffer
  The security impact includes:
  - Memory corruption from network-controlled data
  - Potential system crashes
  - Possible privilege escalation if exploited
  This is similar to other CVE-assigned virtio-net commits that fixed length validation issues (e.g., the "Add validation for used length" commit that received a CVE).
00a39d8652ff9 rtc: cmos: use spin_lock_irqsave in cmos_interrupt
- [sasha] Based on my analysis of the commit and the kernel code, here is my assessment:
  **YES**
  This commit fixes a genuine security vulnerability - a deadlock condition that can occur in the RTC CMOS interrupt handling code. Here's why this should be assigned a CVE:
  1. **Security Impact - Deadlock/DoS**: The bug causes a deadlock when `cmos_interrupt()` is called from non-interrupt contexts (like ACPI event handlers running in interrupt threads) while using `spin_lock()` instead of `spin_lock_irqsave()`. This can lead to system hangs/freezes, constituting a denial-of-service vulnerability.
  2. **Real-world Impact**: The commit message explicitly states this breaks S3-resume on certain systems (fi-kbl-soraka), meaning actual systems can become unresponsive during normal suspend/resume operations.
  3. **Root Cause**: The original commit 6950d046eb6e incorrectly assumed `cmos_interrupt()` would only be called in hard IRQ context, but the ACPI fixed event handler path (`rtc_handler()` → `cmos_interrupt()`) runs in an interrupt thread where interrupts are enabled, violating the locking assumptions.
  4. **Incomplete Prior Fix**: The commit 13be2efc390a attempted to fix this by adding `local_irq_disable()` workarounds in `cmos_check_wkalrm()`, but this was incomplete and problematic for PREEMPT_RT kernels.
  5. **Similar to CVE-assigned commits**: Looking at the similar commits with CVE status:
     - Similar Commit 1 & 2 (CVE Status: YES) fixed a similar deadlock in i915 driver where `spin_lock()` was incorrectly used instead of `spin_lock_irqsave()` in contexts that could have interrupts enabled
     - This commit follows the exact same pattern - fixing incorrect locking assumptions that lead to deadlocks
  The vulnerability allows local attackers to cause system hangs through normal system operations (suspend/resume), affecting system availability.
fa78e9b606a47 rtc: pcf2127: fix SPI command byte for PCF2131
- [sasha] Now I see the pattern. Different PCF chips use different SPI command byte formats. PCF2123 uses BIT(4) for write and BIT(4)|BIT(7) for read, while PCF2127 uses 0x20 (BIT(5)) for write and 0xa0 (BIT(7)|BIT(5)) for read.
  Based on my analysis of this commit:
  **NO** - This commit should NOT be assigned a CVE.
  Explanation:
  1. **Functional bug, not security vulnerability**: The issue is that PCF2131 RTC was not responding to SPI read/write operations because it uses different command byte requirements (0x0 for both read and write flags) compared to PCF2127/29 (which use 0xa0 for read and 0x20 for write).
  2. **No security impact**: This is a device driver initialization bug that prevents proper communication with the PCF2131 RTC over SPI. The worst case is that the RTC device simply doesn't work - it doesn't expose any security vulnerabilities like:
     - Memory corruption
     - Privilege escalation
     - Information disclosure
     - Access control bypass
  3. **Limited scope**: The bug only affects systems using the PCF2131 RTC chip with SPI interface. The I2C interface was not affected. This is a hardware-specific driver issue with no broader security implications.
  4. **Similar to non-CVE commits**: Looking at the similar commits provided, simple driver fixes for incorrect register masks or missing mode support (like commits 1 and 2) were marked as NO CVE, while only commit 3 that fixed a use-after-free vulnerability got a CVE.
  This is a straightforward functional fix to make the PCF2131 RTC work properly over SPI by setting the correct command byte format for that specific chip variant.
08d82d0cad51c rtc: pcf2127: add missing semicolon after statement
- [sasha] Based on my analysis, I can now provide a definitive answer:
  **NO**
  This commit should NOT be assigned a CVE. Here's why:
  1. **Syntax/Compilation Issue Only**: The change replaces a comma with a semicolon at the end of a statement (`config.max_register = variant->max_register,` → `config.max_register = variant->max_register;`). This is a pure syntax fix.
  2. **No Security Impact**: While using a comma instead of a semicolon is syntactically incorrect in this context, it would:
     - Either cause a compilation error (preventing the buggy code from ever running)
     - Or in some cases, create a comma expression that still assigns the value correctly but is stylistically wrong
  3. **No Runtime Behavioral Change**: The comma operator in C evaluates both expressions and returns the value of the second one. In this case, there's no second expression on the same line, so the behavior would be identical to using a semicolon.
  4. **Similar Historical Precedent**: All 5 similar commits shown (converting comma to semicolon) were marked as "CVE Status: NO", establishing a clear pattern that such syntax corrections are not security vulnerabilities.
  5. **No Security-Relevant Code Path**: This is in the RTC (Real-Time Clock) driver initialization code, specifically in the SPI probe function. The change doesn't affect:
     - Memory management
     - Access control
     - Input validation
     - Privilege levels
     - Any security-critical operations
  This is a code quality/style fix, not a security vulnerability fix.
