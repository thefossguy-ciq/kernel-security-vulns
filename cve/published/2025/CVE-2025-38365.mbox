From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2025-38365: btrfs: fix a race between renames and directory logging
Message-Id: <2025072558-CVE-2025-38365-0519@gregkh>
Content-Length: 6282
Lines: 138
X-Developer-Signature: v=1; a=openpgp-sha256; l=6421;
 i=gregkh@linuxfoundation.org; h=from:subject:message-id;
 bh=xObHPDFrt3THBnXYcWm2vNo4SFhfgBb4QmXkomFUVqs=;
 b=owGbwMvMwCRo6H6F97bub03G02pJDBnNNf8exkw0KKnU/fjOeuaWPf1TRNlCrLfc2Duz0mRaz
 RJX/eMuHbEsDIJMDLJiiixftvEc3V9xSNHL0PY0zBxWJpAhDFycAjAR9psMC87I7q1cLm0b8oc5
 PYDzcWTxrdw4PYYFl596+GxzvLZ630rDx0lnf/L7rhDqAgA=
X-Developer-Key: i=gregkh@linuxfoundation.org; a=openpgp;
 fpr=F4B60CC5BF78C2214A313DCB3147D40DDB2DFB29

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

btrfs: fix a race between renames and directory logging

We have a race between a rename and directory inode logging that if it
happens and we crash/power fail before the rename completes, the next time
the filesystem is mounted, the log replay code will end up deleting the
file that was being renamed.

This is best explained following a step by step analysis of an interleaving
of steps that lead into this situation.

Consider the initial conditions:

1) We are at transaction N;

2) We have directories A and B created in a past transaction (< N);

3) We have inode X corresponding to a file that has 2 hardlinks, one in
   directory A and the other in directory B, so we'll name them as
   "A/foo_link1" and "B/foo_link2". Both hard links were persisted in a
   past transaction (< N);

4) We have inode Y corresponding to a file that as a single hard link and
   is located in directory A, we'll name it as "A/bar". This file was also
   persisted in a past transaction (< N).

The steps leading to a file loss are the following and for all of them we
are under transaction N:

 1) Link "A/foo_link1" is removed, so inode's X last_unlink_trans field
    is updated to N, through btrfs_unlink() -> btrfs_record_unlink_dir();

 2) Task A starts a rename for inode Y, with the goal of renaming from
    "A/bar" to "A/baz", so we enter btrfs_rename();

 3) Task A inserts the new BTRFS_INODE_REF_KEY for inode Y by calling
    btrfs_insert_inode_ref();

 4) Because the rename happens in the same directory, we don't set the
    last_unlink_trans field of directoty A's inode to the current
    transaction id, that is, we don't cal btrfs_record_unlink_dir();

 5) Task A then removes the entries from directory A (BTRFS_DIR_ITEM_KEY
    and BTRFS_DIR_INDEX_KEY items) when calling __btrfs_unlink_inode()
    (actually the dir index item is added as a delayed item, but the
    effect is the same);

 6) Now before task A adds the new entry "A/baz" to directory A by
    calling btrfs_add_link(), another task, task B is logging inode X;

 7) Task B starts a fsync of inode X and after logging inode X, at
    btrfs_log_inode_parent() it calls btrfs_log_all_parents(), since
    inode X has a last_unlink_trans value of N, set at in step 1;

 8) At btrfs_log_all_parents() we search for all parent directories of
    inode X using the commit root, so we find directories A and B and log
    them. Bu when logging direct A, we don't have a dir index item for
    inode Y anymore, neither the old name "A/bar" nor for the new name
    "A/baz" since the rename has deleted the old name but has not yet
    inserted the new name - task A hasn't called yet btrfs_add_link() to
    do that.

    Note that logging directory A doesn't fallback to a transaction
    commit because its last_unlink_trans has a lower value than the
    current transaction's id (see step 4);

 9) Task B finishes logging directories A and B and gets back to
    btrfs_sync_file() where it calls btrfs_sync_log() to persist the log
    tree;

10) Task B successfully persisted the log tree, btrfs_sync_log() completed
    with success, and a power failure happened.

    We have a log tree without any directory entry for inode Y, so the
    log replay code deletes the entry for inode Y, name "A/bar", from the
    subvolume tree since it doesn't exist in the log tree and the log
    tree is authorative for its index (we logged a BTRFS_DIR_LOG_INDEX_KEY
    item that covers the index range for the dentry that corresponds to
    "A/bar").

    Since there's no other hard link for inode Y and the log replay code
    deletes the name "A/bar", the file is lost.

The issue wouldn't happen if task B synced the log only after task A
called btrfs_log_new_name(), which would update the log with the new name
for inode Y ("A/bar").

Fix this by pinning the log root during renames before removing the old
directory entry, and unpinning after btrfs_log_new_name() is called.

The Linux kernel CVE team has assigned CVE-2025-38365 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 5.18 with commit 259c4b96d78dda8477a3ac21d6b3cf0eb9f75c8b and fixed in 6.1.143 with commit 51bd363c7010d033d3334daf457c824484bf9bf0
	Issue introduced in 5.18 with commit 259c4b96d78dda8477a3ac21d6b3cf0eb9f75c8b and fixed in 6.6.96 with commit aeeae8feeaae4445a86f9815273e81f902dc1f5b
	Issue introduced in 5.18 with commit 259c4b96d78dda8477a3ac21d6b3cf0eb9f75c8b and fixed in 6.12.36 with commit 2088895d5903082bb9021770b919e733c57edbc1
	Issue introduced in 5.18 with commit 259c4b96d78dda8477a3ac21d6b3cf0eb9f75c8b and fixed in 6.15.5 with commit 8c6874646c21bd820cf475e2874e62c133954023
	Issue introduced in 5.18 with commit 259c4b96d78dda8477a3ac21d6b3cf0eb9f75c8b and fixed in 6.16-rc4 with commit 3ca864de852bc91007b32d2a0d48993724f4abad

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2025-38365
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	fs/btrfs/inode.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/51bd363c7010d033d3334daf457c824484bf9bf0
	https://git.kernel.org/stable/c/aeeae8feeaae4445a86f9815273e81f902dc1f5b
	https://git.kernel.org/stable/c/2088895d5903082bb9021770b919e733c57edbc1
	https://git.kernel.org/stable/c/8c6874646c21bd820cf475e2874e62c133954023
	https://git.kernel.org/stable/c/3ca864de852bc91007b32d2a0d48993724f4abad
