From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2025-38349: eventpoll: don't decrement ep refcount while still holding the ep mutex

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

eventpoll: don't decrement ep refcount while still holding the ep mutex

Jann Horn points out that epoll is decrementing the ep refcount and then
doing a

    mutex_unlock(&ep->mtx);

afterwards. That's very wrong, because it can lead to a use-after-free.

That pattern is actually fine for the very last reference, because the
code in question will delay the actual call to "ep_free(ep)" until after
it has unlocked the mutex.

But it's wrong for the much subtler "next to last" case when somebody
*else* may also be dropping their reference and free the ep while we're
still using the mutex.

Note that this is true even if that other user is also using the same ep
mutex: mutexes, unlike spinlocks, can not be used for object ownership,
even if they guarantee mutual exclusion.

A mutex "unlock" operation is not atomic, and as one user is still
accessing the mutex as part of unlocking it, another user can come in
and get the now released mutex and free the data structure while the
first user is still cleaning up.

See our mutex documentation in Documentation/locking/mutex-design.rst,
in particular the section [1] about semantics:

	"mutex_unlock() may access the mutex structure even after it has
	 internally released the lock already - so it's not safe for
	 another context to acquire the mutex and assume that the
	 mutex_unlock() context is not using the structure anymore"

So if we drop our ep ref before the mutex unlock, but we weren't the
last one, we may then unlock the mutex, another user comes in, drops
_their_ reference and releases the 'ep' as it now has no users - all
while the mutex_unlock() is still accessing it.

Fix this by simply moving the ep refcount dropping to outside the mutex:
the refcount itself is atomic, and doesn't need mutex protection (that's
the whole _point_ of refcounts: unlike mutexes, they are inherently
about object lifetimes).

The Linux kernel CVE team has assigned CVE-2025-38349 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 6.4 with commit 58c9b016e12855286370dfb704c08498edbc857a and fixed in 6.6.99 with commit 521e9ff0b67c66a17d6f9593dfccafaa984aae4c
	Issue introduced in 6.4 with commit 58c9b016e12855286370dfb704c08498edbc857a and fixed in 6.12.39 with commit 6dee745bd0aec9d399df674256e7b1ecdb615444
	Issue introduced in 6.4 with commit 58c9b016e12855286370dfb704c08498edbc857a and fixed in 6.15.7 with commit 605c18698ecfa99165f36b7f59d3ed503e169814
	Issue introduced in 6.4 with commit 58c9b016e12855286370dfb704c08498edbc857a and fixed in 6.16 with commit 8c2e52ebbe885c7eeaabd3b7ddcdc1246fc400d2

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2025-38349
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	fs/eventpoll.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/521e9ff0b67c66a17d6f9593dfccafaa984aae4c
	https://git.kernel.org/stable/c/6dee745bd0aec9d399df674256e7b1ecdb615444
	https://git.kernel.org/stable/c/605c18698ecfa99165f36b7f59d3ed503e169814
	https://git.kernel.org/stable/c/8c2e52ebbe885c7eeaabd3b7ddcdc1246fc400d2
	https://project-zero.issues.chromium.org/issues/430541637
