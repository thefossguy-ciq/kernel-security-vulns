From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2025-39988: can: etas_es58x: populate ndo_change_mtu() to prevent buffer overflow

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

can: etas_es58x: populate ndo_change_mtu() to prevent buffer overflow

Sending an PF_PACKET allows to bypass the CAN framework logic and to
directly reach the xmit() function of a CAN driver. The only check
which is performed by the PF_PACKET framework is to make sure that
skb->len fits the interface's MTU.

Unfortunately, because the etas_es58x driver does not populate its
net_device_ops->ndo_change_mtu(), it is possible for an attacker to
configure an invalid MTU by doing, for example:

  $ ip link set can0 mtu 9999

After doing so, the attacker could open a PF_PACKET socket using the
ETH_P_CANXL protocol:

	socket(PF_PACKET, SOCK_RAW, htons(ETH_P_CANXL));

to inject a malicious CAN XL frames. For example:

	struct canxl_frame frame = {
		.flags = 0xff,
		.len = 2048,
	};

The CAN drivers' xmit() function are calling can_dev_dropped_skb() to
check that the skb is valid, unfortunately under above conditions, the
malicious packet is able to go through can_dev_dropped_skb() checks:

  1. the skb->protocol is set to ETH_P_CANXL which is valid (the
     function does not check the actual device capabilities).

  2. the length is a valid CAN XL length.

And so, es58x_start_xmit() receives a CAN XL frame which it is not
able to correctly handle and will thus misinterpret it as a CAN(FD)
frame.

This can result in a buffer overflow. For example, using the es581.4
variant, the frame will be dispatched to es581_4_tx_can_msg(), go
through the last check at the beginning of this function:

	if (can_is_canfd_skb(skb))
		return -EMSGSIZE;

and reach this line:

	memcpy(tx_can_msg->data, cf->data, cf->len);

Here, cf->len corresponds to the flags field of the CAN XL frame. In
our previous example, we set canxl_frame->flags to 0xff. Because the
maximum expected length is 8, a buffer overflow of 247 bytes occurs!

Populate net_device_ops->ndo_change_mtu() to ensure that the
interface's MTU can not be set to anything bigger than CAN_MTU or
CANFD_MTU (depending on the device capabilities). By fixing the root
cause, this prevents the buffer overflow.

The Linux kernel CVE team has assigned CVE-2025-39988 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 5.13 with commit 8537257874e949a59c834cecfd5a063e11b64b0b and fixed in 5.15.194 with commit 72de0facc50afdb101fb7197d880407f1abfc77f
	Issue introduced in 5.13 with commit 8537257874e949a59c834cecfd5a063e11b64b0b and fixed in 6.1.155 with commit c4e582e686c4d683c87f2b4a316385b3d81d370f
	Issue introduced in 5.13 with commit 8537257874e949a59c834cecfd5a063e11b64b0b and fixed in 6.6.109 with commit cbc1de71766f326a44bb798aeae4a7ef4a081cc9
	Issue introduced in 5.13 with commit 8537257874e949a59c834cecfd5a063e11b64b0b and fixed in 6.12.50 with commit b26cccd87dcddc47b450a40f3b1ac3fe346efcff
	Issue introduced in 5.13 with commit 8537257874e949a59c834cecfd5a063e11b64b0b and fixed in 6.16.10 with commit e587af2c89ecc6382c518febea52fa9ba81e47c0
	Issue introduced in 5.13 with commit 8537257874e949a59c834cecfd5a063e11b64b0b and fixed in 6.17 with commit 38c0abad45b190a30d8284a37264d2127a6ec303

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2025-39988
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	drivers/net/can/usb/etas_es58x/es58x_core.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/72de0facc50afdb101fb7197d880407f1abfc77f
	https://git.kernel.org/stable/c/c4e582e686c4d683c87f2b4a316385b3d81d370f
	https://git.kernel.org/stable/c/cbc1de71766f326a44bb798aeae4a7ef4a081cc9
	https://git.kernel.org/stable/c/b26cccd87dcddc47b450a40f3b1ac3fe346efcff
	https://git.kernel.org/stable/c/e587af2c89ecc6382c518febea52fa9ba81e47c0
	https://git.kernel.org/stable/c/38c0abad45b190a30d8284a37264d2127a6ec303
