From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2025-39948: ice: fix Rx page leak on multi-buffer frames
Message-Id: <2025100420-CVE-2025-39948-7074@gregkh>
Content-Length: 5277
Lines: 110
X-Developer-Signature: v=1; a=openpgp-sha256; l=5388;
 i=gregkh@linuxfoundation.org; h=from:subject:message-id;
 bh=MPFAMc9J+LSV5feOkAmMiV0dx5RSiAfP8HP6S9SXdb4=;
 b=owGbwMvMwCRo6H6F97bub03G02pJDBkPzh7gOMO3M/TMIVkLmyfW9z9KdcRt+PBUKWODzfWNq
 b4WNnUiHbEsDIJMDLJiiixftvEc3V9xSNHL0PY0zBxWJpAhDFycAjCRUG6GBXNNnyk3ZE+Y3WCV
 +0ojxkyy47OSMsOCo1kP+ns2GLFfZZh/StUiXOb0OW02AA==
X-Developer-Key: i=gregkh@linuxfoundation.org; a=openpgp;
 fpr=F4B60CC5BF78C2214A313DCB3147D40DDB2DFB29

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

ice: fix Rx page leak on multi-buffer frames

The ice_put_rx_mbuf() function handles calling ice_put_rx_buf() for each
buffer in the current frame. This function was introduced as part of
handling multi-buffer XDP support in the ice driver.

It works by iterating over the buffers from first_desc up to 1 plus the
total number of fragments in the frame, cached from before the XDP program
was executed.

If the hardware posts a descriptor with a size of 0, the logic used in
ice_put_rx_mbuf() breaks. Such descriptors get skipped and don't get added
as fragments in ice_add_xdp_frag. Since the buffer isn't counted as a
fragment, we do not iterate over it in ice_put_rx_mbuf(), and thus we don't
call ice_put_rx_buf().

Because we don't call ice_put_rx_buf(), we don't attempt to re-use the
page or free it. This leaves a stale page in the ring, as we don't
increment next_to_alloc.

The ice_reuse_rx_page() assumes that the next_to_alloc has been incremented
properly, and that it always points to a buffer with a NULL page. Since
this function doesn't check, it will happily recycle a page over the top
of the next_to_alloc buffer, losing track of the old page.

Note that this leak only occurs for multi-buffer frames. The
ice_put_rx_mbuf() function always handles at least one buffer, so a
single-buffer frame will always get handled correctly. It is not clear
precisely why the hardware hands us descriptors with a size of 0 sometimes,
but it happens somewhat regularly with "jumbo frames" used by 9K MTU.

To fix ice_put_rx_mbuf(), we need to make sure to call ice_put_rx_buf() on
all buffers between first_desc and next_to_clean. Borrow the logic of a
similar function in i40e used for this same purpose. Use the same logic
also in ice_get_pgcnts().

Instead of iterating over just the number of fragments, use a loop which
iterates until the current index reaches to the next_to_clean element just
past the current frame. Unlike i40e, the ice_put_rx_mbuf() function does
call ice_put_rx_buf() on the last buffer of the frame indicating the end of
packet.

For non-linear (multi-buffer) frames, we need to take care when adjusting
the pagecnt_bias. An XDP program might release fragments from the tail of
the frame, in which case that fragment page is already released. Only
update the pagecnt_bias for the first descriptor and fragments still
remaining post-XDP program. Take care to only access the shared info for
fragmented buffers, as this avoids a significant cache miss.

The xdp_xmit value only needs to be updated if an XDP program is run, and
only once per packet. Drop the xdp_xmit pointer argument from
ice_put_rx_mbuf(). Instead, set xdp_xmit in the ice_clean_rx_irq() function
directly. This avoids needing to pass the argument and avoids an extra
bit-wise OR for each buffer in the frame.

Move the increment of the ntc local variable to ensure its updated *before*
all calls to ice_get_pgcnts() or ice_put_rx_mbuf(), as the loop logic
requires the index of the element just after the current frame.

Now that we use an index pointer in the ring to identify the packet, we no
longer need to track or cache the number of fragments in the rx_ring.

The Linux kernel CVE team has assigned CVE-2025-39948 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 6.12.14 with commit 311813ed013c016d4b0b0985a9ee41f778489077 and fixed in 6.12.49 with commit 80555adb5c892f0e21d243ae96ed997ee520aea9
	Issue introduced in 6.14 with commit 743bbd93cf29f653fae0e1416a31f03231689911 and fixed in 6.16.9 with commit fcb5718ebfe7fd64144e3399280440cce361a3ae
	Issue introduced in 6.14 with commit 743bbd93cf29f653fae0e1416a31f03231689911 and fixed in 6.17 with commit 84bf1ac85af84d354c7a2fdbdc0d4efc8aaec34b
	Issue introduced in 6.6.78 with commit ac1728cf370bec2e74fe6a2adf05b4629980d2b3
	Issue introduced in 6.13.3 with commit d445b59d30415bb56f4803f622d566bca06e0abc

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2025-39948
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	drivers/net/ethernet/intel/ice/ice_txrx.c
	drivers/net/ethernet/intel/ice/ice_txrx.h


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/80555adb5c892f0e21d243ae96ed997ee520aea9
	https://git.kernel.org/stable/c/fcb5718ebfe7fd64144e3399280440cce361a3ae
	https://git.kernel.org/stable/c/84bf1ac85af84d354c7a2fdbdc0d4efc8aaec34b
