From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2025-39748: bpf: Forget ranges when refining tnum after JSET

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

bpf: Forget ranges when refining tnum after JSET

Syzbot reported a kernel warning due to a range invariant violation on
the following BPF program.

  0: call bpf_get_netns_cookie
  1: if r0 == 0 goto <exit>
  2: if r0 & Oxffffffff goto <exit>

The issue is on the path where we fall through both jumps.

That path is unreachable at runtime: after insn 1, we know r0 != 0, but
with the sign extension on the jset, we would only fallthrough insn 2
if r0 == 0. Unfortunately, is_branch_taken() isn't currently able to
figure this out, so the verifier walks all branches. The verifier then
refines the register bounds using the second condition and we end
up with inconsistent bounds on this unreachable path:

  1: if r0 == 0 goto <exit>
    r0: u64=[0x1, 0xffffffffffffffff] var_off=(0, 0xffffffffffffffff)
  2: if r0 & 0xffffffff goto <exit>
    r0 before reg_bounds_sync: u64=[0x1, 0xffffffffffffffff] var_off=(0, 0)
    r0 after reg_bounds_sync:  u64=[0x1, 0] var_off=(0, 0)

Improving the range refinement for JSET to cover all cases is tricky. We
also don't expect many users to rely on JSET given LLVM doesn't generate
those instructions. So instead of improving the range refinement for
JSETs, Eduard suggested we forget the ranges whenever we're narrowing
tnums after a JSET. This patch implements that approach.

The Linux kernel CVE team has assigned CVE-2025-39748 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 5.0 with commit 960ea056561a08e2b837b2f02d22c53226414a84 and fixed in 6.12.43 with commit f01e06930444cab289a8783017af9b64255bd103
	Issue introduced in 5.0 with commit 960ea056561a08e2b837b2f02d22c53226414a84 and fixed in 6.15.11 with commit 2fd0c26bacd90ef26522bd3169000a4715bf151f
	Issue introduced in 5.0 with commit 960ea056561a08e2b837b2f02d22c53226414a84 and fixed in 6.16.2 with commit 80a6b11862a7cfdf691e8f9faee89cfea219f098
	Issue introduced in 5.0 with commit 960ea056561a08e2b837b2f02d22c53226414a84 and fixed in 6.17 with commit 6279846b9b2532e1b04559ef8bd0dec049f29383

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2025-39748
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	kernel/bpf/verifier.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/f01e06930444cab289a8783017af9b64255bd103
	https://git.kernel.org/stable/c/2fd0c26bacd90ef26522bd3169000a4715bf151f
	https://git.kernel.org/stable/c/80a6b11862a7cfdf691e8f9faee89cfea219f098
	https://git.kernel.org/stable/c/6279846b9b2532e1b04559ef8bd0dec049f29383
