From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2025-39992: mm: swap: check for stable address space before operating on the VMA
Message-Id: <2025101527-CVE-2025-39992-f580@gregkh>
Content-Length: 3856
Lines: 101
X-Developer-Signature: v=1; a=openpgp-sha256; l=3958;
 i=gregkh@linuxfoundation.org; h=from:subject:message-id;
 bh=MC94Xq84q4PTqifWApFbC2tmt6MRAu/WWPNl+dcddt0=;
 b=owGbwMvMwCRo6H6F97bub03G02pJDBnvQ5Rf7+3/vO+y2d75l1/fOMP3xDl/hs9JifuqprL8h
 7wkH9wr6ohlYRBkYpAVU2T5so3n6P6KQ4pehranYeawMoEMYeDiFICJzDnFME95i1t9XNANRuNT
 s1qfxa/N/ObUv4xhwaXpEoGfHz5Kc9zA/CDgBd+Bla/4egE=
X-Developer-Key: i=gregkh@linuxfoundation.org; a=openpgp;
 fpr=F4B60CC5BF78C2214A313DCB3147D40DDB2DFB29

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

mm: swap: check for stable address space before operating on the VMA

It is possible to hit a zero entry while traversing the vmas in unuse_mm()
called from swapoff path and accessing it causes the OOPS:

Unable to handle kernel NULL pointer dereference at virtual address
0000000000000446--> Loading the memory from offset 0x40 on the
XA_ZERO_ENTRY as address.
Mem abort info:
  ESR = 0x0000000096000005
  EC = 0x25: DABT (current EL), IL = 32 bits
  SET = 0, FnV = 0
  EA = 0, S1PTW = 0
  FSC = 0x05: level 1 translation fault

The issue is manifested from the below race between the fork() on a
process and swapoff:
fork(dup_mmap())			swapoff(unuse_mm)
---------------                         -----------------
1) Identical mtree is built using
   __mt_dup().

2) copy_pte_range()-->
	copy_nonpresent_pte():
       The dst mm is added into the
    mmlist to be visible to the
    swapoff operation.

3) Fatal signal is sent to the parent
process(which is the current during the
fork) thus skip the duplication of the
vmas and mark the vma range with
XA_ZERO_ENTRY as a marker for this process
that helps during exit_mmap().

				     4) swapoff is tried on the
					'mm' added to the 'mmlist' as
					part of the 2.

				     5) unuse_mm(), that iterates
					through the vma's of this 'mm'
					will hit the non-NULL zero entry
					and operating on this zero entry
					as a vma is resulting into the
					oops.

The proper fix would be around not exposing this partially-valid tree to
others when droping the mmap lock, which is being solved with [1].  A
simpler solution would be checking for MMF_UNSTABLE, as it is set if
mm_struct is not fully initialized in dup_mmap().

Thanks to Liam/Lorenzo/David for all the suggestions in fixing this
issue.

The Linux kernel CVE team has assigned CVE-2025-39992 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 6.8 with commit d2406291483775ecddaee929231a39c70c08fda2 and fixed in 6.12.51 with commit 4e5f060d7347466f77aaff1c0d5a6c4f1fb217ac
	Issue introduced in 6.8 with commit d2406291483775ecddaee929231a39c70c08fda2 and fixed in 6.16.11 with commit 9cddad3b26dac830407d2d3c0de5205ff6d6dda0
	Issue introduced in 6.8 with commit d2406291483775ecddaee929231a39c70c08fda2 and fixed in 6.17.1 with commit e4e99d69b8b8295c501b2eef89e13306b738b667
	Issue introduced in 6.8 with commit d2406291483775ecddaee929231a39c70c08fda2 and fixed in 6.18-rc1 with commit 1367da7eb875d01102d2ed18654b24d261ff5393

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2025-39992
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	mm/swapfile.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/4e5f060d7347466f77aaff1c0d5a6c4f1fb217ac
	https://git.kernel.org/stable/c/9cddad3b26dac830407d2d3c0de5205ff6d6dda0
	https://git.kernel.org/stable/c/e4e99d69b8b8295c501b2eef89e13306b738b667
	https://git.kernel.org/stable/c/1367da7eb875d01102d2ed18654b24d261ff5393
