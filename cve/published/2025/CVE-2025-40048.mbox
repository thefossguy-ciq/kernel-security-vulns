From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2025-40048: uio_hv_generic: Let userspace take care of interrupt mask
Message-Id: <2025102814-CVE-2025-40048-3bce@gregkh>
Content-Length: 4787
Lines: 94
X-Developer-Signature: v=1; a=openpgp-sha256; l=4882;
 i=gregkh@linuxfoundation.org; h=from:subject:message-id;
 bh=Eg5TdoF+5fLscJ8ACupftnGe6+FnBA+qxQHy+4NkxdQ=;
 b=owGbwMvMwCRo6H6F97bub03G02pJDJkMa+tOrZvVknVsel2gFOsB46b5kj1TsutnGez75H3Tg
 O+M0OX0jlgWBkEmBlkxRZYv23iO7q84pOhlaHsaZg4rE8gQBi5OAZiI/z6GBcvqC/Xdu/5VOgss
 +9Wnnaw2sS5amGGu5OEbLreKX1RouZ07WGjvcmixY+tjAA==
X-Developer-Key: i=gregkh@linuxfoundation.org; a=openpgp;
 fpr=F4B60CC5BF78C2214A313DCB3147D40DDB2DFB29

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

uio_hv_generic: Let userspace take care of interrupt mask

Remove the logic to set interrupt mask by default in uio_hv_generic
driver as the interrupt mask value is supposed to be controlled
completely by the user space. If the mask bit gets changed
by the driver, concurrently with user mode operating on the ring,
the mask bit may be set when it is supposed to be clear, and the
user-mode driver will miss an interrupt which will cause a hang.

For eg- when the driver sets inbound ring buffer interrupt mask to 1,
the host does not interrupt the guest on the UIO VMBus channel.
However, setting the mask does not prevent the host from putting a
message in the inbound ring buffer. So let’s assume that happens,
the host puts a message into the ring buffer but does not interrupt.

Subsequently, the user space code in the guest sets the inbound ring
buffer interrupt mask to 0, saying “Hey, I’m ready for interrupts”.
User space code then calls pread() to wait for an interrupt.
Then one of two things happens:

* The host never sends another message. So the pread() waits forever.
* The host does send another message. But because there’s already a
  message in the ring buffer, it doesn’t generate an interrupt.
  This is the correct behavior, because the host should only send an
  interrupt when the inbound ring buffer transitions from empty to
  not-empty. Adding an additional message to a ring buffer that is not
  empty is not supposed to generate an interrupt on the guest.
  Since the guest is waiting in pread() and not removing messages from
  the ring buffer, the pread() waits forever.

This could be easily reproduced in hv_fcopy_uio_daemon if we delay
setting interrupt mask to 0.

Similarly if hv_uio_channel_cb() sets the interrupt_mask to 1,
there’s a race condition. Once user space empties the inbound ring
buffer, but before user space sets interrupt_mask to 0, the host could
put another message in the ring buffer but it wouldn’t interrupt.
Then the next pread() would hang.

Fix these by removing all instances where interrupt_mask is changed,
while keeping the one in set_event() unchanged to enable userspace
control the interrupt mask by writing 0/1 to /dev/uioX.

The Linux kernel CVE team has assigned CVE-2025-40048 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 4.10 with commit 95096f2fbd10186d3e78a328b327afc71428f65f and fixed in 5.15.195 with commit a44f61f878f32071d6378e8dd7c2d47f9490c8f7
	Issue introduced in 4.10 with commit 95096f2fbd10186d3e78a328b327afc71428f65f and fixed in 6.1.156 with commit 01ce972e6f9974a7c76943bcb7e93746917db83a
	Issue introduced in 4.10 with commit 95096f2fbd10186d3e78a328b327afc71428f65f and fixed in 6.6.112 with commit 2af39ab5e6dc46b835a52e80a22d0cad430985e3
	Issue introduced in 4.10 with commit 95096f2fbd10186d3e78a328b327afc71428f65f and fixed in 6.12.53 with commit 37bd91f22794dc05436130d6983302cb90ecfe7e
	Issue introduced in 4.10 with commit 95096f2fbd10186d3e78a328b327afc71428f65f and fixed in 6.17.3 with commit e29587c07537929684faa365027f4b0d87521e1b
	Issue introduced in 4.10 with commit 95096f2fbd10186d3e78a328b327afc71428f65f and fixed in 6.18-rc1 with commit b15b7d2a1b09ef5428a8db260251897405a19496

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2025-40048
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	drivers/uio/uio_hv_generic.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/a44f61f878f32071d6378e8dd7c2d47f9490c8f7
	https://git.kernel.org/stable/c/01ce972e6f9974a7c76943bcb7e93746917db83a
	https://git.kernel.org/stable/c/2af39ab5e6dc46b835a52e80a22d0cad430985e3
	https://git.kernel.org/stable/c/37bd91f22794dc05436130d6983302cb90ecfe7e
	https://git.kernel.org/stable/c/e29587c07537929684faa365027f4b0d87521e1b
	https://git.kernel.org/stable/c/b15b7d2a1b09ef5428a8db260251897405a19496
