From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2025-39737: mm/kmemleak: avoid soft lockup in __kmemleak_do_cleanup()

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

mm/kmemleak: avoid soft lockup in __kmemleak_do_cleanup()

A soft lockup warning was observed on a relative small system x86-64
system with 16 GB of memory when running a debug kernel with kmemleak
enabled.

  watchdog: BUG: soft lockup - CPU#8 stuck for 33s! [kworker/8:1:134]

The test system was running a workload with hot unplug happening in
parallel.  Then kemleak decided to disable itself due to its inability to
allocate more kmemleak objects.  The debug kernel has its
CONFIG_DEBUG_KMEMLEAK_MEM_POOL_SIZE set to 40,000.

The soft lockup happened in kmemleak_do_cleanup() when the existing
kmemleak objects were being removed and deleted one-by-one in a loop via a
workqueue.  In this particular case, there are at least 40,000 objects
that need to be processed and given the slowness of a debug kernel and the
fact that a raw_spinlock has to be acquired and released in
__delete_object(), it could take a while to properly handle all these
objects.

As kmemleak has been disabled in this case, the object removal and
deletion process can be further optimized as locking isn't really needed. 
However, it is probably not worth the effort to optimize for such an edge
case that should rarely happen.  So the simple solution is to call
cond_resched() at periodic interval in the iteration loop to avoid soft
lockup.

The Linux kernel CVE team has assigned CVE-2025-39737 to this issue.


Affected and fixed versions
===========================

	Fixed in 5.4.297 with commit 9f1f4e95031f84867c5821540466d62f88dab8ca
	Fixed in 5.10.241 with commit 1ef72a7fedc5bca70e8cc980985790de10d407aa
	Fixed in 5.15.190 with commit a04de4c40aab9b338dfa989cf4aec70fd187eeb2
	Fixed in 6.1.149 with commit f014c10d190b92aad366e56b445daffcd1c075e4
	Fixed in 6.6.103 with commit e21a3ddd58733ce31afcb1e5dc3cb80a4b5bc29b
	Fixed in 6.12.43 with commit 8d2d22a55ffe35c38e69795468a7addd1a80e9ce
	Fixed in 6.15.11 with commit 926092268efdf1ed7b55cf486356c74a9e7710d1
	Fixed in 6.16.2 with commit 9b80430c194e4a114dc663c1025d56b4f3d0153d
	Fixed in 6.17 with commit d1534ae23c2b6be350c8ab060803fbf6e9682adc

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2025-39737
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	mm/kmemleak.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/9f1f4e95031f84867c5821540466d62f88dab8ca
	https://git.kernel.org/stable/c/1ef72a7fedc5bca70e8cc980985790de10d407aa
	https://git.kernel.org/stable/c/a04de4c40aab9b338dfa989cf4aec70fd187eeb2
	https://git.kernel.org/stable/c/f014c10d190b92aad366e56b445daffcd1c075e4
	https://git.kernel.org/stable/c/e21a3ddd58733ce31afcb1e5dc3cb80a4b5bc29b
	https://git.kernel.org/stable/c/8d2d22a55ffe35c38e69795468a7addd1a80e9ce
	https://git.kernel.org/stable/c/926092268efdf1ed7b55cf486356c74a9e7710d1
	https://git.kernel.org/stable/c/9b80430c194e4a114dc663c1025d56b4f3d0153d
	https://git.kernel.org/stable/c/d1534ae23c2b6be350c8ab060803fbf6e9682adc
