From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2023-54113: rcu: dump vmalloc memory info safely
Message-Id: <2025122414-CVE-2023-54113-de5f@gregkh>
Content-Length: 4930
Lines: 109
X-Developer-Signature: v=1; a=openpgp-sha256; l=5040;
 i=gregkh@linuxfoundation.org; h=from:subject:message-id;
 bh=rGgDNYk6VQyk4IexDHnbTc7wZYqlMbJNjlGYaNNU0K0=;
 b=owGbwMvMwCRo6H6F97bub03G02pJDJneT93WvzXfG117o3i3z43LgfLztJoZD96dmN+dElpxw
 v/jCYYZHbEsDIJMDLJiiixftvEc3V9xSNHL0PY0zBxWJpAhDFycAjARQ2eGBZ1aN17OO74xwcc2
 9MyS4KK8sHUq5QzzLH7O89tf7J3YWO93/jxb97ykcMdVAA==
X-Developer-Key: i=gregkh@linuxfoundation.org; a=openpgp;
 fpr=F4B60CC5BF78C2214A313DCB3147D40DDB2DFB29

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

rcu: dump vmalloc memory info safely

Currently, for double invoke call_rcu(), will dump rcu_head objects memory
info, if the objects is not allocated from the slab allocator, the
vmalloc_dump_obj() will be invoke and the vmap_area_lock spinlock need to
be held, since the call_rcu() can be invoked in interrupt context,
therefore, there is a possibility of spinlock deadlock scenarios.

And in Preempt-RT kernel, the rcutorture test also trigger the following
lockdep warning:

BUG: sleeping function called from invalid context at kernel/locking/spinlock_rt.c:48
in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 1, name: swapper/0
preempt_count: 1, expected: 0
RCU nest depth: 1, expected: 1
3 locks held by swapper/0/1:
 #0: ffffffffb534ee80 (fullstop_mutex){+.+.}-{4:4}, at: torture_init_begin+0x24/0xa0
 #1: ffffffffb5307940 (rcu_read_lock){....}-{1:3}, at: rcu_torture_init+0x1ec7/0x2370
 #2: ffffffffb536af40 (vmap_area_lock){+.+.}-{3:3}, at: find_vmap_area+0x1f/0x70
irq event stamp: 565512
hardirqs last  enabled at (565511): [<ffffffffb379b138>] __call_rcu_common+0x218/0x940
hardirqs last disabled at (565512): [<ffffffffb5804262>] rcu_torture_init+0x20b2/0x2370
softirqs last  enabled at (399112): [<ffffffffb36b2586>] __local_bh_enable_ip+0x126/0x170
softirqs last disabled at (399106): [<ffffffffb43fef59>] inet_register_protosw+0x9/0x1d0
Preemption disabled at:
[<ffffffffb58040c3>] rcu_torture_init+0x1f13/0x2370
CPU: 0 PID: 1 Comm: swapper/0 Tainted: G        W          6.5.0-rc4-rt2-yocto-preempt-rt+ #15
Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS rel-1.16.2-0-gea1b7a073390-prebuilt.qemu.org 04/01/2014
Call Trace:
 <TASK>
 dump_stack_lvl+0x68/0xb0
 dump_stack+0x14/0x20
 __might_resched+0x1aa/0x280
 ? __pfx_rcu_torture_err_cb+0x10/0x10
 rt_spin_lock+0x53/0x130
 ? find_vmap_area+0x1f/0x70
 find_vmap_area+0x1f/0x70
 vmalloc_dump_obj+0x20/0x60
 mem_dump_obj+0x22/0x90
 __call_rcu_common+0x5bf/0x940
 ? debug_smp_processor_id+0x1b/0x30
 call_rcu_hurry+0x14/0x20
 rcu_torture_init+0x1f82/0x2370
 ? __pfx_rcu_torture_leak_cb+0x10/0x10
 ? __pfx_rcu_torture_leak_cb+0x10/0x10
 ? __pfx_rcu_torture_init+0x10/0x10
 do_one_initcall+0x6c/0x300
 ? debug_smp_processor_id+0x1b/0x30
 kernel_init_freeable+0x2b9/0x540
 ? __pfx_kernel_init+0x10/0x10
 kernel_init+0x1f/0x150
 ret_from_fork+0x40/0x50
 ? __pfx_kernel_init+0x10/0x10
 ret_from_fork_asm+0x1b/0x30
 </TASK>

The previous patch fixes this by using the deadlock-safe best-effort
version of find_vm_area.  However, in case of failure print the fact that
the pointer was a vmalloc pointer so that we print at least something.

The Linux kernel CVE team has assigned CVE-2023-54113 to this issue.


Affected and fixed versions
===========================

	Issue introduced in 5.12 with commit 98f180837a896ecedf8f7e12af22b57f271d43c9 and fixed in 5.15.132 with commit 0a22f9c17b1aa2a35b5eedee928f7841595b55cd
	Issue introduced in 5.12 with commit 98f180837a896ecedf8f7e12af22b57f271d43c9 and fixed in 6.1.53 with commit 3f7a4e88e40e38c0b16a4bcb599b7b1d8c81440d
	Issue introduced in 5.12 with commit 98f180837a896ecedf8f7e12af22b57f271d43c9 and fixed in 6.4.16 with commit dddca4c46ec92f83449bc91dd199f46a89e066be
	Issue introduced in 5.12 with commit 98f180837a896ecedf8f7e12af22b57f271d43c9 and fixed in 6.5.3 with commit 8fb1601ec0a2c4c34fc2170af767e5c2a6400573
	Issue introduced in 5.12 with commit 98f180837a896ecedf8f7e12af22b57f271d43c9 and fixed in 6.6 with commit c83ad36a18c02c0f51280b50272327807916987f

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2023-54113
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	mm/util.c


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/0a22f9c17b1aa2a35b5eedee928f7841595b55cd
	https://git.kernel.org/stable/c/3f7a4e88e40e38c0b16a4bcb599b7b1d8c81440d
	https://git.kernel.org/stable/c/dddca4c46ec92f83449bc91dd199f46a89e066be
	https://git.kernel.org/stable/c/8fb1601ec0a2c4c34fc2170af767e5c2a6400573
	https://git.kernel.org/stable/c/c83ad36a18c02c0f51280b50272327807916987f
