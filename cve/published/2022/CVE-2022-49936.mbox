From bippy-1.2.0 Mon Sep 17 00:00:00 2001
From: Greg Kroah-Hartman <gregkh@kernel.org>
To: <linux-cve-announce@vger.kernel.org>
Reply-to: <cve@kernel.org>, <linux-kernel@vger.kernel.org>
Subject: CVE-2022-49936: USB: core: Prevent nested device-reset calls
Message-Id: <2025061847-CVE-2022-49936-f434@gregkh>
Content-Length: 5036
Lines: 117
X-Developer-Signature: v=1; a=openpgp-sha256; l=5154;
 i=gregkh@linuxfoundation.org; h=from:subject:message-id;
 bh=+mKzpiALHZ8nsFZ7Ab8sXyaIwn+YbkN6j2Bn+ojD90A=;
 b=owGbwMvMwCRo6H6F97bub03G02pJDBlBs76/TjNYGn8/jqeeVd52x1v3GzlbOW1vagV2Je/cm
 922u168I5aFQZCJQVZMkeXLNp6j+ysOKXoZ2p6GmcPKBDKEgYtTACayPpBhNrtAvnaqaItn8p4d
 vufvzKmPD4j+zjBXRCREa+Oaqum2V264ydwrvT3z/i1/AA==
X-Developer-Key: i=gregkh@linuxfoundation.org; a=openpgp;
 fpr=F4B60CC5BF78C2214A313DCB3147D40DDB2DFB29

Description
===========

In the Linux kernel, the following vulnerability has been resolved:

USB: core: Prevent nested device-reset calls

Automatic kernel fuzzing revealed a recursive locking violation in
usb-storage:

============================================
WARNING: possible recursive locking detected
5.18.0 #3 Not tainted
--------------------------------------------
kworker/1:3/1205 is trying to acquire lock:
ffff888018638db8 (&us_interface_key[i]){+.+.}-{3:3}, at:
usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230

but task is already holding lock:
ffff888018638db8 (&us_interface_key[i]){+.+.}-{3:3}, at:
usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230

...

stack backtrace:
CPU: 1 PID: 1205 Comm: kworker/1:3 Not tainted 5.18.0 #3
Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS
1.13.0-1ubuntu1.1 04/01/2014
Workqueue: usb_hub_wq hub_event
Call Trace:
<TASK>
__dump_stack lib/dump_stack.c:88 [inline]
dump_stack_lvl+0xcd/0x134 lib/dump_stack.c:106
print_deadlock_bug kernel/locking/lockdep.c:2988 [inline]
check_deadlock kernel/locking/lockdep.c:3031 [inline]
validate_chain kernel/locking/lockdep.c:3816 [inline]
__lock_acquire.cold+0x152/0x3ca kernel/locking/lockdep.c:5053
lock_acquire kernel/locking/lockdep.c:5665 [inline]
lock_acquire+0x1ab/0x520 kernel/locking/lockdep.c:5630
__mutex_lock_common kernel/locking/mutex.c:603 [inline]
__mutex_lock+0x14f/0x1610 kernel/locking/mutex.c:747
usb_stor_pre_reset+0x35/0x40 drivers/usb/storage/usb.c:230
usb_reset_device+0x37d/0x9a0 drivers/usb/core/hub.c:6109
r871xu_dev_remove+0x21a/0x270 drivers/staging/rtl8712/usb_intf.c:622
usb_unbind_interface+0x1bd/0x890 drivers/usb/core/driver.c:458
device_remove drivers/base/dd.c:545 [inline]
device_remove+0x11f/0x170 drivers/base/dd.c:537
__device_release_driver drivers/base/dd.c:1222 [inline]
device_release_driver_internal+0x1a7/0x2f0 drivers/base/dd.c:1248
usb_driver_release_interface+0x102/0x180 drivers/usb/core/driver.c:627
usb_forced_unbind_intf+0x4d/0xa0 drivers/usb/core/driver.c:1118
usb_reset_device+0x39b/0x9a0 drivers/usb/core/hub.c:6114

This turned out not to be an error in usb-storage but rather a nested
device reset attempt.  That is, as the rtl8712 driver was being
unbound from a composite device in preparation for an unrelated USB
reset (that driver does not have pre_reset or post_reset callbacks),
its ->remove routine called usb_reset_device() -- thus nesting one
reset call within another.

Performing a reset as part of disconnect processing is a questionable
practice at best.  However, the bug report points out that the USB
core does not have any protection against nested resets.  Adding a
reset_in_progress flag and testing it will prevent such errors in the
future.

The Linux kernel CVE team has assigned CVE-2022-49936 to this issue.


Affected and fixed versions
===========================

	Fixed in 4.9.328 with commit d90419b8b8322b6924f6da9da952647f2dadc21b
	Fixed in 4.14.293 with commit 1b29498669914c7f9afb619722421418a753d372
	Fixed in 4.19.258 with commit cc9a12e12808af178c600cc485338bac2e37d2a8
	Fixed in 5.4.213 with commit df1875084898b15cbc42f712e93d7f113ae6271b
	Fixed in 5.10.142 with commit abe3cfb7a7c8e907b312c7dbd7bf4d142b745aa8
	Fixed in 5.15.66 with commit c548b99e1c37db6f7df86ecfe9a1f895d6c5966e
	Fixed in 5.19.8 with commit d5eb850b3e8836197a38475840725260b9783e94
	Fixed in 6.0 with commit 9c6d778800b921bde3bff3cff5003d1650f942d1

Please see https://www.kernel.org for a full list of currently supported
kernel versions by the kernel community.

Unaffected versions might change over time as fixes are backported to
older supported kernel versions.  The official CVE entry at
	https://cve.org/CVERecord/?id=CVE-2022-49936
will be updated if fixes are backported, please check that for the most
up to date information about this issue.


Affected files
==============

The file(s) affected by this issue are:
	drivers/usb/core/hub.c
	include/linux/usb.h


Mitigation
==========

The Linux kernel CVE team recommends that you update to the latest
stable kernel version for this, and many other bugfixes.  Individual
changes are never tested alone, but rather are part of a larger kernel
release.  Cherry-picking individual commits is not recommended or
supported by the Linux kernel community at all.  If however, updating to
the latest release is impossible, the individual changes to resolve this
issue can be found at these commits:
	https://git.kernel.org/stable/c/d90419b8b8322b6924f6da9da952647f2dadc21b
	https://git.kernel.org/stable/c/1b29498669914c7f9afb619722421418a753d372
	https://git.kernel.org/stable/c/cc9a12e12808af178c600cc485338bac2e37d2a8
	https://git.kernel.org/stable/c/df1875084898b15cbc42f712e93d7f113ae6271b
	https://git.kernel.org/stable/c/abe3cfb7a7c8e907b312c7dbd7bf4d142b745aa8
	https://git.kernel.org/stable/c/c548b99e1c37db6f7df86ecfe9a1f895d6c5966e
	https://git.kernel.org/stable/c/d5eb850b3e8836197a38475840725260b9783e94
	https://git.kernel.org/stable/c/9c6d778800b921bde3bff3cff5003d1650f942d1
